{
  "0": [
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/error.js",
      "startLine": 131,
      "endLine": 132,
      "before": "function (ex) {\n  let se;\n  let msg = '';\n  let withStack = false;\n  let quit = false;\n  let etype = 'warning';\n\n  if (this.debug) {\n    withStack = true;\n  }\n\n  switch (ex.fluenterror) {\n    case HMSTATUS.themeNotFound:\n      msg = printf(M2C(this.msgs.themeNotFound.msg, 'yellow'), ex.data);\n      break;\n\n    case HMSTATUS.copyCSS:\n      msg = M2C(this.msgs.copyCSS.msg, 'red');\n      quit = false;\n      break;\n\n    case HMSTATUS.resumeNotFound:\n      //msg = M2C( this.msgs.resumeNotFound.msg, 'yellow' );\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, `help/${ex.verb}.txt`), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.missingCommand:\n      // msg = M2C( this.msgs.missingCommand.msg + \" (\", 'yellow');\n      // msg += Object.keys( FCMD.verbs ).map( (v, idx, ar) ->\n      //   return ( if idx == ar.length - 1 then chalk.yellow('or ') else '') +\n      //     chalk.yellow.bold(v.toUpperCase());\n      // ).join( chalk.yellow(', ')) + chalk.yellow(\").\\n\\n\");\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, 'help/use.txt'), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.invalidCommand:\n      msg = printf(M2C(this.msgs.invalidCommand.msg, 'yellow'), ex.attempted);\n      break;\n\n    case HMSTATUS.resumeNotFoundAlt:\n      msg = M2C(this.msgs.resumeNotFoundAlt.msg, 'yellow');\n      break;\n\n    case HMSTATUS.inputOutputParity:\n      msg = M2C(this.msgs.inputOutputParity.msg);\n      break;\n\n    case HMSTATUS.createNameMissing:\n      msg = M2C(this.msgs.createNameMissing.msg);\n      break;\n\n    case HMSTATUS.pdfGeneration:\n      msg = M2C(this.msgs.pdfGeneration.msg, 'bold');\n\n      if (ex.inner) {\n        msg += chalk.red(`\\n${ex.inner}`);\n      }\n\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalid:\n      msg = M2C(this.msgs.invalid.msg, 'red');\n      etype = 'error';\n      break;\n\n    case HMSTATUS.generateError:\n      msg = ex.inner && ex.inner.toString() || ex;\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.fileSaveError:\n      msg = printf(M2C(this.msgs.fileSaveError.msg), (ex.inner || ex).toString());\n      etype = 'error';\n      quit = false;\n      break;\n\n    case HMSTATUS.invalidFormat:\n      ex.data.forEach(function (d) {\n        return msg += printf(M2C(this.msgs.invalidFormat.msg, 'bold'), ex.theme.name.toUpperCase(), d.format.toUpperCase());\n      }, this);\n      break;\n\n    case HMSTATUS.missingParam:\n      msg = printf(M2C(this.msgs.missingParam.msg), ex.expected, ex.helper);\n      break;\n\n    case HMSTATUS.invalidHelperUse:\n      msg = printf(M2C(this.msgs.invalidHelperUse.msg), ex.helper);\n\n      if (ex.error) {\n        msg += `\\n--> ${assembleError.call(this, extend(true, {}, ex, {\n          fluenterror: ex.error\n        })).msg}`;\n      } //msg += printf( '\\n--> ' + M2C( this.msgs.invalidParamCount.msg ), ex.expected );\n\n\n      quit = false;\n      etype = 'warning';\n      break;\n\n    case HMSTATUS.notOnPath:\n      msg = printf(M2C(this.msgs.notOnPath.msg, 'bold'), ex.engine);\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.readError:\n      if (!ex.quiet) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n      }\n\n      msg = ex.inner.toString();\n      etype = 'error';\n      break;\n\n    case HMSTATUS.mixedMerge:\n      msg = M2C(this.msgs.mixedMerge.msg);\n      quit = false;\n      break;\n\n    case HMSTATUS.invokeTemplate:\n      msg = M2C(this.msgs.invokeTemplate.msg, 'red');\n      msg += M2C(`\\n${WRAP(ex.inner.toString(), {\n        width: 60,\n        indent: '   '\n      })}`, 'gray');\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.compileTemplate:\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeLoad:\n      msg = M2C(printf(this.msgs.themeLoad.msg, ex.attempted.toUpperCase()), 'red');\n\n      if (ex.inner && ex.inner.fluenterror) {\n        msg += M2C('\\nError: ', 'red') + assembleError.call(this, ex.inner).msg;\n      }\n\n      quit = true;\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.parseError:\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg = M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg = ex;\n      }\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.createError:\n      // inner.code could be EPERM, EACCES, etc\n      msg = printf(M2C(this.msgs.createError.msg), ex.inner.path);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.validateError:\n      msg = printf(M2C(this.msgs.validateError.msg), ex.inner.toString());\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidOptionsFile:\n      msg = M2C(this.msgs.invalidOptionsFile.msg[0]);\n\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg += M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg += ex;\n      }\n\n      msg += this.msgs.invalidOptionsFile.msg[1];\n      etype = 'error';\n      break;\n\n    case HMSTATUS.optionsFileNotFound:\n      msg = M2C(this.msgs.optionsFileNotFound.msg);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.unknownSchema:\n      msg = M2C(this.msgs.unknownSchema.msg[0]); //msg += \"\\n\" + M2C( @msgs.unknownSchema.msg[1], 'yellow' )\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeHelperLoad:\n      msg = printf(M2C(this.msgs.themeHelperLoad.msg), ex.glob);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidSchemaVersion:\n      msg = printf(M2C(this.msgs.invalidSchemaVersion.msg), ex.data);\n      etype = 'error';\n      break;\n  }\n\n  return {\n    msg,\n    // The error message to display\n    withStack,\n    // Whether to include the stack\n    quit,\n    etype\n  };\n}",
      "after": "async function (ex) {\n  let se;\n  let msg = '';\n  let withStack = false;\n  let quit = false;\n  let etype = 'warning';\n\n  if (this.debug) {\n    withStack = true;\n  }\n\n  switch (ex.fluenterror) {\n    case HMSTATUS.themeNotFound:\n      msg = printf(M2C(this.msgs.themeNotFound.msg, 'yellow'), ex.data);\n      break;\n\n    case HMSTATUS.copyCSS:\n      msg = M2C(this.msgs.copyCSS.msg, 'red');\n      quit = false;\n      break;\n\n    case HMSTATUS.resumeNotFound:\n      //msg = M2C( this.msgs.resumeNotFound.msg, 'yellow' );\n      msg += M2C(await FS.promises.readFile(PATH.resolve(__dirname, `help/${ex.verb}.txt`), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.missingCommand:\n      // msg = M2C( this.msgs.missingCommand.msg + \" (\", 'yellow');\n      // msg += Object.keys( FCMD.verbs ).map( (v, idx, ar) ->\n      //   return ( if idx == ar.length - 1 then chalk.yellow('or ') else '') +\n      //     chalk.yellow.bold(v.toUpperCase());\n      // ).join( chalk.yellow(', ')) + chalk.yellow(\").\\n\\n\");\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, 'help/use.txt'), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.invalidCommand:\n      msg = printf(M2C(this.msgs.invalidCommand.msg, 'yellow'), ex.attempted);\n      break;\n\n    case HMSTATUS.resumeNotFoundAlt:\n      msg = M2C(this.msgs.resumeNotFoundAlt.msg, 'yellow');\n      break;\n\n    case HMSTATUS.inputOutputParity:\n      msg = M2C(this.msgs.inputOutputParity.msg);\n      break;\n\n    case HMSTATUS.createNameMissing:\n      msg = M2C(this.msgs.createNameMissing.msg);\n      break;\n\n    case HMSTATUS.pdfGeneration:\n      msg = M2C(this.msgs.pdfGeneration.msg, 'bold');\n\n      if (ex.inner) {\n        msg += chalk.red(`\\n${ex.inner}`);\n      }\n\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalid:\n      msg = M2C(this.msgs.invalid.msg, 'red');\n      etype = 'error';\n      break;\n\n    case HMSTATUS.generateError:\n      msg = ex.inner && ex.inner.toString() || ex;\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.fileSaveError:\n      msg = printf(M2C(this.msgs.fileSaveError.msg), (ex.inner || ex).toString());\n      etype = 'error';\n      quit = false;\n      break;\n\n    case HMSTATUS.invalidFormat:\n      ex.data.forEach(function (d) {\n        return msg += printf(M2C(this.msgs.invalidFormat.msg, 'bold'), ex.theme.name.toUpperCase(), d.format.toUpperCase());\n      }, this);\n      break;\n\n    case HMSTATUS.missingParam:\n      msg = printf(M2C(this.msgs.missingParam.msg), ex.expected, ex.helper);\n      break;\n\n    case HMSTATUS.invalidHelperUse:\n      msg = printf(M2C(this.msgs.invalidHelperUse.msg), ex.helper);\n\n      if (ex.error) {\n        msg += `\\n--> ${assembleError.call(this, extend(true, {}, ex, {\n          fluenterror: ex.error\n        })).msg}`;\n      } //msg += printf( '\\n--> ' + M2C( this.msgs.invalidParamCount.msg ), ex.expected );\n\n\n      quit = false;\n      etype = 'warning';\n      break;\n\n    case HMSTATUS.notOnPath:\n      msg = printf(M2C(this.msgs.notOnPath.msg, 'bold'), ex.engine);\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.readError:\n      if (!ex.quiet) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n      }\n\n      msg = ex.inner.toString();\n      etype = 'error';\n      break;\n\n    case HMSTATUS.mixedMerge:\n      msg = M2C(this.msgs.mixedMerge.msg);\n      quit = false;\n      break;\n\n    case HMSTATUS.invokeTemplate:\n      msg = M2C(this.msgs.invokeTemplate.msg, 'red');\n      msg += M2C(`\\n${WRAP(ex.inner.toString(), {\n        width: 60,\n        indent: '   '\n      })}`, 'gray');\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.compileTemplate:\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeLoad:\n      msg = M2C(printf(this.msgs.themeLoad.msg, ex.attempted.toUpperCase()), 'red');\n\n      if (ex.inner && ex.inner.fluenterror) {\n        msg += M2C('\\nError: ', 'red') + assembleError.call(this, ex.inner).msg;\n      }\n\n      quit = true;\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.parseError:\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg = M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg = ex;\n      }\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.createError:\n      // inner.code could be EPERM, EACCES, etc\n      msg = printf(M2C(this.msgs.createError.msg), ex.inner.path);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.validateError:\n      msg = printf(M2C(this.msgs.validateError.msg), ex.inner.toString());\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidOptionsFile:\n      msg = M2C(this.msgs.invalidOptionsFile.msg[0]);\n\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg += M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg += ex;\n      }\n\n      msg += this.msgs.invalidOptionsFile.msg[1];\n      etype = 'error';\n      break;\n\n    case HMSTATUS.optionsFileNotFound:\n      msg = M2C(this.msgs.optionsFileNotFound.msg);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.unknownSchema:\n      msg = M2C(this.msgs.unknownSchema.msg[0]); //msg += \"\\n\" + M2C( @msgs.unknownSchema.msg[1], 'yellow' )\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeHelperLoad:\n      msg = printf(M2C(this.msgs.themeHelperLoad.msg), ex.glob);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidSchemaVersion:\n      msg = printf(M2C(this.msgs.invalidSchemaVersion.msg), ex.data);\n      etype = 'error';\n      break;\n  }\n\n  return {\n    msg,\n    // The error message to display\n    withStack,\n    // Whether to include the stack\n    quit,\n    etype\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/error.js",
      "startLine": 56,
      "endLine": 56,
      "before": "err(ex, shouldExit) {\n  // Short-circuit logging output if --silent is on\n  let stack;\n  const o = this.silent ? function () {} : _defaultLog; // Special case; can probably be removed.\n\n  if (ex.pass) {\n    throw ex;\n  } // Load error messages\n\n\n  this.msgs = this.msgs || require('./msg').errors; // Handle packaged HMR exceptions\n\n  if (ex.fluenterror) {\n    // Output the error message\n    const objError = assembleError.call(this, ex);\n    o(this[`format_${objError.etype}`](objError.msg)); // Output the stack (sometimes)\n\n    if (objError.withStack) {\n      stack = ex.stack || ex.inner && ex.inner.stack;\n      stack && o(chalk.gray(stack));\n    } // Quit if necessary\n\n\n    if (shouldExit || ex.exit) {\n      if (this.debug) {\n        o(chalk.cyan(`Exiting with error code ${ex.fluenterror.toString()}`));\n      }\n\n      if (this.assert) {\n        ex.pass = true;\n        throw ex;\n      }\n\n      return process.exit(ex.fluenterror);\n    } // Handle raw exceptions\n\n  } else {\n    o(ex);\n    const stackTrace = ex.stack || ex.inner && ex.inner.stack;\n\n    if (stackTrace && this.debug) {\n      return o(M2C(ex.stack || ex.inner.stack, 'gray'));\n    }\n  }\n}",
      "after": "async err(ex, shouldExit) {\n  // Short-circuit logging output if --silent is on\n  let stack;\n  const o = this.silent ? function () {} : _defaultLog; // Special case; can probably be removed.\n\n  if (ex.pass) {\n    throw ex;\n  } // Load error messages\n\n\n  this.msgs = this.msgs || require('./msg').errors; // Handle packaged HMR exceptions\n\n  if (ex.fluenterror) {\n    // Output the error message\n    const objError = await assembleError.call(this, ex);\n    o(this[`format_${objError.etype}`](objError.msg)); // Output the stack (sometimes)\n\n    if (objError.withStack) {\n      stack = ex.stack || ex.inner && ex.inner.stack;\n      stack && o(chalk.gray(stack));\n    } // Quit if necessary\n\n\n    if (shouldExit || ex.exit) {\n      if (this.debug) {\n        o(chalk.cyan(`Exiting with error code ${ex.fluenterror.toString()}`));\n      }\n\n      if (this.assert) {\n        ex.pass = true;\n        throw ex;\n      }\n\n      return process.exit(ex.fluenterror);\n    } // Handle raw exceptions\n\n  } else {\n    o(ex);\n    const stackTrace = ex.stack || ex.inner && ex.inner.stack;\n\n    if (stackTrace && this.debug) {\n      return o(M2C(ex.stack || ex.inner.stack, 'gray'));\n    }\n  }\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/index.js",
      "startLine": 20,
      "endLine": 20,
      "before": "require('./error').err(ex, true)",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait require('./error').err(ex, true)"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/main.js",
      "startLine": 167,
      "endLine": 171,
      "before": "function (ar, exitCallback) {\n  _exitCallback = exitCallback || process.exit;\n  const o = initOptions(ar);\n\n  if (o.ex) {\n    _err.init(false, true, false);\n\n    if (o.ex.op === 'parse') {\n      _err.err({\n        fluenterror: o.ex.op === 'parse' ? HMSTATUS.invalidOptionsFile : HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    } else {\n      _err.err({\n        fluenterror: HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    }\n\n    return null;\n  }\n\n  o.silent || logMsg(_title); // Emit debug prelude if --debug was specified\n\n  if (o.debug) {\n    _out.log(chalk.cyan('The -d or --debug switch was specified. DEBUG mode engaged.'));\n\n    _out.log('');\n\n    _out.log(chalk.cyan(PAD('  Platform:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.platform === 'win32' ? 'windows' : process.platform));\n\n    _out.log(chalk.cyan(PAD('  Node.js:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.version));\n\n    _out.log(chalk.cyan(PAD('  HackMyResume:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(`v${PKG.version}`));\n\n    _out.log(chalk.cyan(PAD('  FRESCA:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(PKG.dependencies.fresca)); //_out.log(chalk.cyan(PAD('  fresh-themes:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-themes'] ))\n    //_out.log(chalk.cyan(PAD('  fresh-jrs-converter:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-jrs-converter'] ))\n\n\n    _out.log('');\n  }\n\n  _err.init(o.debug, o.assert, o.silent); // Handle invalid verbs here (a bit easier here than in commander.js)...\n\n\n  if (o.verb && !HMR.verbs[o.verb] && !HMR.alias[o.verb] && o.verb !== 'help') {\n    _err.err({\n      fluenterror: HMSTATUS.invalidCommand,\n      quit: true,\n      attempted: o.orgVerb\n    }, true);\n  } // Override the .missingArgument behavior\n\n\n  Command.prototype.missingArgument = function () {\n    if (this.name() !== 'help') {\n      _err.err({\n        verb: this.name(),\n        fluenterror: HMSTATUS.resumeNotFound\n      }, true);\n    }\n  }; // Override the .helpInformation behavior\n\n\n  Command.prototype.helpInformation = function () {\n    const manPage = FS.readFileSync(PATH.join(__dirname, 'help/use.txt'), 'utf8');\n    return M2C(manPage, 'white', 'yellow');\n  };\n\n  return {\n    args: o.args,\n    options: o.json\n  };\n}",
      "after": "async function (ar, exitCallback) {\n  _exitCallback = exitCallback || process.exit;\n  const o = initOptions(ar);\n\n  if (o.ex) {\n    _err.init(false, true, false);\n\n    if (o.ex.op === 'parse') {\n      await _err.err({\n        fluenterror: o.ex.op === 'parse' ? HMSTATUS.invalidOptionsFile : HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    } else {\n      _err.err({\n        fluenterror: HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    }\n\n    return null;\n  }\n\n  o.silent || logMsg(_title); // Emit debug prelude if --debug was specified\n\n  if (o.debug) {\n    _out.log(chalk.cyan('The -d or --debug switch was specified. DEBUG mode engaged.'));\n\n    _out.log('');\n\n    _out.log(chalk.cyan(PAD('  Platform:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.platform === 'win32' ? 'windows' : process.platform));\n\n    _out.log(chalk.cyan(PAD('  Node.js:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.version));\n\n    _out.log(chalk.cyan(PAD('  HackMyResume:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(`v${PKG.version}`));\n\n    _out.log(chalk.cyan(PAD('  FRESCA:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(PKG.dependencies.fresca)); //_out.log(chalk.cyan(PAD('  fresh-themes:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-themes'] ))\n    //_out.log(chalk.cyan(PAD('  fresh-jrs-converter:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-jrs-converter'] ))\n\n\n    _out.log('');\n  }\n\n  _err.init(o.debug, o.assert, o.silent); // Handle invalid verbs here (a bit easier here than in commander.js)...\n\n\n  if (o.verb && !HMR.verbs[o.verb] && !HMR.alias[o.verb] && o.verb !== 'help') {\n    _err.err({\n      fluenterror: HMSTATUS.invalidCommand,\n      quit: true,\n      attempted: o.orgVerb\n    }, true);\n  } // Override the .missingArgument behavior\n\n\n  Command.prototype.missingArgument = function () {\n    if (this.name() !== 'help') {\n      _err.err({\n        verb: this.name(),\n        fluenterror: HMSTATUS.resumeNotFound\n      }, true);\n    }\n  }; // Override the .helpInformation behavior\n\n\n  Command.prototype.helpInformation = function () {\n    const manPage = FS.readFileSync(PATH.join(__dirname, 'help/use.txt'), 'utf8');\n    return M2C(manPage, 'white', 'yellow');\n  };\n\n  return {\n    args: o.args,\n    options: o.json\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/main.js",
      "startLine": 46,
      "endLine": 46,
      "before": "function (rawArgs, exitCallback) {\n  const initInfo = initialize(rawArgs, exitCallback);\n\n  if (initInfo === null) {\n    return;\n  }\n\n  const {\n    args\n  } = initInfo; // Create the top-level (application) command...\n\n  const program = new Command('hackmyresume').version(PKG.version).description(chalk.yellow.bold('*** HackMyResume ***')).option('-s --silent', 'Run in silent mode').option('--no-color', 'Disable colors').option('--color', 'Enable colors').option('-d --debug', 'Enable diagnostics', false).option('-a --assert', 'Treat warnings as errors', false).option('-v --version', 'Show the version').allowUnknownOption();\n  program.jsonArgs = initInfo.options; // Create the NEW command\n\n  program.command('new').arguments('<sources...>').option('-f --format <fmt>', 'FRESH or JRS format', 'FRESH').alias('create').description('Create resume(s) in FRESH or JSON RESUME format.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the VALIDATE command\n\n  program.command('validate').arguments('<sources...>').description('Validate a resume in FRESH or JSON RESUME format.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the CONVERT command\n\n  program.command('convert').description('Convert a resume to/from FRESH or JSON RESUME format.').option('-f --format <fmt>', 'FRESH or JRS format and optional version', undefined).action(function () {\n    const x = splitSrcDest.call(this);\n    execute.call(this, x.src, x.dst, this.opts(), logMsg);\n  }); // Create the ANALYZE command\n\n  program.command('analyze').arguments('<sources...>').option('--private', 'Include resume fields marked as private', false).description('Analyze one or more resumes.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the PEEK command\n\n  program.command('peek').arguments('<sources...>').description('Peek at a resume field or section') //.action(( sources, sectionOrField ) ->\n  .action(function (sources) {\n    const dst = sources && sources.length > 1 ? [sources.pop()] : [];\n    execute.call(this, sources, dst, this.opts(), logMsg);\n  }); // Create the BUILD command\n\n  program.command('build').alias('generate').option('-t --theme <theme>', 'Theme name or path').option('-n --no-prettify', 'Disable HTML prettification', true).option('-c --css <option>', 'CSS linking / embedding').option('-p --pdf <engine>', 'PDF generation engine').option('--no-sort', 'Sort resume sections by date', false).option('--tips', 'Display theme tips and warnings.', false).option('--private', 'Include resume fields marked as private', false).option('--no-escape', 'Turn off encoding in Handlebars themes.', false).description('Generate resume to multiple formats') //.action(( sources, targets, options ) ->\n  .action(function () {\n    const x = splitSrcDest.call(this);\n    execute.call(this, x.src, x.dst, this.opts(), logMsg);\n  }); // Create the HELP command\n\n  program.command('help').arguments('[command]').description('Get help on a HackMyResume command').action(function (cmd) {\n    cmd = cmd || 'use';\n    const manPage = FS.readFileSync(PATH.join(__dirname, `help/${cmd}.txt`), 'utf8');\n\n    _out.log(M2C(manPage, 'white', 'yellow.bold'));\n  });\n  program.parse(args);\n\n  if (!program.args.length) {\n    throw {\n      fluenterror: 4\n    };\n  }\n}",
      "after": "async function (rawArgs, exitCallback) {\n  const initInfo = await initialize(rawArgs, exitCallback);\n\n  if (initInfo === null) {\n    return;\n  }\n\n  const {\n    args\n  } = initInfo; // Create the top-level (application) command...\n\n  const program = new Command('hackmyresume').version(PKG.version).description(chalk.yellow.bold('*** HackMyResume ***')).option('-s --silent', 'Run in silent mode').option('--no-color', 'Disable colors').option('--color', 'Enable colors').option('-d --debug', 'Enable diagnostics', false).option('-a --assert', 'Treat warnings as errors', false).option('-v --version', 'Show the version').allowUnknownOption();\n  program.jsonArgs = initInfo.options; // Create the NEW command\n\n  program.command('new').arguments('<sources...>').option('-f --format <fmt>', 'FRESH or JRS format', 'FRESH').alias('create').description('Create resume(s) in FRESH or JSON RESUME format.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the VALIDATE command\n\n  program.command('validate').arguments('<sources...>').description('Validate a resume in FRESH or JSON RESUME format.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the CONVERT command\n\n  program.command('convert').description('Convert a resume to/from FRESH or JSON RESUME format.').option('-f --format <fmt>', 'FRESH or JRS format and optional version', undefined).action(function () {\n    const x = splitSrcDest.call(this);\n    execute.call(this, x.src, x.dst, this.opts(), logMsg);\n  }); // Create the ANALYZE command\n\n  program.command('analyze').arguments('<sources...>').option('--private', 'Include resume fields marked as private', false).description('Analyze one or more resumes.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the PEEK command\n\n  program.command('peek').arguments('<sources...>').description('Peek at a resume field or section') //.action(( sources, sectionOrField ) ->\n  .action(function (sources) {\n    const dst = sources && sources.length > 1 ? [sources.pop()] : [];\n    execute.call(this, sources, dst, this.opts(), logMsg);\n  }); // Create the BUILD command\n\n  program.command('build').alias('generate').option('-t --theme <theme>', 'Theme name or path').option('-n --no-prettify', 'Disable HTML prettification', true).option('-c --css <option>', 'CSS linking / embedding').option('-p --pdf <engine>', 'PDF generation engine').option('--no-sort', 'Sort resume sections by date', false).option('--tips', 'Display theme tips and warnings.', false).option('--private', 'Include resume fields marked as private', false).option('--no-escape', 'Turn off encoding in Handlebars themes.', false).description('Generate resume to multiple formats') //.action(( sources, targets, options ) ->\n  .action(function () {\n    const x = splitSrcDest.call(this);\n    execute.call(this, x.src, x.dst, this.opts(), logMsg);\n  }); // Create the HELP command\n\n  program.command('help').arguments('[command]').description('Get help on a HackMyResume command').action(function (cmd) {\n    cmd = cmd || 'use';\n    const manPage = FS.readFileSync(PATH.join(__dirname, `help/${cmd}.txt`), 'utf8');\n\n    _out.log(M2C(manPage, 'white', 'yellow.bold'));\n  });\n  program.parse(args);\n\n  if (!program.args.length) {\n    throw {\n      fluenterror: 4\n    };\n  }\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/index.js",
      "startLine": 15,
      "endLine": 15,
      "before": "require('./main')(process.argv)",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait require('./main')(process.argv)"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 56,
      "endLine": 56,
      "before": "// HackMyResume CLI stub. Handle a single HMR invocation.\nfunction HackMyResumeOutputStub(args) {\n  console.log = MyConsoleLog;\n  process.exit = MyProcessExit;\n  CHALK.enabled = false;\n\n  try {\n    args.unshift(process.argv[1]);\n    args.unshift(process.argv[0]);\n    HMRMAIN(args);\n  } catch (ex) {\n    console.error(ex);\n\n    require('../../src/cli/error').err(ex, false);\n  }\n\n  CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n  console.log = ConsoleLogOrg;\n} // Run a test through the stub, gathering console.log output into \"gather\"\n// and testing against it.",
      "after": "// HackMyResume CLI stub. Handle a single HMR invocation.\nasync function HackMyResumeOutputStub(args) {\n  console.log = MyConsoleLog;\n  process.exit = MyProcessExit;\n  CHALK.enabled = false;\n\n  try {\n    args.unshift(process.argv[1]);\n    args.unshift(process.argv[0]);\n    await HMRMAIN(args);\n  } catch (ex) {\n    console.error(ex);\n\n    require('../../src/cli/error').err(ex, false);\n  }\n\n  CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n  console.log = ConsoleLogOrg;\n} // Run a test through the stub, gathering console.log output into \"gather\"\n// and testing against it."
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 74,
      "endLine": 74,
      "before": "function () {\n  gather = '';\n  HackMyResumeOutputStub(args);\n  expect(_.all(tests, function (t) {\n    return gather.indexOf(t) > -1;\n  })).to.equal(true);\n}",
      "after": "async function () {\n  gather = '';\n  await HackMyResumeOutputStub(args);\n  expect(_.all(tests, function (t) {\n    return gather.indexOf(t) > -1;\n  })).to.equal(true);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 96,
      "endLine": 97,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 99,
      "endLine": 100,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 102,
      "endLine": 103,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 105,
      "endLine": 109,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 111,
      "endLine": 112,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 114,
      "endLine": 115,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 120,
      "endLine": 121,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 123,
      "endLine": 131,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 133,
      "endLine": 141,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 143,
      "endLine": 154,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 156,
      "endLine": 167,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 169,
      "endLine": 180,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/main.js",
      "startLine": 173,
      "endLine": 173,
      "before": "function (ar, exitCallback) {\n  _exitCallback = exitCallback || process.exit;\n  const o = initOptions(ar);\n\n  if (o.ex) {\n    _err.init(false, true, false);\n\n    if (o.ex.op === 'parse') {\n      _err.err({\n        fluenterror: o.ex.op === 'parse' ? HMSTATUS.invalidOptionsFile : HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    } else {\n      _err.err({\n        fluenterror: HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    }\n\n    return null;\n  }\n\n  o.silent || logMsg(_title); // Emit debug prelude if --debug was specified\n\n  if (o.debug) {\n    _out.log(chalk.cyan('The -d or --debug switch was specified. DEBUG mode engaged.'));\n\n    _out.log('');\n\n    _out.log(chalk.cyan(PAD('  Platform:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.platform === 'win32' ? 'windows' : process.platform));\n\n    _out.log(chalk.cyan(PAD('  Node.js:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.version));\n\n    _out.log(chalk.cyan(PAD('  HackMyResume:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(`v${PKG.version}`));\n\n    _out.log(chalk.cyan(PAD('  FRESCA:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(PKG.dependencies.fresca)); //_out.log(chalk.cyan(PAD('  fresh-themes:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-themes'] ))\n    //_out.log(chalk.cyan(PAD('  fresh-jrs-converter:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-jrs-converter'] ))\n\n\n    _out.log('');\n  }\n\n  _err.init(o.debug, o.assert, o.silent); // Handle invalid verbs here (a bit easier here than in commander.js)...\n\n\n  if (o.verb && !HMR.verbs[o.verb] && !HMR.alias[o.verb] && o.verb !== 'help') {\n    _err.err({\n      fluenterror: HMSTATUS.invalidCommand,\n      quit: true,\n      attempted: o.orgVerb\n    }, true);\n  } // Override the .missingArgument behavior\n\n\n  Command.prototype.missingArgument = function () {\n    if (this.name() !== 'help') {\n      _err.err({\n        verb: this.name(),\n        fluenterror: HMSTATUS.resumeNotFound\n      }, true);\n    }\n  }; // Override the .helpInformation behavior\n\n\n  Command.prototype.helpInformation = function () {\n    const manPage = FS.readFileSync(PATH.join(__dirname, 'help/use.txt'), 'utf8');\n    return M2C(manPage, 'white', 'yellow');\n  };\n\n  return {\n    args: o.args,\n    options: o.json\n  };\n}",
      "after": "async function (ar, exitCallback) {\n  _exitCallback = exitCallback || process.exit;\n  const o = initOptions(ar);\n\n  if (o.ex) {\n    _err.init(false, true, false);\n\n    if (o.ex.op === 'parse') {\n      await _err.err({\n        fluenterror: o.ex.op === 'parse' ? HMSTATUS.invalidOptionsFile : HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    } else {\n      await _err.err({\n        fluenterror: HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    }\n\n    return null;\n  }\n\n  o.silent || logMsg(_title); // Emit debug prelude if --debug was specified\n\n  if (o.debug) {\n    _out.log(chalk.cyan('The -d or --debug switch was specified. DEBUG mode engaged.'));\n\n    _out.log('');\n\n    _out.log(chalk.cyan(PAD('  Platform:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.platform === 'win32' ? 'windows' : process.platform));\n\n    _out.log(chalk.cyan(PAD('  Node.js:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.version));\n\n    _out.log(chalk.cyan(PAD('  HackMyResume:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(`v${PKG.version}`));\n\n    _out.log(chalk.cyan(PAD('  FRESCA:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(PKG.dependencies.fresca)); //_out.log(chalk.cyan(PAD('  fresh-themes:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-themes'] ))\n    //_out.log(chalk.cyan(PAD('  fresh-jrs-converter:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-jrs-converter'] ))\n\n\n    _out.log('');\n  }\n\n  _err.init(o.debug, o.assert, o.silent); // Handle invalid verbs here (a bit easier here than in commander.js)...\n\n\n  if (o.verb && !HMR.verbs[o.verb] && !HMR.alias[o.verb] && o.verb !== 'help') {\n    _err.err({\n      fluenterror: HMSTATUS.invalidCommand,\n      quit: true,\n      attempted: o.orgVerb\n    }, true);\n  } // Override the .missingArgument behavior\n\n\n  Command.prototype.missingArgument = function () {\n    if (this.name() !== 'help') {\n      _err.err({\n        verb: this.name(),\n        fluenterror: HMSTATUS.resumeNotFound\n      }, true);\n    }\n  }; // Override the .helpInformation behavior\n\n\n  Command.prototype.helpInformation = function () {\n    const manPage = FS.readFileSync(PATH.join(__dirname, 'help/use.txt'), 'utf8');\n    return M2C(manPage, 'white', 'yellow');\n  };\n\n  return {\n    args: o.args,\n    options: o.json\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/main.js",
      "startLine": 196,
      "endLine": 196,
      "before": "function (ar, exitCallback) {\n  _exitCallback = exitCallback || process.exit;\n  const o = initOptions(ar);\n\n  if (o.ex) {\n    _err.init(false, true, false);\n\n    if (o.ex.op === 'parse') {\n      _err.err({\n        fluenterror: o.ex.op === 'parse' ? HMSTATUS.invalidOptionsFile : HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    } else {\n      _err.err({\n        fluenterror: HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    }\n\n    return null;\n  }\n\n  o.silent || logMsg(_title); // Emit debug prelude if --debug was specified\n\n  if (o.debug) {\n    _out.log(chalk.cyan('The -d or --debug switch was specified. DEBUG mode engaged.'));\n\n    _out.log('');\n\n    _out.log(chalk.cyan(PAD('  Platform:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.platform === 'win32' ? 'windows' : process.platform));\n\n    _out.log(chalk.cyan(PAD('  Node.js:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.version));\n\n    _out.log(chalk.cyan(PAD('  HackMyResume:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(`v${PKG.version}`));\n\n    _out.log(chalk.cyan(PAD('  FRESCA:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(PKG.dependencies.fresca)); //_out.log(chalk.cyan(PAD('  fresh-themes:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-themes'] ))\n    //_out.log(chalk.cyan(PAD('  fresh-jrs-converter:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-jrs-converter'] ))\n\n\n    _out.log('');\n  }\n\n  _err.init(o.debug, o.assert, o.silent); // Handle invalid verbs here (a bit easier here than in commander.js)...\n\n\n  if (o.verb && !HMR.verbs[o.verb] && !HMR.alias[o.verb] && o.verb !== 'help') {\n    _err.err({\n      fluenterror: HMSTATUS.invalidCommand,\n      quit: true,\n      attempted: o.orgVerb\n    }, true);\n  } // Override the .missingArgument behavior\n\n\n  Command.prototype.missingArgument = function () {\n    if (this.name() !== 'help') {\n      _err.err({\n        verb: this.name(),\n        fluenterror: HMSTATUS.resumeNotFound\n      }, true);\n    }\n  }; // Override the .helpInformation behavior\n\n\n  Command.prototype.helpInformation = function () {\n    const manPage = FS.readFileSync(PATH.join(__dirname, 'help/use.txt'), 'utf8');\n    return M2C(manPage, 'white', 'yellow');\n  };\n\n  return {\n    args: o.args,\n    options: o.json\n  };\n}",
      "after": "async function (ar, exitCallback) {\n  _exitCallback = exitCallback || process.exit;\n  const o = initOptions(ar);\n\n  if (o.ex) {\n    _err.init(false, true, false);\n\n    if (o.ex.op === 'parse') {\n      await _err.err({\n        fluenterror: o.ex.op === 'parse' ? HMSTATUS.invalidOptionsFile : HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    } else {\n      await _err.err({\n        fluenterror: HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    }\n\n    return null;\n  }\n\n  o.silent || logMsg(_title); // Emit debug prelude if --debug was specified\n\n  if (o.debug) {\n    _out.log(chalk.cyan('The -d or --debug switch was specified. DEBUG mode engaged.'));\n\n    _out.log('');\n\n    _out.log(chalk.cyan(PAD('  Platform:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.platform === 'win32' ? 'windows' : process.platform));\n\n    _out.log(chalk.cyan(PAD('  Node.js:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.version));\n\n    _out.log(chalk.cyan(PAD('  HackMyResume:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(`v${PKG.version}`));\n\n    _out.log(chalk.cyan(PAD('  FRESCA:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(PKG.dependencies.fresca)); //_out.log(chalk.cyan(PAD('  fresh-themes:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-themes'] ))\n    //_out.log(chalk.cyan(PAD('  fresh-jrs-converter:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-jrs-converter'] ))\n\n\n    _out.log('');\n  }\n\n  _err.init(o.debug, o.assert, o.silent); // Handle invalid verbs here (a bit easier here than in commander.js)...\n\n\n  if (o.verb && !HMR.verbs[o.verb] && !HMR.alias[o.verb] && o.verb !== 'help') {\n    await _err.err({\n      fluenterror: HMSTATUS.invalidCommand,\n      quit: true,\n      attempted: o.orgVerb\n    }, true);\n  } // Override the .missingArgument behavior\n\n\n  Command.prototype.missingArgument = function () {\n    if (this.name() !== 'help') {\n      _err.err({\n        verb: this.name(),\n        fluenterror: HMSTATUS.resumeNotFound\n      }, true);\n    }\n  }; // Override the .helpInformation behavior\n\n\n  Command.prototype.helpInformation = function () {\n    const manPage = FS.readFileSync(PATH.join(__dirname, 'help/use.txt'), 'utf8');\n    return M2C(manPage, 'white', 'yellow');\n  };\n\n  return {\n    args: o.args,\n    options: o.json\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 60,
      "endLine": 60,
      "before": "// HackMyResume CLI stub. Handle a single HMR invocation.\nfunction HackMyResumeOutputStub(args) {\n  console.log = MyConsoleLog;\n  process.exit = MyProcessExit;\n  CHALK.enabled = false;\n\n  try {\n    args.unshift(process.argv[1]);\n    args.unshift(process.argv[0]);\n    HMRMAIN(args);\n  } catch (ex) {\n    console.error(ex);\n\n    require('../../src/cli/error').err(ex, false);\n  }\n\n  CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n  console.log = ConsoleLogOrg;\n} // Run a test through the stub, gathering console.log output into \"gather\"\n// and testing against it.",
      "after": "// HackMyResume CLI stub. Handle a single HMR invocation.\nasync function HackMyResumeOutputStub(args) {\n  console.log = MyConsoleLog;\n  process.exit = MyProcessExit;\n  CHALK.enabled = false;\n\n  try {\n    args.unshift(process.argv[1]);\n    args.unshift(process.argv[0]);\n    await HMRMAIN(args);\n  } catch (ex) {\n    console.error(ex);\n    await require('../../src/cli/error').err(ex, false);\n  }\n\n  CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n  console.log = ConsoleLogOrg;\n} // Run a test through the stub, gathering console.log output into \"gather\"\n// and testing against it."
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/error.js",
      "startLine": 201,
      "endLine": 201,
      "before": "function (ex) {\n  let se;\n  let msg = '';\n  let withStack = false;\n  let quit = false;\n  let etype = 'warning';\n\n  if (this.debug) {\n    withStack = true;\n  }\n\n  switch (ex.fluenterror) {\n    case HMSTATUS.themeNotFound:\n      msg = printf(M2C(this.msgs.themeNotFound.msg, 'yellow'), ex.data);\n      break;\n\n    case HMSTATUS.copyCSS:\n      msg = M2C(this.msgs.copyCSS.msg, 'red');\n      quit = false;\n      break;\n\n    case HMSTATUS.resumeNotFound:\n      //msg = M2C( this.msgs.resumeNotFound.msg, 'yellow' );\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, `help/${ex.verb}.txt`), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.missingCommand:\n      // msg = M2C( this.msgs.missingCommand.msg + \" (\", 'yellow');\n      // msg += Object.keys( FCMD.verbs ).map( (v, idx, ar) ->\n      //   return ( if idx == ar.length - 1 then chalk.yellow('or ') else '') +\n      //     chalk.yellow.bold(v.toUpperCase());\n      // ).join( chalk.yellow(', ')) + chalk.yellow(\").\\n\\n\");\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, 'help/use.txt'), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.invalidCommand:\n      msg = printf(M2C(this.msgs.invalidCommand.msg, 'yellow'), ex.attempted);\n      break;\n\n    case HMSTATUS.resumeNotFoundAlt:\n      msg = M2C(this.msgs.resumeNotFoundAlt.msg, 'yellow');\n      break;\n\n    case HMSTATUS.inputOutputParity:\n      msg = M2C(this.msgs.inputOutputParity.msg);\n      break;\n\n    case HMSTATUS.createNameMissing:\n      msg = M2C(this.msgs.createNameMissing.msg);\n      break;\n\n    case HMSTATUS.pdfGeneration:\n      msg = M2C(this.msgs.pdfGeneration.msg, 'bold');\n\n      if (ex.inner) {\n        msg += chalk.red(`\\n${ex.inner}`);\n      }\n\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalid:\n      msg = M2C(this.msgs.invalid.msg, 'red');\n      etype = 'error';\n      break;\n\n    case HMSTATUS.generateError:\n      msg = ex.inner && ex.inner.toString() || ex;\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.fileSaveError:\n      msg = printf(M2C(this.msgs.fileSaveError.msg), (ex.inner || ex).toString());\n      etype = 'error';\n      quit = false;\n      break;\n\n    case HMSTATUS.invalidFormat:\n      ex.data.forEach(function (d) {\n        return msg += printf(M2C(this.msgs.invalidFormat.msg, 'bold'), ex.theme.name.toUpperCase(), d.format.toUpperCase());\n      }, this);\n      break;\n\n    case HMSTATUS.missingParam:\n      msg = printf(M2C(this.msgs.missingParam.msg), ex.expected, ex.helper);\n      break;\n\n    case HMSTATUS.invalidHelperUse:\n      msg = printf(M2C(this.msgs.invalidHelperUse.msg), ex.helper);\n\n      if (ex.error) {\n        msg += `\\n--> ${assembleError.call(this, extend(true, {}, ex, {\n          fluenterror: ex.error\n        })).msg}`;\n      } //msg += printf( '\\n--> ' + M2C( this.msgs.invalidParamCount.msg ), ex.expected );\n\n\n      quit = false;\n      etype = 'warning';\n      break;\n\n    case HMSTATUS.notOnPath:\n      msg = printf(M2C(this.msgs.notOnPath.msg, 'bold'), ex.engine);\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.readError:\n      if (!ex.quiet) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n      }\n\n      msg = ex.inner.toString();\n      etype = 'error';\n      break;\n\n    case HMSTATUS.mixedMerge:\n      msg = M2C(this.msgs.mixedMerge.msg);\n      quit = false;\n      break;\n\n    case HMSTATUS.invokeTemplate:\n      msg = M2C(this.msgs.invokeTemplate.msg, 'red');\n      msg += M2C(`\\n${WRAP(ex.inner.toString(), {\n        width: 60,\n        indent: '   '\n      })}`, 'gray');\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.compileTemplate:\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeLoad:\n      msg = M2C(printf(this.msgs.themeLoad.msg, ex.attempted.toUpperCase()), 'red');\n\n      if (ex.inner && ex.inner.fluenterror) {\n        msg += M2C('\\nError: ', 'red') + assembleError.call(this, ex.inner).msg;\n      }\n\n      quit = true;\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.parseError:\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg = M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg = ex;\n      }\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.createError:\n      // inner.code could be EPERM, EACCES, etc\n      msg = printf(M2C(this.msgs.createError.msg), ex.inner.path);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.validateError:\n      msg = printf(M2C(this.msgs.validateError.msg), ex.inner.toString());\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidOptionsFile:\n      msg = M2C(this.msgs.invalidOptionsFile.msg[0]);\n\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg += M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg += ex;\n      }\n\n      msg += this.msgs.invalidOptionsFile.msg[1];\n      etype = 'error';\n      break;\n\n    case HMSTATUS.optionsFileNotFound:\n      msg = M2C(this.msgs.optionsFileNotFound.msg);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.unknownSchema:\n      msg = M2C(this.msgs.unknownSchema.msg[0]); //msg += \"\\n\" + M2C( @msgs.unknownSchema.msg[1], 'yellow' )\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeHelperLoad:\n      msg = printf(M2C(this.msgs.themeHelperLoad.msg), ex.glob);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidSchemaVersion:\n      msg = printf(M2C(this.msgs.invalidSchemaVersion.msg), ex.data);\n      etype = 'error';\n      break;\n  }\n\n  return {\n    msg,\n    // The error message to display\n    withStack,\n    // Whether to include the stack\n    quit,\n    etype\n  };\n}",
      "after": "async function (ex) {\n  let se;\n  let msg = '';\n  let withStack = false;\n  let quit = false;\n  let etype = 'warning';\n\n  if (this.debug) {\n    withStack = true;\n  }\n\n  switch (ex.fluenterror) {\n    case HMSTATUS.themeNotFound:\n      msg = printf(M2C(this.msgs.themeNotFound.msg, 'yellow'), ex.data);\n      break;\n\n    case HMSTATUS.copyCSS:\n      msg = M2C(this.msgs.copyCSS.msg, 'red');\n      quit = false;\n      break;\n\n    case HMSTATUS.resumeNotFound:\n      //msg = M2C( this.msgs.resumeNotFound.msg, 'yellow' );\n      msg += M2C(await FS.promises.readFile(PATH.resolve(__dirname, `help/${ex.verb}.txt`), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.missingCommand:\n      // msg = M2C( this.msgs.missingCommand.msg + \" (\", 'yellow');\n      // msg += Object.keys( FCMD.verbs ).map( (v, idx, ar) ->\n      //   return ( if idx == ar.length - 1 then chalk.yellow('or ') else '') +\n      //     chalk.yellow.bold(v.toUpperCase());\n      // ).join( chalk.yellow(', ')) + chalk.yellow(\").\\n\\n\");\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, 'help/use.txt'), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.invalidCommand:\n      msg = printf(M2C(this.msgs.invalidCommand.msg, 'yellow'), ex.attempted);\n      break;\n\n    case HMSTATUS.resumeNotFoundAlt:\n      msg = M2C(this.msgs.resumeNotFoundAlt.msg, 'yellow');\n      break;\n\n    case HMSTATUS.inputOutputParity:\n      msg = M2C(this.msgs.inputOutputParity.msg);\n      break;\n\n    case HMSTATUS.createNameMissing:\n      msg = M2C(this.msgs.createNameMissing.msg);\n      break;\n\n    case HMSTATUS.pdfGeneration:\n      msg = M2C(this.msgs.pdfGeneration.msg, 'bold');\n\n      if (ex.inner) {\n        msg += chalk.red(`\\n${ex.inner}`);\n      }\n\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalid:\n      msg = M2C(this.msgs.invalid.msg, 'red');\n      etype = 'error';\n      break;\n\n    case HMSTATUS.generateError:\n      msg = ex.inner && ex.inner.toString() || ex;\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.fileSaveError:\n      msg = printf(M2C(this.msgs.fileSaveError.msg), (ex.inner || ex).toString());\n      etype = 'error';\n      quit = false;\n      break;\n\n    case HMSTATUS.invalidFormat:\n      ex.data.forEach(function (d) {\n        return msg += printf(M2C(this.msgs.invalidFormat.msg, 'bold'), ex.theme.name.toUpperCase(), d.format.toUpperCase());\n      }, this);\n      break;\n\n    case HMSTATUS.missingParam:\n      msg = printf(M2C(this.msgs.missingParam.msg), ex.expected, ex.helper);\n      break;\n\n    case HMSTATUS.invalidHelperUse:\n      msg = printf(M2C(this.msgs.invalidHelperUse.msg), ex.helper);\n\n      if (ex.error) {\n        msg += `\\n--> ${(await assembleError.call(this, extend(true, {}, ex, {\n          fluenterror: ex.error\n        }))).msg}`;\n      } //msg += printf( '\\n--> ' + M2C( this.msgs.invalidParamCount.msg ), ex.expected );\n\n\n      quit = false;\n      etype = 'warning';\n      break;\n\n    case HMSTATUS.notOnPath:\n      msg = printf(M2C(this.msgs.notOnPath.msg, 'bold'), ex.engine);\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.readError:\n      if (!ex.quiet) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n      }\n\n      msg = ex.inner.toString();\n      etype = 'error';\n      break;\n\n    case HMSTATUS.mixedMerge:\n      msg = M2C(this.msgs.mixedMerge.msg);\n      quit = false;\n      break;\n\n    case HMSTATUS.invokeTemplate:\n      msg = M2C(this.msgs.invokeTemplate.msg, 'red');\n      msg += M2C(`\\n${WRAP(ex.inner.toString(), {\n        width: 60,\n        indent: '   '\n      })}`, 'gray');\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.compileTemplate:\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeLoad:\n      msg = M2C(printf(this.msgs.themeLoad.msg, ex.attempted.toUpperCase()), 'red');\n\n      if (ex.inner && ex.inner.fluenterror) {\n        msg += M2C('\\nError: ', 'red') + assembleError.call(this, ex.inner).msg;\n      }\n\n      quit = true;\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.parseError:\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg = M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg = ex;\n      }\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.createError:\n      // inner.code could be EPERM, EACCES, etc\n      msg = printf(M2C(this.msgs.createError.msg), ex.inner.path);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.validateError:\n      msg = printf(M2C(this.msgs.validateError.msg), ex.inner.toString());\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidOptionsFile:\n      msg = M2C(this.msgs.invalidOptionsFile.msg[0]);\n\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg += M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg += ex;\n      }\n\n      msg += this.msgs.invalidOptionsFile.msg[1];\n      etype = 'error';\n      break;\n\n    case HMSTATUS.optionsFileNotFound:\n      msg = M2C(this.msgs.optionsFileNotFound.msg);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.unknownSchema:\n      msg = M2C(this.msgs.unknownSchema.msg[0]); //msg += \"\\n\" + M2C( @msgs.unknownSchema.msg[1], 'yellow' )\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeHelperLoad:\n      msg = printf(M2C(this.msgs.themeHelperLoad.msg), ex.glob);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidSchemaVersion:\n      msg = printf(M2C(this.msgs.invalidSchemaVersion.msg), ex.data);\n      etype = 'error';\n      break;\n  }\n\n  return {\n    msg,\n    // The error message to display\n    withStack,\n    // Whether to include the stack\n    quit,\n    etype\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/error.js",
      "startLine": 241,
      "endLine": 241,
      "before": "function (ex) {\n  let se;\n  let msg = '';\n  let withStack = false;\n  let quit = false;\n  let etype = 'warning';\n\n  if (this.debug) {\n    withStack = true;\n  }\n\n  switch (ex.fluenterror) {\n    case HMSTATUS.themeNotFound:\n      msg = printf(M2C(this.msgs.themeNotFound.msg, 'yellow'), ex.data);\n      break;\n\n    case HMSTATUS.copyCSS:\n      msg = M2C(this.msgs.copyCSS.msg, 'red');\n      quit = false;\n      break;\n\n    case HMSTATUS.resumeNotFound:\n      //msg = M2C( this.msgs.resumeNotFound.msg, 'yellow' );\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, `help/${ex.verb}.txt`), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.missingCommand:\n      // msg = M2C( this.msgs.missingCommand.msg + \" (\", 'yellow');\n      // msg += Object.keys( FCMD.verbs ).map( (v, idx, ar) ->\n      //   return ( if idx == ar.length - 1 then chalk.yellow('or ') else '') +\n      //     chalk.yellow.bold(v.toUpperCase());\n      // ).join( chalk.yellow(', ')) + chalk.yellow(\").\\n\\n\");\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, 'help/use.txt'), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.invalidCommand:\n      msg = printf(M2C(this.msgs.invalidCommand.msg, 'yellow'), ex.attempted);\n      break;\n\n    case HMSTATUS.resumeNotFoundAlt:\n      msg = M2C(this.msgs.resumeNotFoundAlt.msg, 'yellow');\n      break;\n\n    case HMSTATUS.inputOutputParity:\n      msg = M2C(this.msgs.inputOutputParity.msg);\n      break;\n\n    case HMSTATUS.createNameMissing:\n      msg = M2C(this.msgs.createNameMissing.msg);\n      break;\n\n    case HMSTATUS.pdfGeneration:\n      msg = M2C(this.msgs.pdfGeneration.msg, 'bold');\n\n      if (ex.inner) {\n        msg += chalk.red(`\\n${ex.inner}`);\n      }\n\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalid:\n      msg = M2C(this.msgs.invalid.msg, 'red');\n      etype = 'error';\n      break;\n\n    case HMSTATUS.generateError:\n      msg = ex.inner && ex.inner.toString() || ex;\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.fileSaveError:\n      msg = printf(M2C(this.msgs.fileSaveError.msg), (ex.inner || ex).toString());\n      etype = 'error';\n      quit = false;\n      break;\n\n    case HMSTATUS.invalidFormat:\n      ex.data.forEach(function (d) {\n        return msg += printf(M2C(this.msgs.invalidFormat.msg, 'bold'), ex.theme.name.toUpperCase(), d.format.toUpperCase());\n      }, this);\n      break;\n\n    case HMSTATUS.missingParam:\n      msg = printf(M2C(this.msgs.missingParam.msg), ex.expected, ex.helper);\n      break;\n\n    case HMSTATUS.invalidHelperUse:\n      msg = printf(M2C(this.msgs.invalidHelperUse.msg), ex.helper);\n\n      if (ex.error) {\n        msg += `\\n--> ${assembleError.call(this, extend(true, {}, ex, {\n          fluenterror: ex.error\n        })).msg}`;\n      } //msg += printf( '\\n--> ' + M2C( this.msgs.invalidParamCount.msg ), ex.expected );\n\n\n      quit = false;\n      etype = 'warning';\n      break;\n\n    case HMSTATUS.notOnPath:\n      msg = printf(M2C(this.msgs.notOnPath.msg, 'bold'), ex.engine);\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.readError:\n      if (!ex.quiet) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n      }\n\n      msg = ex.inner.toString();\n      etype = 'error';\n      break;\n\n    case HMSTATUS.mixedMerge:\n      msg = M2C(this.msgs.mixedMerge.msg);\n      quit = false;\n      break;\n\n    case HMSTATUS.invokeTemplate:\n      msg = M2C(this.msgs.invokeTemplate.msg, 'red');\n      msg += M2C(`\\n${WRAP(ex.inner.toString(), {\n        width: 60,\n        indent: '   '\n      })}`, 'gray');\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.compileTemplate:\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeLoad:\n      msg = M2C(printf(this.msgs.themeLoad.msg, ex.attempted.toUpperCase()), 'red');\n\n      if (ex.inner && ex.inner.fluenterror) {\n        msg += M2C('\\nError: ', 'red') + assembleError.call(this, ex.inner).msg;\n      }\n\n      quit = true;\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.parseError:\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg = M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg = ex;\n      }\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.createError:\n      // inner.code could be EPERM, EACCES, etc\n      msg = printf(M2C(this.msgs.createError.msg), ex.inner.path);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.validateError:\n      msg = printf(M2C(this.msgs.validateError.msg), ex.inner.toString());\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidOptionsFile:\n      msg = M2C(this.msgs.invalidOptionsFile.msg[0]);\n\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg += M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg += ex;\n      }\n\n      msg += this.msgs.invalidOptionsFile.msg[1];\n      etype = 'error';\n      break;\n\n    case HMSTATUS.optionsFileNotFound:\n      msg = M2C(this.msgs.optionsFileNotFound.msg);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.unknownSchema:\n      msg = M2C(this.msgs.unknownSchema.msg[0]); //msg += \"\\n\" + M2C( @msgs.unknownSchema.msg[1], 'yellow' )\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeHelperLoad:\n      msg = printf(M2C(this.msgs.themeHelperLoad.msg), ex.glob);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidSchemaVersion:\n      msg = printf(M2C(this.msgs.invalidSchemaVersion.msg), ex.data);\n      etype = 'error';\n      break;\n  }\n\n  return {\n    msg,\n    // The error message to display\n    withStack,\n    // Whether to include the stack\n    quit,\n    etype\n  };\n}",
      "after": "async function (ex) {\n  let se;\n  let msg = '';\n  let withStack = false;\n  let quit = false;\n  let etype = 'warning';\n\n  if (this.debug) {\n    withStack = true;\n  }\n\n  switch (ex.fluenterror) {\n    case HMSTATUS.themeNotFound:\n      msg = printf(M2C(this.msgs.themeNotFound.msg, 'yellow'), ex.data);\n      break;\n\n    case HMSTATUS.copyCSS:\n      msg = M2C(this.msgs.copyCSS.msg, 'red');\n      quit = false;\n      break;\n\n    case HMSTATUS.resumeNotFound:\n      //msg = M2C( this.msgs.resumeNotFound.msg, 'yellow' );\n      msg += M2C(await FS.promises.readFile(PATH.resolve(__dirname, `help/${ex.verb}.txt`), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.missingCommand:\n      // msg = M2C( this.msgs.missingCommand.msg + \" (\", 'yellow');\n      // msg += Object.keys( FCMD.verbs ).map( (v, idx, ar) ->\n      //   return ( if idx == ar.length - 1 then chalk.yellow('or ') else '') +\n      //     chalk.yellow.bold(v.toUpperCase());\n      // ).join( chalk.yellow(', ')) + chalk.yellow(\").\\n\\n\");\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, 'help/use.txt'), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.invalidCommand:\n      msg = printf(M2C(this.msgs.invalidCommand.msg, 'yellow'), ex.attempted);\n      break;\n\n    case HMSTATUS.resumeNotFoundAlt:\n      msg = M2C(this.msgs.resumeNotFoundAlt.msg, 'yellow');\n      break;\n\n    case HMSTATUS.inputOutputParity:\n      msg = M2C(this.msgs.inputOutputParity.msg);\n      break;\n\n    case HMSTATUS.createNameMissing:\n      msg = M2C(this.msgs.createNameMissing.msg);\n      break;\n\n    case HMSTATUS.pdfGeneration:\n      msg = M2C(this.msgs.pdfGeneration.msg, 'bold');\n\n      if (ex.inner) {\n        msg += chalk.red(`\\n${ex.inner}`);\n      }\n\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalid:\n      msg = M2C(this.msgs.invalid.msg, 'red');\n      etype = 'error';\n      break;\n\n    case HMSTATUS.generateError:\n      msg = ex.inner && ex.inner.toString() || ex;\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.fileSaveError:\n      msg = printf(M2C(this.msgs.fileSaveError.msg), (ex.inner || ex).toString());\n      etype = 'error';\n      quit = false;\n      break;\n\n    case HMSTATUS.invalidFormat:\n      ex.data.forEach(function (d) {\n        return msg += printf(M2C(this.msgs.invalidFormat.msg, 'bold'), ex.theme.name.toUpperCase(), d.format.toUpperCase());\n      }, this);\n      break;\n\n    case HMSTATUS.missingParam:\n      msg = printf(M2C(this.msgs.missingParam.msg), ex.expected, ex.helper);\n      break;\n\n    case HMSTATUS.invalidHelperUse:\n      msg = printf(M2C(this.msgs.invalidHelperUse.msg), ex.helper);\n\n      if (ex.error) {\n        msg += `\\n--> ${(await assembleError.call(this, extend(true, {}, ex, {\n          fluenterror: ex.error\n        }))).msg}`;\n      } //msg += printf( '\\n--> ' + M2C( this.msgs.invalidParamCount.msg ), ex.expected );\n\n\n      quit = false;\n      etype = 'warning';\n      break;\n\n    case HMSTATUS.notOnPath:\n      msg = printf(M2C(this.msgs.notOnPath.msg, 'bold'), ex.engine);\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.readError:\n      if (!ex.quiet) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n      }\n\n      msg = ex.inner.toString();\n      etype = 'error';\n      break;\n\n    case HMSTATUS.mixedMerge:\n      msg = M2C(this.msgs.mixedMerge.msg);\n      quit = false;\n      break;\n\n    case HMSTATUS.invokeTemplate:\n      msg = M2C(this.msgs.invokeTemplate.msg, 'red');\n      msg += M2C(`\\n${WRAP(ex.inner.toString(), {\n        width: 60,\n        indent: '   '\n      })}`, 'gray');\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.compileTemplate:\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeLoad:\n      msg = M2C(printf(this.msgs.themeLoad.msg, ex.attempted.toUpperCase()), 'red');\n\n      if (ex.inner && ex.inner.fluenterror) {\n        msg += M2C('\\nError: ', 'red') + (await assembleError.call(this, ex.inner)).msg;\n      }\n\n      quit = true;\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.parseError:\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg = M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg = ex;\n      }\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.createError:\n      // inner.code could be EPERM, EACCES, etc\n      msg = printf(M2C(this.msgs.createError.msg), ex.inner.path);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.validateError:\n      msg = printf(M2C(this.msgs.validateError.msg), ex.inner.toString());\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidOptionsFile:\n      msg = M2C(this.msgs.invalidOptionsFile.msg[0]);\n\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg += M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg += ex;\n      }\n\n      msg += this.msgs.invalidOptionsFile.msg[1];\n      etype = 'error';\n      break;\n\n    case HMSTATUS.optionsFileNotFound:\n      msg = M2C(this.msgs.optionsFileNotFound.msg);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.unknownSchema:\n      msg = M2C(this.msgs.unknownSchema.msg[0]); //msg += \"\\n\" + M2C( @msgs.unknownSchema.msg[1], 'yellow' )\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeHelperLoad:\n      msg = printf(M2C(this.msgs.themeHelperLoad.msg), ex.glob);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidSchemaVersion:\n      msg = printf(M2C(this.msgs.invalidSchemaVersion.msg), ex.data);\n      etype = 'error';\n      break;\n  }\n\n  return {\n    msg,\n    // The error message to display\n    withStack,\n    // Whether to include the stack\n    quit,\n    etype\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/error.js",
      "startLine": 201,
      "endLine": 201,
      "before": "function (ex) {\n  let se;\n  let msg = '';\n  let withStack = false;\n  let quit = false;\n  let etype = 'warning';\n\n  if (this.debug) {\n    withStack = true;\n  }\n\n  switch (ex.fluenterror) {\n    case HMSTATUS.themeNotFound:\n      msg = printf(M2C(this.msgs.themeNotFound.msg, 'yellow'), ex.data);\n      break;\n\n    case HMSTATUS.copyCSS:\n      msg = M2C(this.msgs.copyCSS.msg, 'red');\n      quit = false;\n      break;\n\n    case HMSTATUS.resumeNotFound:\n      //msg = M2C( this.msgs.resumeNotFound.msg, 'yellow' );\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, `help/${ex.verb}.txt`), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.missingCommand:\n      // msg = M2C( this.msgs.missingCommand.msg + \" (\", 'yellow');\n      // msg += Object.keys( FCMD.verbs ).map( (v, idx, ar) ->\n      //   return ( if idx == ar.length - 1 then chalk.yellow('or ') else '') +\n      //     chalk.yellow.bold(v.toUpperCase());\n      // ).join( chalk.yellow(', ')) + chalk.yellow(\").\\n\\n\");\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, 'help/use.txt'), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.invalidCommand:\n      msg = printf(M2C(this.msgs.invalidCommand.msg, 'yellow'), ex.attempted);\n      break;\n\n    case HMSTATUS.resumeNotFoundAlt:\n      msg = M2C(this.msgs.resumeNotFoundAlt.msg, 'yellow');\n      break;\n\n    case HMSTATUS.inputOutputParity:\n      msg = M2C(this.msgs.inputOutputParity.msg);\n      break;\n\n    case HMSTATUS.createNameMissing:\n      msg = M2C(this.msgs.createNameMissing.msg);\n      break;\n\n    case HMSTATUS.pdfGeneration:\n      msg = M2C(this.msgs.pdfGeneration.msg, 'bold');\n\n      if (ex.inner) {\n        msg += chalk.red(`\\n${ex.inner}`);\n      }\n\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalid:\n      msg = M2C(this.msgs.invalid.msg, 'red');\n      etype = 'error';\n      break;\n\n    case HMSTATUS.generateError:\n      msg = ex.inner && ex.inner.toString() || ex;\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.fileSaveError:\n      msg = printf(M2C(this.msgs.fileSaveError.msg), (ex.inner || ex).toString());\n      etype = 'error';\n      quit = false;\n      break;\n\n    case HMSTATUS.invalidFormat:\n      ex.data.forEach(function (d) {\n        return msg += printf(M2C(this.msgs.invalidFormat.msg, 'bold'), ex.theme.name.toUpperCase(), d.format.toUpperCase());\n      }, this);\n      break;\n\n    case HMSTATUS.missingParam:\n      msg = printf(M2C(this.msgs.missingParam.msg), ex.expected, ex.helper);\n      break;\n\n    case HMSTATUS.invalidHelperUse:\n      msg = printf(M2C(this.msgs.invalidHelperUse.msg), ex.helper);\n\n      if (ex.error) {\n        msg += `\\n--> ${assembleError.call(this, extend(true, {}, ex, {\n          fluenterror: ex.error\n        })).msg}`;\n      } //msg += printf( '\\n--> ' + M2C( this.msgs.invalidParamCount.msg ), ex.expected );\n\n\n      quit = false;\n      etype = 'warning';\n      break;\n\n    case HMSTATUS.notOnPath:\n      msg = printf(M2C(this.msgs.notOnPath.msg, 'bold'), ex.engine);\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.readError:\n      if (!ex.quiet) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n      }\n\n      msg = ex.inner.toString();\n      etype = 'error';\n      break;\n\n    case HMSTATUS.mixedMerge:\n      msg = M2C(this.msgs.mixedMerge.msg);\n      quit = false;\n      break;\n\n    case HMSTATUS.invokeTemplate:\n      msg = M2C(this.msgs.invokeTemplate.msg, 'red');\n      msg += M2C(`\\n${WRAP(ex.inner.toString(), {\n        width: 60,\n        indent: '   '\n      })}`, 'gray');\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.compileTemplate:\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeLoad:\n      msg = M2C(printf(this.msgs.themeLoad.msg, ex.attempted.toUpperCase()), 'red');\n\n      if (ex.inner && ex.inner.fluenterror) {\n        msg += M2C('\\nError: ', 'red') + assembleError.call(this, ex.inner).msg;\n      }\n\n      quit = true;\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.parseError:\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg = M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg = ex;\n      }\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.createError:\n      // inner.code could be EPERM, EACCES, etc\n      msg = printf(M2C(this.msgs.createError.msg), ex.inner.path);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.validateError:\n      msg = printf(M2C(this.msgs.validateError.msg), ex.inner.toString());\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidOptionsFile:\n      msg = M2C(this.msgs.invalidOptionsFile.msg[0]);\n\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg += M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg += ex;\n      }\n\n      msg += this.msgs.invalidOptionsFile.msg[1];\n      etype = 'error';\n      break;\n\n    case HMSTATUS.optionsFileNotFound:\n      msg = M2C(this.msgs.optionsFileNotFound.msg);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.unknownSchema:\n      msg = M2C(this.msgs.unknownSchema.msg[0]); //msg += \"\\n\" + M2C( @msgs.unknownSchema.msg[1], 'yellow' )\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeHelperLoad:\n      msg = printf(M2C(this.msgs.themeHelperLoad.msg), ex.glob);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidSchemaVersion:\n      msg = printf(M2C(this.msgs.invalidSchemaVersion.msg), ex.data);\n      etype = 'error';\n      break;\n  }\n\n  return {\n    msg,\n    // The error message to display\n    withStack,\n    // Whether to include the stack\n    quit,\n    etype\n  };\n}",
      "after": "async function (ex) {\n  let se;\n  let msg = '';\n  let withStack = false;\n  let quit = false;\n  let etype = 'warning';\n\n  if (this.debug) {\n    withStack = true;\n  }\n\n  switch (ex.fluenterror) {\n    case HMSTATUS.themeNotFound:\n      msg = printf(M2C(this.msgs.themeNotFound.msg, 'yellow'), ex.data);\n      break;\n\n    case HMSTATUS.copyCSS:\n      msg = M2C(this.msgs.copyCSS.msg, 'red');\n      quit = false;\n      break;\n\n    case HMSTATUS.resumeNotFound:\n      //msg = M2C( this.msgs.resumeNotFound.msg, 'yellow' );\n      msg += M2C(await FS.promises.readFile(PATH.resolve(__dirname, `help/${ex.verb}.txt`), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.missingCommand:\n      // msg = M2C( this.msgs.missingCommand.msg + \" (\", 'yellow');\n      // msg += Object.keys( FCMD.verbs ).map( (v, idx, ar) ->\n      //   return ( if idx == ar.length - 1 then chalk.yellow('or ') else '') +\n      //     chalk.yellow.bold(v.toUpperCase());\n      // ).join( chalk.yellow(', ')) + chalk.yellow(\").\\n\\n\");\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, 'help/use.txt'), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.invalidCommand:\n      msg = printf(M2C(this.msgs.invalidCommand.msg, 'yellow'), ex.attempted);\n      break;\n\n    case HMSTATUS.resumeNotFoundAlt:\n      msg = M2C(this.msgs.resumeNotFoundAlt.msg, 'yellow');\n      break;\n\n    case HMSTATUS.inputOutputParity:\n      msg = M2C(this.msgs.inputOutputParity.msg);\n      break;\n\n    case HMSTATUS.createNameMissing:\n      msg = M2C(this.msgs.createNameMissing.msg);\n      break;\n\n    case HMSTATUS.pdfGeneration:\n      msg = M2C(this.msgs.pdfGeneration.msg, 'bold');\n\n      if (ex.inner) {\n        msg += chalk.red(`\\n${ex.inner}`);\n      }\n\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalid:\n      msg = M2C(this.msgs.invalid.msg, 'red');\n      etype = 'error';\n      break;\n\n    case HMSTATUS.generateError:\n      msg = ex.inner && ex.inner.toString() || ex;\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.fileSaveError:\n      msg = printf(M2C(this.msgs.fileSaveError.msg), (ex.inner || ex).toString());\n      etype = 'error';\n      quit = false;\n      break;\n\n    case HMSTATUS.invalidFormat:\n      ex.data.forEach(function (d) {\n        return msg += printf(M2C(this.msgs.invalidFormat.msg, 'bold'), ex.theme.name.toUpperCase(), d.format.toUpperCase());\n      }, this);\n      break;\n\n    case HMSTATUS.missingParam:\n      msg = printf(M2C(this.msgs.missingParam.msg), ex.expected, ex.helper);\n      break;\n\n    case HMSTATUS.invalidHelperUse:\n      msg = printf(M2C(this.msgs.invalidHelperUse.msg), ex.helper);\n\n      if (ex.error) {\n        msg += `\\n--> ${(await assembleError.call(this, extend(true, {}, ex, {\n          fluenterror: ex.error\n        }))).msg}`;\n      } //msg += printf( '\\n--> ' + M2C( this.msgs.invalidParamCount.msg ), ex.expected );\n\n\n      quit = false;\n      etype = 'warning';\n      break;\n\n    case HMSTATUS.notOnPath:\n      msg = printf(M2C(this.msgs.notOnPath.msg, 'bold'), ex.engine);\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.readError:\n      if (!ex.quiet) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n      }\n\n      msg = ex.inner.toString();\n      etype = 'error';\n      break;\n\n    case HMSTATUS.mixedMerge:\n      msg = M2C(this.msgs.mixedMerge.msg);\n      quit = false;\n      break;\n\n    case HMSTATUS.invokeTemplate:\n      msg = M2C(this.msgs.invokeTemplate.msg, 'red');\n      msg += M2C(`\\n${WRAP(ex.inner.toString(), {\n        width: 60,\n        indent: '   '\n      })}`, 'gray');\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.compileTemplate:\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeLoad:\n      msg = M2C(printf(this.msgs.themeLoad.msg, ex.attempted.toUpperCase()), 'red');\n\n      if (ex.inner && ex.inner.fluenterror) {\n        msg += M2C('\\nError: ', 'red') + (await assembleError.call(this, ex.inner)).msg;\n      }\n\n      quit = true;\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.parseError:\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg = M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg = ex;\n      }\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.createError:\n      // inner.code could be EPERM, EACCES, etc\n      msg = printf(M2C(this.msgs.createError.msg), ex.inner.path);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.validateError:\n      msg = printf(M2C(this.msgs.validateError.msg), ex.inner.toString());\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidOptionsFile:\n      msg = M2C(this.msgs.invalidOptionsFile.msg[0]);\n\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg += M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg += ex;\n      }\n\n      msg += this.msgs.invalidOptionsFile.msg[1];\n      etype = 'error';\n      break;\n\n    case HMSTATUS.optionsFileNotFound:\n      msg = M2C(this.msgs.optionsFileNotFound.msg);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.unknownSchema:\n      msg = M2C(this.msgs.unknownSchema.msg[0]); //msg += \"\\n\" + M2C( @msgs.unknownSchema.msg[1], 'yellow' )\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeHelperLoad:\n      msg = printf(M2C(this.msgs.themeHelperLoad.msg), ex.glob);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidSchemaVersion:\n      msg = printf(M2C(this.msgs.invalidSchemaVersion.msg), ex.data);\n      etype = 'error';\n      break;\n  }\n\n  return {\n    msg,\n    // The error message to display\n    withStack,\n    // Whether to include the stack\n    quit,\n    etype\n  };\n}"
    }
  ],
  "1": [
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/error.js",
      "startLine": 142,
      "endLine": 143,
      "before": "function (ex) {\n  let se;\n  let msg = '';\n  let withStack = false;\n  let quit = false;\n  let etype = 'warning';\n\n  if (this.debug) {\n    withStack = true;\n  }\n\n  switch (ex.fluenterror) {\n    case HMSTATUS.themeNotFound:\n      msg = printf(M2C(this.msgs.themeNotFound.msg, 'yellow'), ex.data);\n      break;\n\n    case HMSTATUS.copyCSS:\n      msg = M2C(this.msgs.copyCSS.msg, 'red');\n      quit = false;\n      break;\n\n    case HMSTATUS.resumeNotFound:\n      //msg = M2C( this.msgs.resumeNotFound.msg, 'yellow' );\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, `help/${ex.verb}.txt`), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.missingCommand:\n      // msg = M2C( this.msgs.missingCommand.msg + \" (\", 'yellow');\n      // msg += Object.keys( FCMD.verbs ).map( (v, idx, ar) ->\n      //   return ( if idx == ar.length - 1 then chalk.yellow('or ') else '') +\n      //     chalk.yellow.bold(v.toUpperCase());\n      // ).join( chalk.yellow(', ')) + chalk.yellow(\").\\n\\n\");\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, 'help/use.txt'), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.invalidCommand:\n      msg = printf(M2C(this.msgs.invalidCommand.msg, 'yellow'), ex.attempted);\n      break;\n\n    case HMSTATUS.resumeNotFoundAlt:\n      msg = M2C(this.msgs.resumeNotFoundAlt.msg, 'yellow');\n      break;\n\n    case HMSTATUS.inputOutputParity:\n      msg = M2C(this.msgs.inputOutputParity.msg);\n      break;\n\n    case HMSTATUS.createNameMissing:\n      msg = M2C(this.msgs.createNameMissing.msg);\n      break;\n\n    case HMSTATUS.pdfGeneration:\n      msg = M2C(this.msgs.pdfGeneration.msg, 'bold');\n\n      if (ex.inner) {\n        msg += chalk.red(`\\n${ex.inner}`);\n      }\n\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalid:\n      msg = M2C(this.msgs.invalid.msg, 'red');\n      etype = 'error';\n      break;\n\n    case HMSTATUS.generateError:\n      msg = ex.inner && ex.inner.toString() || ex;\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.fileSaveError:\n      msg = printf(M2C(this.msgs.fileSaveError.msg), (ex.inner || ex).toString());\n      etype = 'error';\n      quit = false;\n      break;\n\n    case HMSTATUS.invalidFormat:\n      ex.data.forEach(function (d) {\n        return msg += printf(M2C(this.msgs.invalidFormat.msg, 'bold'), ex.theme.name.toUpperCase(), d.format.toUpperCase());\n      }, this);\n      break;\n\n    case HMSTATUS.missingParam:\n      msg = printf(M2C(this.msgs.missingParam.msg), ex.expected, ex.helper);\n      break;\n\n    case HMSTATUS.invalidHelperUse:\n      msg = printf(M2C(this.msgs.invalidHelperUse.msg), ex.helper);\n\n      if (ex.error) {\n        msg += `\\n--> ${assembleError.call(this, extend(true, {}, ex, {\n          fluenterror: ex.error\n        })).msg}`;\n      } //msg += printf( '\\n--> ' + M2C( this.msgs.invalidParamCount.msg ), ex.expected );\n\n\n      quit = false;\n      etype = 'warning';\n      break;\n\n    case HMSTATUS.notOnPath:\n      msg = printf(M2C(this.msgs.notOnPath.msg, 'bold'), ex.engine);\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.readError:\n      if (!ex.quiet) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n      }\n\n      msg = ex.inner.toString();\n      etype = 'error';\n      break;\n\n    case HMSTATUS.mixedMerge:\n      msg = M2C(this.msgs.mixedMerge.msg);\n      quit = false;\n      break;\n\n    case HMSTATUS.invokeTemplate:\n      msg = M2C(this.msgs.invokeTemplate.msg, 'red');\n      msg += M2C(`\\n${WRAP(ex.inner.toString(), {\n        width: 60,\n        indent: '   '\n      })}`, 'gray');\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.compileTemplate:\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeLoad:\n      msg = M2C(printf(this.msgs.themeLoad.msg, ex.attempted.toUpperCase()), 'red');\n\n      if (ex.inner && ex.inner.fluenterror) {\n        msg += M2C('\\nError: ', 'red') + assembleError.call(this, ex.inner).msg;\n      }\n\n      quit = true;\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.parseError:\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg = M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg = ex;\n      }\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.createError:\n      // inner.code could be EPERM, EACCES, etc\n      msg = printf(M2C(this.msgs.createError.msg), ex.inner.path);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.validateError:\n      msg = printf(M2C(this.msgs.validateError.msg), ex.inner.toString());\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidOptionsFile:\n      msg = M2C(this.msgs.invalidOptionsFile.msg[0]);\n\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg += M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg += ex;\n      }\n\n      msg += this.msgs.invalidOptionsFile.msg[1];\n      etype = 'error';\n      break;\n\n    case HMSTATUS.optionsFileNotFound:\n      msg = M2C(this.msgs.optionsFileNotFound.msg);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.unknownSchema:\n      msg = M2C(this.msgs.unknownSchema.msg[0]); //msg += \"\\n\" + M2C( @msgs.unknownSchema.msg[1], 'yellow' )\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeHelperLoad:\n      msg = printf(M2C(this.msgs.themeHelperLoad.msg), ex.glob);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidSchemaVersion:\n      msg = printf(M2C(this.msgs.invalidSchemaVersion.msg), ex.data);\n      etype = 'error';\n      break;\n  }\n\n  return {\n    msg,\n    // The error message to display\n    withStack,\n    // Whether to include the stack\n    quit,\n    etype\n  };\n}",
      "after": "async function (ex) {\n  let se;\n  let msg = '';\n  let withStack = false;\n  let quit = false;\n  let etype = 'warning';\n\n  if (this.debug) {\n    withStack = true;\n  }\n\n  switch (ex.fluenterror) {\n    case HMSTATUS.themeNotFound:\n      msg = printf(M2C(this.msgs.themeNotFound.msg, 'yellow'), ex.data);\n      break;\n\n    case HMSTATUS.copyCSS:\n      msg = M2C(this.msgs.copyCSS.msg, 'red');\n      quit = false;\n      break;\n\n    case HMSTATUS.resumeNotFound:\n      //msg = M2C( this.msgs.resumeNotFound.msg, 'yellow' );\n      msg += M2C(await FS.promises.readFile(PATH.resolve(__dirname, `help/${ex.verb}.txt`), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.missingCommand:\n      // msg = M2C( this.msgs.missingCommand.msg + \" (\", 'yellow');\n      // msg += Object.keys( FCMD.verbs ).map( (v, idx, ar) ->\n      //   return ( if idx == ar.length - 1 then chalk.yellow('or ') else '') +\n      //     chalk.yellow.bold(v.toUpperCase());\n      // ).join( chalk.yellow(', ')) + chalk.yellow(\").\\n\\n\");\n      msg += M2C(await FS.promises.readFile(PATH.resolve(__dirname, 'help/use.txt'), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.invalidCommand:\n      msg = printf(M2C(this.msgs.invalidCommand.msg, 'yellow'), ex.attempted);\n      break;\n\n    case HMSTATUS.resumeNotFoundAlt:\n      msg = M2C(this.msgs.resumeNotFoundAlt.msg, 'yellow');\n      break;\n\n    case HMSTATUS.inputOutputParity:\n      msg = M2C(this.msgs.inputOutputParity.msg);\n      break;\n\n    case HMSTATUS.createNameMissing:\n      msg = M2C(this.msgs.createNameMissing.msg);\n      break;\n\n    case HMSTATUS.pdfGeneration:\n      msg = M2C(this.msgs.pdfGeneration.msg, 'bold');\n\n      if (ex.inner) {\n        msg += chalk.red(`\\n${ex.inner}`);\n      }\n\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalid:\n      msg = M2C(this.msgs.invalid.msg, 'red');\n      etype = 'error';\n      break;\n\n    case HMSTATUS.generateError:\n      msg = ex.inner && ex.inner.toString() || ex;\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.fileSaveError:\n      msg = printf(M2C(this.msgs.fileSaveError.msg), (ex.inner || ex).toString());\n      etype = 'error';\n      quit = false;\n      break;\n\n    case HMSTATUS.invalidFormat:\n      ex.data.forEach(function (d) {\n        return msg += printf(M2C(this.msgs.invalidFormat.msg, 'bold'), ex.theme.name.toUpperCase(), d.format.toUpperCase());\n      }, this);\n      break;\n\n    case HMSTATUS.missingParam:\n      msg = printf(M2C(this.msgs.missingParam.msg), ex.expected, ex.helper);\n      break;\n\n    case HMSTATUS.invalidHelperUse:\n      msg = printf(M2C(this.msgs.invalidHelperUse.msg), ex.helper);\n\n      if (ex.error) {\n        msg += `\\n--> ${(await assembleError.call(this, extend(true, {}, ex, {\n          fluenterror: ex.error\n        }))).msg}`;\n      } //msg += printf( '\\n--> ' + M2C( this.msgs.invalidParamCount.msg ), ex.expected );\n\n\n      quit = false;\n      etype = 'warning';\n      break;\n\n    case HMSTATUS.notOnPath:\n      msg = printf(M2C(this.msgs.notOnPath.msg, 'bold'), ex.engine);\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.readError:\n      if (!ex.quiet) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n      }\n\n      msg = ex.inner.toString();\n      etype = 'error';\n      break;\n\n    case HMSTATUS.mixedMerge:\n      msg = M2C(this.msgs.mixedMerge.msg);\n      quit = false;\n      break;\n\n    case HMSTATUS.invokeTemplate:\n      msg = M2C(this.msgs.invokeTemplate.msg, 'red');\n      msg += M2C(`\\n${WRAP(ex.inner.toString(), {\n        width: 60,\n        indent: '   '\n      })}`, 'gray');\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.compileTemplate:\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeLoad:\n      msg = M2C(printf(this.msgs.themeLoad.msg, ex.attempted.toUpperCase()), 'red');\n\n      if (ex.inner && ex.inner.fluenterror) {\n        msg += M2C('\\nError: ', 'red') + (await assembleError.call(this, ex.inner)).msg;\n      }\n\n      quit = true;\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.parseError:\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg = M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg = ex;\n      }\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.createError:\n      // inner.code could be EPERM, EACCES, etc\n      msg = printf(M2C(this.msgs.createError.msg), ex.inner.path);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.validateError:\n      msg = printf(M2C(this.msgs.validateError.msg), ex.inner.toString());\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidOptionsFile:\n      msg = M2C(this.msgs.invalidOptionsFile.msg[0]);\n\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg += M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg += ex;\n      }\n\n      msg += this.msgs.invalidOptionsFile.msg[1];\n      etype = 'error';\n      break;\n\n    case HMSTATUS.optionsFileNotFound:\n      msg = M2C(this.msgs.optionsFileNotFound.msg);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.unknownSchema:\n      msg = M2C(this.msgs.unknownSchema.msg[0]); //msg += \"\\n\" + M2C( @msgs.unknownSchema.msg[1], 'yellow' )\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeHelperLoad:\n      msg = printf(M2C(this.msgs.themeHelperLoad.msg), ex.glob);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidSchemaVersion:\n      msg = printf(M2C(this.msgs.invalidSchemaVersion.msg), ex.data);\n      etype = 'error';\n      break;\n  }\n\n  return {\n    msg,\n    // The error message to display\n    withStack,\n    // Whether to include the stack\n    quit,\n    etype\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/error.js",
      "startLine": 56,
      "endLine": 56,
      "before": "err(ex, shouldExit) {\n  // Short-circuit logging output if --silent is on\n  let stack;\n  const o = this.silent ? function () {} : _defaultLog; // Special case; can probably be removed.\n\n  if (ex.pass) {\n    throw ex;\n  } // Load error messages\n\n\n  this.msgs = this.msgs || require('./msg').errors; // Handle packaged HMR exceptions\n\n  if (ex.fluenterror) {\n    // Output the error message\n    const objError = assembleError.call(this, ex);\n    o(this[`format_${objError.etype}`](objError.msg)); // Output the stack (sometimes)\n\n    if (objError.withStack) {\n      stack = ex.stack || ex.inner && ex.inner.stack;\n      stack && o(chalk.gray(stack));\n    } // Quit if necessary\n\n\n    if (shouldExit || ex.exit) {\n      if (this.debug) {\n        o(chalk.cyan(`Exiting with error code ${ex.fluenterror.toString()}`));\n      }\n\n      if (this.assert) {\n        ex.pass = true;\n        throw ex;\n      }\n\n      return process.exit(ex.fluenterror);\n    } // Handle raw exceptions\n\n  } else {\n    o(ex);\n    const stackTrace = ex.stack || ex.inner && ex.inner.stack;\n\n    if (stackTrace && this.debug) {\n      return o(M2C(ex.stack || ex.inner.stack, 'gray'));\n    }\n  }\n}",
      "after": "async err(ex, shouldExit) {\n  // Short-circuit logging output if --silent is on\n  let stack;\n  const o = this.silent ? function () {} : _defaultLog; // Special case; can probably be removed.\n\n  if (ex.pass) {\n    throw ex;\n  } // Load error messages\n\n\n  this.msgs = this.msgs || require('./msg').errors; // Handle packaged HMR exceptions\n\n  if (ex.fluenterror) {\n    // Output the error message\n    const objError = await assembleError.call(this, ex);\n    o(this[`format_${objError.etype}`](objError.msg)); // Output the stack (sometimes)\n\n    if (objError.withStack) {\n      stack = ex.stack || ex.inner && ex.inner.stack;\n      stack && o(chalk.gray(stack));\n    } // Quit if necessary\n\n\n    if (shouldExit || ex.exit) {\n      if (this.debug) {\n        o(chalk.cyan(`Exiting with error code ${ex.fluenterror.toString()}`));\n      }\n\n      if (this.assert) {\n        ex.pass = true;\n        throw ex;\n      }\n\n      return process.exit(ex.fluenterror);\n    } // Handle raw exceptions\n\n  } else {\n    o(ex);\n    const stackTrace = ex.stack || ex.inner && ex.inner.stack;\n\n    if (stackTrace && this.debug) {\n      return o(M2C(ex.stack || ex.inner.stack, 'gray'));\n    }\n  }\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/index.js",
      "startLine": 20,
      "endLine": 20,
      "before": "require('./error').err(ex, true)",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait require('./error').err(ex, true)"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/main.js",
      "startLine": 167,
      "endLine": 171,
      "before": "function (ar, exitCallback) {\n  _exitCallback = exitCallback || process.exit;\n  const o = initOptions(ar);\n\n  if (o.ex) {\n    _err.init(false, true, false);\n\n    if (o.ex.op === 'parse') {\n      _err.err({\n        fluenterror: o.ex.op === 'parse' ? HMSTATUS.invalidOptionsFile : HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    } else {\n      _err.err({\n        fluenterror: HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    }\n\n    return null;\n  }\n\n  o.silent || logMsg(_title); // Emit debug prelude if --debug was specified\n\n  if (o.debug) {\n    _out.log(chalk.cyan('The -d or --debug switch was specified. DEBUG mode engaged.'));\n\n    _out.log('');\n\n    _out.log(chalk.cyan(PAD('  Platform:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.platform === 'win32' ? 'windows' : process.platform));\n\n    _out.log(chalk.cyan(PAD('  Node.js:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.version));\n\n    _out.log(chalk.cyan(PAD('  HackMyResume:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(`v${PKG.version}`));\n\n    _out.log(chalk.cyan(PAD('  FRESCA:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(PKG.dependencies.fresca)); //_out.log(chalk.cyan(PAD('  fresh-themes:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-themes'] ))\n    //_out.log(chalk.cyan(PAD('  fresh-jrs-converter:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-jrs-converter'] ))\n\n\n    _out.log('');\n  }\n\n  _err.init(o.debug, o.assert, o.silent); // Handle invalid verbs here (a bit easier here than in commander.js)...\n\n\n  if (o.verb && !HMR.verbs[o.verb] && !HMR.alias[o.verb] && o.verb !== 'help') {\n    _err.err({\n      fluenterror: HMSTATUS.invalidCommand,\n      quit: true,\n      attempted: o.orgVerb\n    }, true);\n  } // Override the .missingArgument behavior\n\n\n  Command.prototype.missingArgument = function () {\n    if (this.name() !== 'help') {\n      _err.err({\n        verb: this.name(),\n        fluenterror: HMSTATUS.resumeNotFound\n      }, true);\n    }\n  }; // Override the .helpInformation behavior\n\n\n  Command.prototype.helpInformation = function () {\n    const manPage = FS.readFileSync(PATH.join(__dirname, 'help/use.txt'), 'utf8');\n    return M2C(manPage, 'white', 'yellow');\n  };\n\n  return {\n    args: o.args,\n    options: o.json\n  };\n}",
      "after": "async function (ar, exitCallback) {\n  _exitCallback = exitCallback || process.exit;\n  const o = initOptions(ar);\n\n  if (o.ex) {\n    _err.init(false, true, false);\n\n    if (o.ex.op === 'parse') {\n      await _err.err({\n        fluenterror: o.ex.op === 'parse' ? HMSTATUS.invalidOptionsFile : HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    } else {\n      await _err.err({\n        fluenterror: HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    }\n\n    return null;\n  }\n\n  o.silent || logMsg(_title); // Emit debug prelude if --debug was specified\n\n  if (o.debug) {\n    _out.log(chalk.cyan('The -d or --debug switch was specified. DEBUG mode engaged.'));\n\n    _out.log('');\n\n    _out.log(chalk.cyan(PAD('  Platform:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.platform === 'win32' ? 'windows' : process.platform));\n\n    _out.log(chalk.cyan(PAD('  Node.js:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.version));\n\n    _out.log(chalk.cyan(PAD('  HackMyResume:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(`v${PKG.version}`));\n\n    _out.log(chalk.cyan(PAD('  FRESCA:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(PKG.dependencies.fresca)); //_out.log(chalk.cyan(PAD('  fresh-themes:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-themes'] ))\n    //_out.log(chalk.cyan(PAD('  fresh-jrs-converter:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-jrs-converter'] ))\n\n\n    _out.log('');\n  }\n\n  _err.init(o.debug, o.assert, o.silent); // Handle invalid verbs here (a bit easier here than in commander.js)...\n\n\n  if (o.verb && !HMR.verbs[o.verb] && !HMR.alias[o.verb] && o.verb !== 'help') {\n    await _err.err({\n      fluenterror: HMSTATUS.invalidCommand,\n      quit: true,\n      attempted: o.orgVerb\n    }, true);\n  } // Override the .missingArgument behavior\n\n\n  Command.prototype.missingArgument = function () {\n    if (this.name() !== 'help') {\n      _err.err({\n        verb: this.name(),\n        fluenterror: HMSTATUS.resumeNotFound\n      }, true);\n    }\n  }; // Override the .helpInformation behavior\n\n\n  Command.prototype.helpInformation = function () {\n    const manPage = FS.readFileSync(PATH.join(__dirname, 'help/use.txt'), 'utf8');\n    return M2C(manPage, 'white', 'yellow');\n  };\n\n  return {\n    args: o.args,\n    options: o.json\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/main.js",
      "startLine": 46,
      "endLine": 46,
      "before": "function (rawArgs, exitCallback) {\n  const initInfo = initialize(rawArgs, exitCallback);\n\n  if (initInfo === null) {\n    return;\n  }\n\n  const {\n    args\n  } = initInfo; // Create the top-level (application) command...\n\n  const program = new Command('hackmyresume').version(PKG.version).description(chalk.yellow.bold('*** HackMyResume ***')).option('-s --silent', 'Run in silent mode').option('--no-color', 'Disable colors').option('--color', 'Enable colors').option('-d --debug', 'Enable diagnostics', false).option('-a --assert', 'Treat warnings as errors', false).option('-v --version', 'Show the version').allowUnknownOption();\n  program.jsonArgs = initInfo.options; // Create the NEW command\n\n  program.command('new').arguments('<sources...>').option('-f --format <fmt>', 'FRESH or JRS format', 'FRESH').alias('create').description('Create resume(s) in FRESH or JSON RESUME format.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the VALIDATE command\n\n  program.command('validate').arguments('<sources...>').description('Validate a resume in FRESH or JSON RESUME format.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the CONVERT command\n\n  program.command('convert').description('Convert a resume to/from FRESH or JSON RESUME format.').option('-f --format <fmt>', 'FRESH or JRS format and optional version', undefined).action(function () {\n    const x = splitSrcDest.call(this);\n    execute.call(this, x.src, x.dst, this.opts(), logMsg);\n  }); // Create the ANALYZE command\n\n  program.command('analyze').arguments('<sources...>').option('--private', 'Include resume fields marked as private', false).description('Analyze one or more resumes.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the PEEK command\n\n  program.command('peek').arguments('<sources...>').description('Peek at a resume field or section') //.action(( sources, sectionOrField ) ->\n  .action(function (sources) {\n    const dst = sources && sources.length > 1 ? [sources.pop()] : [];\n    execute.call(this, sources, dst, this.opts(), logMsg);\n  }); // Create the BUILD command\n\n  program.command('build').alias('generate').option('-t --theme <theme>', 'Theme name or path').option('-n --no-prettify', 'Disable HTML prettification', true).option('-c --css <option>', 'CSS linking / embedding').option('-p --pdf <engine>', 'PDF generation engine').option('--no-sort', 'Sort resume sections by date', false).option('--tips', 'Display theme tips and warnings.', false).option('--private', 'Include resume fields marked as private', false).option('--no-escape', 'Turn off encoding in Handlebars themes.', false).description('Generate resume to multiple formats') //.action(( sources, targets, options ) ->\n  .action(function () {\n    const x = splitSrcDest.call(this);\n    execute.call(this, x.src, x.dst, this.opts(), logMsg);\n  }); // Create the HELP command\n\n  program.command('help').arguments('[command]').description('Get help on a HackMyResume command').action(function (cmd) {\n    cmd = cmd || 'use';\n    const manPage = FS.readFileSync(PATH.join(__dirname, `help/${cmd}.txt`), 'utf8');\n\n    _out.log(M2C(manPage, 'white', 'yellow.bold'));\n  });\n  program.parse(args);\n\n  if (!program.args.length) {\n    throw {\n      fluenterror: 4\n    };\n  }\n}",
      "after": "async function (rawArgs, exitCallback) {\n  const initInfo = await initialize(rawArgs, exitCallback);\n\n  if (initInfo === null) {\n    return;\n  }\n\n  const {\n    args\n  } = initInfo; // Create the top-level (application) command...\n\n  const program = new Command('hackmyresume').version(PKG.version).description(chalk.yellow.bold('*** HackMyResume ***')).option('-s --silent', 'Run in silent mode').option('--no-color', 'Disable colors').option('--color', 'Enable colors').option('-d --debug', 'Enable diagnostics', false).option('-a --assert', 'Treat warnings as errors', false).option('-v --version', 'Show the version').allowUnknownOption();\n  program.jsonArgs = initInfo.options; // Create the NEW command\n\n  program.command('new').arguments('<sources...>').option('-f --format <fmt>', 'FRESH or JRS format', 'FRESH').alias('create').description('Create resume(s) in FRESH or JSON RESUME format.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the VALIDATE command\n\n  program.command('validate').arguments('<sources...>').description('Validate a resume in FRESH or JSON RESUME format.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the CONVERT command\n\n  program.command('convert').description('Convert a resume to/from FRESH or JSON RESUME format.').option('-f --format <fmt>', 'FRESH or JRS format and optional version', undefined).action(function () {\n    const x = splitSrcDest.call(this);\n    execute.call(this, x.src, x.dst, this.opts(), logMsg);\n  }); // Create the ANALYZE command\n\n  program.command('analyze').arguments('<sources...>').option('--private', 'Include resume fields marked as private', false).description('Analyze one or more resumes.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the PEEK command\n\n  program.command('peek').arguments('<sources...>').description('Peek at a resume field or section') //.action(( sources, sectionOrField ) ->\n  .action(function (sources) {\n    const dst = sources && sources.length > 1 ? [sources.pop()] : [];\n    execute.call(this, sources, dst, this.opts(), logMsg);\n  }); // Create the BUILD command\n\n  program.command('build').alias('generate').option('-t --theme <theme>', 'Theme name or path').option('-n --no-prettify', 'Disable HTML prettification', true).option('-c --css <option>', 'CSS linking / embedding').option('-p --pdf <engine>', 'PDF generation engine').option('--no-sort', 'Sort resume sections by date', false).option('--tips', 'Display theme tips and warnings.', false).option('--private', 'Include resume fields marked as private', false).option('--no-escape', 'Turn off encoding in Handlebars themes.', false).description('Generate resume to multiple formats') //.action(( sources, targets, options ) ->\n  .action(function () {\n    const x = splitSrcDest.call(this);\n    execute.call(this, x.src, x.dst, this.opts(), logMsg);\n  }); // Create the HELP command\n\n  program.command('help').arguments('[command]').description('Get help on a HackMyResume command').action(function (cmd) {\n    cmd = cmd || 'use';\n    const manPage = FS.readFileSync(PATH.join(__dirname, `help/${cmd}.txt`), 'utf8');\n\n    _out.log(M2C(manPage, 'white', 'yellow.bold'));\n  });\n  program.parse(args);\n\n  if (!program.args.length) {\n    throw {\n      fluenterror: 4\n    };\n  }\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/index.js",
      "startLine": 15,
      "endLine": 15,
      "before": "require('./main')(process.argv)",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait require('./main')(process.argv)"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 56,
      "endLine": 56,
      "before": "// HackMyResume CLI stub. Handle a single HMR invocation.\nfunction HackMyResumeOutputStub(args) {\n  console.log = MyConsoleLog;\n  process.exit = MyProcessExit;\n  CHALK.enabled = false;\n\n  try {\n    args.unshift(process.argv[1]);\n    args.unshift(process.argv[0]);\n    HMRMAIN(args);\n  } catch (ex) {\n    console.error(ex);\n\n    require('../../src/cli/error').err(ex, false);\n  }\n\n  CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n  console.log = ConsoleLogOrg;\n} // Run a test through the stub, gathering console.log output into \"gather\"\n// and testing against it.",
      "after": "// HackMyResume CLI stub. Handle a single HMR invocation.\nasync function HackMyResumeOutputStub(args) {\n  console.log = MyConsoleLog;\n  process.exit = MyProcessExit;\n  CHALK.enabled = false;\n\n  try {\n    args.unshift(process.argv[1]);\n    args.unshift(process.argv[0]);\n    await HMRMAIN(args);\n  } catch (ex) {\n    console.error(ex);\n    await require('../../src/cli/error').err(ex, false);\n  }\n\n  CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n  console.log = ConsoleLogOrg;\n} // Run a test through the stub, gathering console.log output into \"gather\"\n// and testing against it."
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 74,
      "endLine": 74,
      "before": "function () {\n  gather = '';\n  HackMyResumeOutputStub(args);\n  expect(_.all(tests, function (t) {\n    return gather.indexOf(t) > -1;\n  })).to.equal(true);\n}",
      "after": "async function () {\n  gather = '';\n  await HackMyResumeOutputStub(args);\n  expect(_.all(tests, function (t) {\n    return gather.indexOf(t) > -1;\n  })).to.equal(true);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 96,
      "endLine": 97,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 99,
      "endLine": 100,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 102,
      "endLine": 103,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 105,
      "endLine": 109,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 111,
      "endLine": 112,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 114,
      "endLine": 115,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 120,
      "endLine": 121,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 123,
      "endLine": 131,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 133,
      "endLine": 141,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 143,
      "endLine": 154,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 156,
      "endLine": 167,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 169,
      "endLine": 180,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/main.js",
      "startLine": 173,
      "endLine": 173,
      "before": "function (ar, exitCallback) {\n  _exitCallback = exitCallback || process.exit;\n  const o = initOptions(ar);\n\n  if (o.ex) {\n    _err.init(false, true, false);\n\n    if (o.ex.op === 'parse') {\n      _err.err({\n        fluenterror: o.ex.op === 'parse' ? HMSTATUS.invalidOptionsFile : HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    } else {\n      _err.err({\n        fluenterror: HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    }\n\n    return null;\n  }\n\n  o.silent || logMsg(_title); // Emit debug prelude if --debug was specified\n\n  if (o.debug) {\n    _out.log(chalk.cyan('The -d or --debug switch was specified. DEBUG mode engaged.'));\n\n    _out.log('');\n\n    _out.log(chalk.cyan(PAD('  Platform:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.platform === 'win32' ? 'windows' : process.platform));\n\n    _out.log(chalk.cyan(PAD('  Node.js:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.version));\n\n    _out.log(chalk.cyan(PAD('  HackMyResume:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(`v${PKG.version}`));\n\n    _out.log(chalk.cyan(PAD('  FRESCA:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(PKG.dependencies.fresca)); //_out.log(chalk.cyan(PAD('  fresh-themes:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-themes'] ))\n    //_out.log(chalk.cyan(PAD('  fresh-jrs-converter:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-jrs-converter'] ))\n\n\n    _out.log('');\n  }\n\n  _err.init(o.debug, o.assert, o.silent); // Handle invalid verbs here (a bit easier here than in commander.js)...\n\n\n  if (o.verb && !HMR.verbs[o.verb] && !HMR.alias[o.verb] && o.verb !== 'help') {\n    _err.err({\n      fluenterror: HMSTATUS.invalidCommand,\n      quit: true,\n      attempted: o.orgVerb\n    }, true);\n  } // Override the .missingArgument behavior\n\n\n  Command.prototype.missingArgument = function () {\n    if (this.name() !== 'help') {\n      _err.err({\n        verb: this.name(),\n        fluenterror: HMSTATUS.resumeNotFound\n      }, true);\n    }\n  }; // Override the .helpInformation behavior\n\n\n  Command.prototype.helpInformation = function () {\n    const manPage = FS.readFileSync(PATH.join(__dirname, 'help/use.txt'), 'utf8');\n    return M2C(manPage, 'white', 'yellow');\n  };\n\n  return {\n    args: o.args,\n    options: o.json\n  };\n}",
      "after": "async function (ar, exitCallback) {\n  _exitCallback = exitCallback || process.exit;\n  const o = initOptions(ar);\n\n  if (o.ex) {\n    _err.init(false, true, false);\n\n    if (o.ex.op === 'parse') {\n      await _err.err({\n        fluenterror: o.ex.op === 'parse' ? HMSTATUS.invalidOptionsFile : HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    } else {\n      await _err.err({\n        fluenterror: HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    }\n\n    return null;\n  }\n\n  o.silent || logMsg(_title); // Emit debug prelude if --debug was specified\n\n  if (o.debug) {\n    _out.log(chalk.cyan('The -d or --debug switch was specified. DEBUG mode engaged.'));\n\n    _out.log('');\n\n    _out.log(chalk.cyan(PAD('  Platform:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.platform === 'win32' ? 'windows' : process.platform));\n\n    _out.log(chalk.cyan(PAD('  Node.js:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.version));\n\n    _out.log(chalk.cyan(PAD('  HackMyResume:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(`v${PKG.version}`));\n\n    _out.log(chalk.cyan(PAD('  FRESCA:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(PKG.dependencies.fresca)); //_out.log(chalk.cyan(PAD('  fresh-themes:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-themes'] ))\n    //_out.log(chalk.cyan(PAD('  fresh-jrs-converter:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-jrs-converter'] ))\n\n\n    _out.log('');\n  }\n\n  _err.init(o.debug, o.assert, o.silent); // Handle invalid verbs here (a bit easier here than in commander.js)...\n\n\n  if (o.verb && !HMR.verbs[o.verb] && !HMR.alias[o.verb] && o.verb !== 'help') {\n    await _err.err({\n      fluenterror: HMSTATUS.invalidCommand,\n      quit: true,\n      attempted: o.orgVerb\n    }, true);\n  } // Override the .missingArgument behavior\n\n\n  Command.prototype.missingArgument = function () {\n    if (this.name() !== 'help') {\n      _err.err({\n        verb: this.name(),\n        fluenterror: HMSTATUS.resumeNotFound\n      }, true);\n    }\n  }; // Override the .helpInformation behavior\n\n\n  Command.prototype.helpInformation = function () {\n    const manPage = FS.readFileSync(PATH.join(__dirname, 'help/use.txt'), 'utf8');\n    return M2C(manPage, 'white', 'yellow');\n  };\n\n  return {\n    args: o.args,\n    options: o.json\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/main.js",
      "startLine": 196,
      "endLine": 196,
      "before": "function (ar, exitCallback) {\n  _exitCallback = exitCallback || process.exit;\n  const o = initOptions(ar);\n\n  if (o.ex) {\n    _err.init(false, true, false);\n\n    if (o.ex.op === 'parse') {\n      _err.err({\n        fluenterror: o.ex.op === 'parse' ? HMSTATUS.invalidOptionsFile : HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    } else {\n      _err.err({\n        fluenterror: HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    }\n\n    return null;\n  }\n\n  o.silent || logMsg(_title); // Emit debug prelude if --debug was specified\n\n  if (o.debug) {\n    _out.log(chalk.cyan('The -d or --debug switch was specified. DEBUG mode engaged.'));\n\n    _out.log('');\n\n    _out.log(chalk.cyan(PAD('  Platform:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.platform === 'win32' ? 'windows' : process.platform));\n\n    _out.log(chalk.cyan(PAD('  Node.js:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.version));\n\n    _out.log(chalk.cyan(PAD('  HackMyResume:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(`v${PKG.version}`));\n\n    _out.log(chalk.cyan(PAD('  FRESCA:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(PKG.dependencies.fresca)); //_out.log(chalk.cyan(PAD('  fresh-themes:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-themes'] ))\n    //_out.log(chalk.cyan(PAD('  fresh-jrs-converter:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-jrs-converter'] ))\n\n\n    _out.log('');\n  }\n\n  _err.init(o.debug, o.assert, o.silent); // Handle invalid verbs here (a bit easier here than in commander.js)...\n\n\n  if (o.verb && !HMR.verbs[o.verb] && !HMR.alias[o.verb] && o.verb !== 'help') {\n    _err.err({\n      fluenterror: HMSTATUS.invalidCommand,\n      quit: true,\n      attempted: o.orgVerb\n    }, true);\n  } // Override the .missingArgument behavior\n\n\n  Command.prototype.missingArgument = function () {\n    if (this.name() !== 'help') {\n      _err.err({\n        verb: this.name(),\n        fluenterror: HMSTATUS.resumeNotFound\n      }, true);\n    }\n  }; // Override the .helpInformation behavior\n\n\n  Command.prototype.helpInformation = function () {\n    const manPage = FS.readFileSync(PATH.join(__dirname, 'help/use.txt'), 'utf8');\n    return M2C(manPage, 'white', 'yellow');\n  };\n\n  return {\n    args: o.args,\n    options: o.json\n  };\n}",
      "after": "async function (ar, exitCallback) {\n  _exitCallback = exitCallback || process.exit;\n  const o = initOptions(ar);\n\n  if (o.ex) {\n    _err.init(false, true, false);\n\n    if (o.ex.op === 'parse') {\n      await _err.err({\n        fluenterror: o.ex.op === 'parse' ? HMSTATUS.invalidOptionsFile : HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    } else {\n      await _err.err({\n        fluenterror: HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    }\n\n    return null;\n  }\n\n  o.silent || logMsg(_title); // Emit debug prelude if --debug was specified\n\n  if (o.debug) {\n    _out.log(chalk.cyan('The -d or --debug switch was specified. DEBUG mode engaged.'));\n\n    _out.log('');\n\n    _out.log(chalk.cyan(PAD('  Platform:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.platform === 'win32' ? 'windows' : process.platform));\n\n    _out.log(chalk.cyan(PAD('  Node.js:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.version));\n\n    _out.log(chalk.cyan(PAD('  HackMyResume:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(`v${PKG.version}`));\n\n    _out.log(chalk.cyan(PAD('  FRESCA:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(PKG.dependencies.fresca)); //_out.log(chalk.cyan(PAD('  fresh-themes:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-themes'] ))\n    //_out.log(chalk.cyan(PAD('  fresh-jrs-converter:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-jrs-converter'] ))\n\n\n    _out.log('');\n  }\n\n  _err.init(o.debug, o.assert, o.silent); // Handle invalid verbs here (a bit easier here than in commander.js)...\n\n\n  if (o.verb && !HMR.verbs[o.verb] && !HMR.alias[o.verb] && o.verb !== 'help') {\n    await _err.err({\n      fluenterror: HMSTATUS.invalidCommand,\n      quit: true,\n      attempted: o.orgVerb\n    }, true);\n  } // Override the .missingArgument behavior\n\n\n  Command.prototype.missingArgument = function () {\n    if (this.name() !== 'help') {\n      _err.err({\n        verb: this.name(),\n        fluenterror: HMSTATUS.resumeNotFound\n      }, true);\n    }\n  }; // Override the .helpInformation behavior\n\n\n  Command.prototype.helpInformation = function () {\n    const manPage = FS.readFileSync(PATH.join(__dirname, 'help/use.txt'), 'utf8');\n    return M2C(manPage, 'white', 'yellow');\n  };\n\n  return {\n    args: o.args,\n    options: o.json\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 60,
      "endLine": 60,
      "before": "// HackMyResume CLI stub. Handle a single HMR invocation.\nfunction HackMyResumeOutputStub(args) {\n  console.log = MyConsoleLog;\n  process.exit = MyProcessExit;\n  CHALK.enabled = false;\n\n  try {\n    args.unshift(process.argv[1]);\n    args.unshift(process.argv[0]);\n    HMRMAIN(args);\n  } catch (ex) {\n    console.error(ex);\n\n    require('../../src/cli/error').err(ex, false);\n  }\n\n  CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n  console.log = ConsoleLogOrg;\n} // Run a test through the stub, gathering console.log output into \"gather\"\n// and testing against it.",
      "after": "// HackMyResume CLI stub. Handle a single HMR invocation.\nasync function HackMyResumeOutputStub(args) {\n  console.log = MyConsoleLog;\n  process.exit = MyProcessExit;\n  CHALK.enabled = false;\n\n  try {\n    args.unshift(process.argv[1]);\n    args.unshift(process.argv[0]);\n    await HMRMAIN(args);\n  } catch (ex) {\n    console.error(ex);\n    await require('../../src/cli/error').err(ex, false);\n  }\n\n  CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n  console.log = ConsoleLogOrg;\n} // Run a test through the stub, gathering console.log output into \"gather\"\n// and testing against it."
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/error.js",
      "startLine": 201,
      "endLine": 201,
      "before": "function (ex) {\n  let se;\n  let msg = '';\n  let withStack = false;\n  let quit = false;\n  let etype = 'warning';\n\n  if (this.debug) {\n    withStack = true;\n  }\n\n  switch (ex.fluenterror) {\n    case HMSTATUS.themeNotFound:\n      msg = printf(M2C(this.msgs.themeNotFound.msg, 'yellow'), ex.data);\n      break;\n\n    case HMSTATUS.copyCSS:\n      msg = M2C(this.msgs.copyCSS.msg, 'red');\n      quit = false;\n      break;\n\n    case HMSTATUS.resumeNotFound:\n      //msg = M2C( this.msgs.resumeNotFound.msg, 'yellow' );\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, `help/${ex.verb}.txt`), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.missingCommand:\n      // msg = M2C( this.msgs.missingCommand.msg + \" (\", 'yellow');\n      // msg += Object.keys( FCMD.verbs ).map( (v, idx, ar) ->\n      //   return ( if idx == ar.length - 1 then chalk.yellow('or ') else '') +\n      //     chalk.yellow.bold(v.toUpperCase());\n      // ).join( chalk.yellow(', ')) + chalk.yellow(\").\\n\\n\");\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, 'help/use.txt'), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.invalidCommand:\n      msg = printf(M2C(this.msgs.invalidCommand.msg, 'yellow'), ex.attempted);\n      break;\n\n    case HMSTATUS.resumeNotFoundAlt:\n      msg = M2C(this.msgs.resumeNotFoundAlt.msg, 'yellow');\n      break;\n\n    case HMSTATUS.inputOutputParity:\n      msg = M2C(this.msgs.inputOutputParity.msg);\n      break;\n\n    case HMSTATUS.createNameMissing:\n      msg = M2C(this.msgs.createNameMissing.msg);\n      break;\n\n    case HMSTATUS.pdfGeneration:\n      msg = M2C(this.msgs.pdfGeneration.msg, 'bold');\n\n      if (ex.inner) {\n        msg += chalk.red(`\\n${ex.inner}`);\n      }\n\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalid:\n      msg = M2C(this.msgs.invalid.msg, 'red');\n      etype = 'error';\n      break;\n\n    case HMSTATUS.generateError:\n      msg = ex.inner && ex.inner.toString() || ex;\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.fileSaveError:\n      msg = printf(M2C(this.msgs.fileSaveError.msg), (ex.inner || ex).toString());\n      etype = 'error';\n      quit = false;\n      break;\n\n    case HMSTATUS.invalidFormat:\n      ex.data.forEach(function (d) {\n        return msg += printf(M2C(this.msgs.invalidFormat.msg, 'bold'), ex.theme.name.toUpperCase(), d.format.toUpperCase());\n      }, this);\n      break;\n\n    case HMSTATUS.missingParam:\n      msg = printf(M2C(this.msgs.missingParam.msg), ex.expected, ex.helper);\n      break;\n\n    case HMSTATUS.invalidHelperUse:\n      msg = printf(M2C(this.msgs.invalidHelperUse.msg), ex.helper);\n\n      if (ex.error) {\n        msg += `\\n--> ${assembleError.call(this, extend(true, {}, ex, {\n          fluenterror: ex.error\n        })).msg}`;\n      } //msg += printf( '\\n--> ' + M2C( this.msgs.invalidParamCount.msg ), ex.expected );\n\n\n      quit = false;\n      etype = 'warning';\n      break;\n\n    case HMSTATUS.notOnPath:\n      msg = printf(M2C(this.msgs.notOnPath.msg, 'bold'), ex.engine);\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.readError:\n      if (!ex.quiet) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n      }\n\n      msg = ex.inner.toString();\n      etype = 'error';\n      break;\n\n    case HMSTATUS.mixedMerge:\n      msg = M2C(this.msgs.mixedMerge.msg);\n      quit = false;\n      break;\n\n    case HMSTATUS.invokeTemplate:\n      msg = M2C(this.msgs.invokeTemplate.msg, 'red');\n      msg += M2C(`\\n${WRAP(ex.inner.toString(), {\n        width: 60,\n        indent: '   '\n      })}`, 'gray');\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.compileTemplate:\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeLoad:\n      msg = M2C(printf(this.msgs.themeLoad.msg, ex.attempted.toUpperCase()), 'red');\n\n      if (ex.inner && ex.inner.fluenterror) {\n        msg += M2C('\\nError: ', 'red') + assembleError.call(this, ex.inner).msg;\n      }\n\n      quit = true;\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.parseError:\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg = M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg = ex;\n      }\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.createError:\n      // inner.code could be EPERM, EACCES, etc\n      msg = printf(M2C(this.msgs.createError.msg), ex.inner.path);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.validateError:\n      msg = printf(M2C(this.msgs.validateError.msg), ex.inner.toString());\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidOptionsFile:\n      msg = M2C(this.msgs.invalidOptionsFile.msg[0]);\n\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg += M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg += ex;\n      }\n\n      msg += this.msgs.invalidOptionsFile.msg[1];\n      etype = 'error';\n      break;\n\n    case HMSTATUS.optionsFileNotFound:\n      msg = M2C(this.msgs.optionsFileNotFound.msg);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.unknownSchema:\n      msg = M2C(this.msgs.unknownSchema.msg[0]); //msg += \"\\n\" + M2C( @msgs.unknownSchema.msg[1], 'yellow' )\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeHelperLoad:\n      msg = printf(M2C(this.msgs.themeHelperLoad.msg), ex.glob);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidSchemaVersion:\n      msg = printf(M2C(this.msgs.invalidSchemaVersion.msg), ex.data);\n      etype = 'error';\n      break;\n  }\n\n  return {\n    msg,\n    // The error message to display\n    withStack,\n    // Whether to include the stack\n    quit,\n    etype\n  };\n}",
      "after": "async function (ex) {\n  let se;\n  let msg = '';\n  let withStack = false;\n  let quit = false;\n  let etype = 'warning';\n\n  if (this.debug) {\n    withStack = true;\n  }\n\n  switch (ex.fluenterror) {\n    case HMSTATUS.themeNotFound:\n      msg = printf(M2C(this.msgs.themeNotFound.msg, 'yellow'), ex.data);\n      break;\n\n    case HMSTATUS.copyCSS:\n      msg = M2C(this.msgs.copyCSS.msg, 'red');\n      quit = false;\n      break;\n\n    case HMSTATUS.resumeNotFound:\n      //msg = M2C( this.msgs.resumeNotFound.msg, 'yellow' );\n      msg += M2C(await FS.promises.readFile(PATH.resolve(__dirname, `help/${ex.verb}.txt`), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.missingCommand:\n      // msg = M2C( this.msgs.missingCommand.msg + \" (\", 'yellow');\n      // msg += Object.keys( FCMD.verbs ).map( (v, idx, ar) ->\n      //   return ( if idx == ar.length - 1 then chalk.yellow('or ') else '') +\n      //     chalk.yellow.bold(v.toUpperCase());\n      // ).join( chalk.yellow(', ')) + chalk.yellow(\").\\n\\n\");\n      msg += M2C(await FS.promises.readFile(PATH.resolve(__dirname, 'help/use.txt'), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.invalidCommand:\n      msg = printf(M2C(this.msgs.invalidCommand.msg, 'yellow'), ex.attempted);\n      break;\n\n    case HMSTATUS.resumeNotFoundAlt:\n      msg = M2C(this.msgs.resumeNotFoundAlt.msg, 'yellow');\n      break;\n\n    case HMSTATUS.inputOutputParity:\n      msg = M2C(this.msgs.inputOutputParity.msg);\n      break;\n\n    case HMSTATUS.createNameMissing:\n      msg = M2C(this.msgs.createNameMissing.msg);\n      break;\n\n    case HMSTATUS.pdfGeneration:\n      msg = M2C(this.msgs.pdfGeneration.msg, 'bold');\n\n      if (ex.inner) {\n        msg += chalk.red(`\\n${ex.inner}`);\n      }\n\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalid:\n      msg = M2C(this.msgs.invalid.msg, 'red');\n      etype = 'error';\n      break;\n\n    case HMSTATUS.generateError:\n      msg = ex.inner && ex.inner.toString() || ex;\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.fileSaveError:\n      msg = printf(M2C(this.msgs.fileSaveError.msg), (ex.inner || ex).toString());\n      etype = 'error';\n      quit = false;\n      break;\n\n    case HMSTATUS.invalidFormat:\n      ex.data.forEach(function (d) {\n        return msg += printf(M2C(this.msgs.invalidFormat.msg, 'bold'), ex.theme.name.toUpperCase(), d.format.toUpperCase());\n      }, this);\n      break;\n\n    case HMSTATUS.missingParam:\n      msg = printf(M2C(this.msgs.missingParam.msg), ex.expected, ex.helper);\n      break;\n\n    case HMSTATUS.invalidHelperUse:\n      msg = printf(M2C(this.msgs.invalidHelperUse.msg), ex.helper);\n\n      if (ex.error) {\n        msg += `\\n--> ${(await assembleError.call(this, extend(true, {}, ex, {\n          fluenterror: ex.error\n        }))).msg}`;\n      } //msg += printf( '\\n--> ' + M2C( this.msgs.invalidParamCount.msg ), ex.expected );\n\n\n      quit = false;\n      etype = 'warning';\n      break;\n\n    case HMSTATUS.notOnPath:\n      msg = printf(M2C(this.msgs.notOnPath.msg, 'bold'), ex.engine);\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.readError:\n      if (!ex.quiet) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n      }\n\n      msg = ex.inner.toString();\n      etype = 'error';\n      break;\n\n    case HMSTATUS.mixedMerge:\n      msg = M2C(this.msgs.mixedMerge.msg);\n      quit = false;\n      break;\n\n    case HMSTATUS.invokeTemplate:\n      msg = M2C(this.msgs.invokeTemplate.msg, 'red');\n      msg += M2C(`\\n${WRAP(ex.inner.toString(), {\n        width: 60,\n        indent: '   '\n      })}`, 'gray');\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.compileTemplate:\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeLoad:\n      msg = M2C(printf(this.msgs.themeLoad.msg, ex.attempted.toUpperCase()), 'red');\n\n      if (ex.inner && ex.inner.fluenterror) {\n        msg += M2C('\\nError: ', 'red') + (await assembleError.call(this, ex.inner)).msg;\n      }\n\n      quit = true;\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.parseError:\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg = M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg = ex;\n      }\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.createError:\n      // inner.code could be EPERM, EACCES, etc\n      msg = printf(M2C(this.msgs.createError.msg), ex.inner.path);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.validateError:\n      msg = printf(M2C(this.msgs.validateError.msg), ex.inner.toString());\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidOptionsFile:\n      msg = M2C(this.msgs.invalidOptionsFile.msg[0]);\n\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg += M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg += ex;\n      }\n\n      msg += this.msgs.invalidOptionsFile.msg[1];\n      etype = 'error';\n      break;\n\n    case HMSTATUS.optionsFileNotFound:\n      msg = M2C(this.msgs.optionsFileNotFound.msg);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.unknownSchema:\n      msg = M2C(this.msgs.unknownSchema.msg[0]); //msg += \"\\n\" + M2C( @msgs.unknownSchema.msg[1], 'yellow' )\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeHelperLoad:\n      msg = printf(M2C(this.msgs.themeHelperLoad.msg), ex.glob);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidSchemaVersion:\n      msg = printf(M2C(this.msgs.invalidSchemaVersion.msg), ex.data);\n      etype = 'error';\n      break;\n  }\n\n  return {\n    msg,\n    // The error message to display\n    withStack,\n    // Whether to include the stack\n    quit,\n    etype\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/error.js",
      "startLine": 241,
      "endLine": 241,
      "before": "function (ex) {\n  let se;\n  let msg = '';\n  let withStack = false;\n  let quit = false;\n  let etype = 'warning';\n\n  if (this.debug) {\n    withStack = true;\n  }\n\n  switch (ex.fluenterror) {\n    case HMSTATUS.themeNotFound:\n      msg = printf(M2C(this.msgs.themeNotFound.msg, 'yellow'), ex.data);\n      break;\n\n    case HMSTATUS.copyCSS:\n      msg = M2C(this.msgs.copyCSS.msg, 'red');\n      quit = false;\n      break;\n\n    case HMSTATUS.resumeNotFound:\n      //msg = M2C( this.msgs.resumeNotFound.msg, 'yellow' );\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, `help/${ex.verb}.txt`), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.missingCommand:\n      // msg = M2C( this.msgs.missingCommand.msg + \" (\", 'yellow');\n      // msg += Object.keys( FCMD.verbs ).map( (v, idx, ar) ->\n      //   return ( if idx == ar.length - 1 then chalk.yellow('or ') else '') +\n      //     chalk.yellow.bold(v.toUpperCase());\n      // ).join( chalk.yellow(', ')) + chalk.yellow(\").\\n\\n\");\n      msg += M2C(FS.readFileSync(PATH.resolve(__dirname, 'help/use.txt'), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.invalidCommand:\n      msg = printf(M2C(this.msgs.invalidCommand.msg, 'yellow'), ex.attempted);\n      break;\n\n    case HMSTATUS.resumeNotFoundAlt:\n      msg = M2C(this.msgs.resumeNotFoundAlt.msg, 'yellow');\n      break;\n\n    case HMSTATUS.inputOutputParity:\n      msg = M2C(this.msgs.inputOutputParity.msg);\n      break;\n\n    case HMSTATUS.createNameMissing:\n      msg = M2C(this.msgs.createNameMissing.msg);\n      break;\n\n    case HMSTATUS.pdfGeneration:\n      msg = M2C(this.msgs.pdfGeneration.msg, 'bold');\n\n      if (ex.inner) {\n        msg += chalk.red(`\\n${ex.inner}`);\n      }\n\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalid:\n      msg = M2C(this.msgs.invalid.msg, 'red');\n      etype = 'error';\n      break;\n\n    case HMSTATUS.generateError:\n      msg = ex.inner && ex.inner.toString() || ex;\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.fileSaveError:\n      msg = printf(M2C(this.msgs.fileSaveError.msg), (ex.inner || ex).toString());\n      etype = 'error';\n      quit = false;\n      break;\n\n    case HMSTATUS.invalidFormat:\n      ex.data.forEach(function (d) {\n        return msg += printf(M2C(this.msgs.invalidFormat.msg, 'bold'), ex.theme.name.toUpperCase(), d.format.toUpperCase());\n      }, this);\n      break;\n\n    case HMSTATUS.missingParam:\n      msg = printf(M2C(this.msgs.missingParam.msg), ex.expected, ex.helper);\n      break;\n\n    case HMSTATUS.invalidHelperUse:\n      msg = printf(M2C(this.msgs.invalidHelperUse.msg), ex.helper);\n\n      if (ex.error) {\n        msg += `\\n--> ${assembleError.call(this, extend(true, {}, ex, {\n          fluenterror: ex.error\n        })).msg}`;\n      } //msg += printf( '\\n--> ' + M2C( this.msgs.invalidParamCount.msg ), ex.expected );\n\n\n      quit = false;\n      etype = 'warning';\n      break;\n\n    case HMSTATUS.notOnPath:\n      msg = printf(M2C(this.msgs.notOnPath.msg, 'bold'), ex.engine);\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.readError:\n      if (!ex.quiet) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n      }\n\n      msg = ex.inner.toString();\n      etype = 'error';\n      break;\n\n    case HMSTATUS.mixedMerge:\n      msg = M2C(this.msgs.mixedMerge.msg);\n      quit = false;\n      break;\n\n    case HMSTATUS.invokeTemplate:\n      msg = M2C(this.msgs.invokeTemplate.msg, 'red');\n      msg += M2C(`\\n${WRAP(ex.inner.toString(), {\n        width: 60,\n        indent: '   '\n      })}`, 'gray');\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.compileTemplate:\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeLoad:\n      msg = M2C(printf(this.msgs.themeLoad.msg, ex.attempted.toUpperCase()), 'red');\n\n      if (ex.inner && ex.inner.fluenterror) {\n        msg += M2C('\\nError: ', 'red') + assembleError.call(this, ex.inner).msg;\n      }\n\n      quit = true;\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.parseError:\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg = M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg = ex;\n      }\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.createError:\n      // inner.code could be EPERM, EACCES, etc\n      msg = printf(M2C(this.msgs.createError.msg), ex.inner.path);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.validateError:\n      msg = printf(M2C(this.msgs.validateError.msg), ex.inner.toString());\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidOptionsFile:\n      msg = M2C(this.msgs.invalidOptionsFile.msg[0]);\n\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg += M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg += ex;\n      }\n\n      msg += this.msgs.invalidOptionsFile.msg[1];\n      etype = 'error';\n      break;\n\n    case HMSTATUS.optionsFileNotFound:\n      msg = M2C(this.msgs.optionsFileNotFound.msg);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.unknownSchema:\n      msg = M2C(this.msgs.unknownSchema.msg[0]); //msg += \"\\n\" + M2C( @msgs.unknownSchema.msg[1], 'yellow' )\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeHelperLoad:\n      msg = printf(M2C(this.msgs.themeHelperLoad.msg), ex.glob);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidSchemaVersion:\n      msg = printf(M2C(this.msgs.invalidSchemaVersion.msg), ex.data);\n      etype = 'error';\n      break;\n  }\n\n  return {\n    msg,\n    // The error message to display\n    withStack,\n    // Whether to include the stack\n    quit,\n    etype\n  };\n}",
      "after": "async function (ex) {\n  let se;\n  let msg = '';\n  let withStack = false;\n  let quit = false;\n  let etype = 'warning';\n\n  if (this.debug) {\n    withStack = true;\n  }\n\n  switch (ex.fluenterror) {\n    case HMSTATUS.themeNotFound:\n      msg = printf(M2C(this.msgs.themeNotFound.msg, 'yellow'), ex.data);\n      break;\n\n    case HMSTATUS.copyCSS:\n      msg = M2C(this.msgs.copyCSS.msg, 'red');\n      quit = false;\n      break;\n\n    case HMSTATUS.resumeNotFound:\n      //msg = M2C( this.msgs.resumeNotFound.msg, 'yellow' );\n      msg += M2C(await FS.promises.readFile(PATH.resolve(__dirname, `help/${ex.verb}.txt`), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.missingCommand:\n      // msg = M2C( this.msgs.missingCommand.msg + \" (\", 'yellow');\n      // msg += Object.keys( FCMD.verbs ).map( (v, idx, ar) ->\n      //   return ( if idx == ar.length - 1 then chalk.yellow('or ') else '') +\n      //     chalk.yellow.bold(v.toUpperCase());\n      // ).join( chalk.yellow(', ')) + chalk.yellow(\").\\n\\n\");\n      msg += M2C(await FS.promises.readFile(PATH.resolve(__dirname, 'help/use.txt'), 'utf8'), 'white', 'yellow');\n      break;\n\n    case HMSTATUS.invalidCommand:\n      msg = printf(M2C(this.msgs.invalidCommand.msg, 'yellow'), ex.attempted);\n      break;\n\n    case HMSTATUS.resumeNotFoundAlt:\n      msg = M2C(this.msgs.resumeNotFoundAlt.msg, 'yellow');\n      break;\n\n    case HMSTATUS.inputOutputParity:\n      msg = M2C(this.msgs.inputOutputParity.msg);\n      break;\n\n    case HMSTATUS.createNameMissing:\n      msg = M2C(this.msgs.createNameMissing.msg);\n      break;\n\n    case HMSTATUS.pdfGeneration:\n      msg = M2C(this.msgs.pdfGeneration.msg, 'bold');\n\n      if (ex.inner) {\n        msg += chalk.red(`\\n${ex.inner}`);\n      }\n\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalid:\n      msg = M2C(this.msgs.invalid.msg, 'red');\n      etype = 'error';\n      break;\n\n    case HMSTATUS.generateError:\n      msg = ex.inner && ex.inner.toString() || ex;\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.fileSaveError:\n      msg = printf(M2C(this.msgs.fileSaveError.msg), (ex.inner || ex).toString());\n      etype = 'error';\n      quit = false;\n      break;\n\n    case HMSTATUS.invalidFormat:\n      ex.data.forEach(function (d) {\n        return msg += printf(M2C(this.msgs.invalidFormat.msg, 'bold'), ex.theme.name.toUpperCase(), d.format.toUpperCase());\n      }, this);\n      break;\n\n    case HMSTATUS.missingParam:\n      msg = printf(M2C(this.msgs.missingParam.msg), ex.expected, ex.helper);\n      break;\n\n    case HMSTATUS.invalidHelperUse:\n      msg = printf(M2C(this.msgs.invalidHelperUse.msg), ex.helper);\n\n      if (ex.error) {\n        msg += `\\n--> ${(await assembleError.call(this, extend(true, {}, ex, {\n          fluenterror: ex.error\n        }))).msg}`;\n      } //msg += printf( '\\n--> ' + M2C( this.msgs.invalidParamCount.msg ), ex.expected );\n\n\n      quit = false;\n      etype = 'warning';\n      break;\n\n    case HMSTATUS.notOnPath:\n      msg = printf(M2C(this.msgs.notOnPath.msg, 'bold'), ex.engine);\n      quit = false;\n      etype = 'error';\n      break;\n\n    case HMSTATUS.readError:\n      if (!ex.quiet) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n      }\n\n      msg = ex.inner.toString();\n      etype = 'error';\n      break;\n\n    case HMSTATUS.mixedMerge:\n      msg = M2C(this.msgs.mixedMerge.msg);\n      quit = false;\n      break;\n\n    case HMSTATUS.invokeTemplate:\n      msg = M2C(this.msgs.invokeTemplate.msg, 'red');\n      msg += M2C(`\\n${WRAP(ex.inner.toString(), {\n        width: 60,\n        indent: '   '\n      })}`, 'gray');\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.compileTemplate:\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeLoad:\n      msg = M2C(printf(this.msgs.themeLoad.msg, ex.attempted.toUpperCase()), 'red');\n\n      if (ex.inner && ex.inner.fluenterror) {\n        msg += M2C('\\nError: ', 'red') + (await assembleError.call(this, ex.inner)).msg;\n      }\n\n      quit = true;\n      etype = 'custom';\n      break;\n\n    case HMSTATUS.parseError:\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg = printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg = M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg = printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg = ex;\n      }\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.createError:\n      // inner.code could be EPERM, EACCES, etc\n      msg = printf(M2C(this.msgs.createError.msg), ex.inner.path);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.validateError:\n      msg = printf(M2C(this.msgs.validateError.msg), ex.inner.toString());\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidOptionsFile:\n      msg = M2C(this.msgs.invalidOptionsFile.msg[0]);\n\n      if (SyntaxErrorEx.is(ex.inner)) {\n        // eslint-disable-next-line no-console\n        console.error(printf(M2C(this.msgs.readError.msg, 'red'), ex.file));\n        se = new SyntaxErrorEx(ex, ex.raw);\n\n        if (se.line != null && se.col != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), se.line, se.col);\n        } else if (se.line != null) {\n          msg += printf(M2C(this.msgs.parseError.msg[1], 'red'), se.line);\n        } else {\n          msg += M2C(this.msgs.parseError.msg[2], 'red');\n        }\n      } else if (ex.inner && ex.inner.line != null && ex.inner.col != null) {\n        msg += printf(M2C(this.msgs.parseError.msg[0], 'red'), ex.inner.line, ex.inner.col);\n      } else {\n        msg += ex;\n      }\n\n      msg += this.msgs.invalidOptionsFile.msg[1];\n      etype = 'error';\n      break;\n\n    case HMSTATUS.optionsFileNotFound:\n      msg = M2C(this.msgs.optionsFileNotFound.msg);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.unknownSchema:\n      msg = M2C(this.msgs.unknownSchema.msg[0]); //msg += \"\\n\" + M2C( @msgs.unknownSchema.msg[1], 'yellow' )\n\n      etype = 'error';\n      break;\n\n    case HMSTATUS.themeHelperLoad:\n      msg = printf(M2C(this.msgs.themeHelperLoad.msg), ex.glob);\n      etype = 'error';\n      break;\n\n    case HMSTATUS.invalidSchemaVersion:\n      msg = printf(M2C(this.msgs.invalidSchemaVersion.msg), ex.data);\n      etype = 'error';\n      break;\n  }\n\n  return {\n    msg,\n    // The error message to display\n    withStack,\n    // Whether to include the stack\n    quit,\n    etype\n  };\n}"
    }
  ],
  "4": [
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/html-png-generator.js",
      "startLine": 52,
      "endLine": 52,
      "before": "function (markup, fOut) {\n  // Save the markup to a temporary file\n  const tempFile = fOut.replace(/\\.png$/i, '.png.html');\n  FS.writeFileSync(tempFile, markup, 'utf8');\n  const scriptPath = SLASH(PATH.relative(process.cwd(), PATH.resolve(__dirname, '../utils/rasterize.js')));\n  const sourcePath = SLASH(PATH.relative(process.cwd(), tempFile));\n  const destPath = SLASH(PATH.relative(process.cwd(), fOut));\n  SPAWN('phantomjs', [scriptPath, sourcePath, destPath]);\n}",
      "after": "async function (markup, fOut) {\n  // Save the markup to a temporary file\n  const tempFile = fOut.replace(/\\.png$/i, '.png.html');\n  await FS.promises.writeFile(tempFile, markup, 'utf8');\n  const scriptPath = SLASH(PATH.relative(process.cwd(), PATH.resolve(__dirname, '../utils/rasterize.js')));\n  const sourcePath = SLASH(PATH.relative(process.cwd(), tempFile));\n  const destPath = SLASH(PATH.relative(process.cwd(), fOut));\n  SPAWN('phantomjs', [scriptPath, sourcePath, destPath]);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/html-png-generator.js",
      "startLine": 34,
      "endLine": 34,
      "before": "// TODO: Not currently called or callable.\ngenerate(rez, f, opts) {\n  const htmlResults = opts.targets.filter(t => t.fmt.outFormat === 'html');\n  const htmlFile = htmlResults[0].final.files.filter(fl => fl.info.ext === 'html');\n  phantom(htmlFile[0].data, f);\n}",
      "after": "// TODO: Not currently called or callable.\nasync generate(rez, f, opts) {\n  const htmlResults = opts.targets.filter(t => t.fmt.outFormat === 'html');\n  const htmlFile = htmlResults[0].final.files.filter(fl => fl.info.ext === 'html');\n  await phantom(htmlFile[0].data, f);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/template-generator.js",
      "startLine": 180,
      "endLine": 180,
      "before": "/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */\ntransform(json, jst, format, opts, theme, curFmt) {\n  if (this.opts.freezeBreaks) {\n    jst = freeze(jst);\n  }\n\n  const eng = require(`../renderers/${theme.engine}-generator`);\n\n  let result = eng.generate(json, jst, format, curFmt, opts, theme);\n\n  if (this.opts.freezeBreaks) {\n    result = unfreeze(result);\n  }\n\n  return result;\n}",
      "after": "/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */\nasync transform(json, jst, format, opts, theme, curFmt) {\n  if (this.opts.freezeBreaks) {\n    jst = freeze(jst);\n  }\n\n  const eng = require(`../renderers/${theme.engine}-generator`);\n\n  let result = await eng.generate(json, jst, format, curFmt, opts, theme);\n\n  if (this.opts.freezeBreaks) {\n    result = unfreeze(result);\n  }\n\n  return result;\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/template-generator.js",
      "startLine": 71,
      "endLine": 71,
      "before": "function (tplInfo, idx) {\n  let trx;\n\n  if (tplInfo.action === 'transform') {\n    trx = this.transform(rez, tplInfo.data, this.format, opts, opts.themeObj, curFmt);\n\n    if (tplInfo.ext === 'css') {\n      curFmt.files[idx].data = trx;\n    } else {\n      tplInfo.ext === 'html';\n    }\n  } //tplInfo.css contains the CSS data loaded by theme\n  //tplInfo.cssPath contains the absolute path to the source CSS File\n  //else {}\n  // Images and non-transformable binary files\n\n\n  if (typeof opts.onTransform === 'function') {\n    opts.onTransform(tplInfo);\n  }\n\n  return {\n    info: tplInfo,\n    data: trx\n  };\n}",
      "after": "async function (tplInfo, idx) {\n  let trx;\n\n  if (tplInfo.action === 'transform') {\n    trx = await this.transform(rez, tplInfo.data, this.format, opts, opts.themeObj, curFmt);\n\n    if (tplInfo.ext === 'css') {\n      curFmt.files[idx].data = trx;\n    } else {\n      tplInfo.ext === 'html';\n    }\n  } //tplInfo.css contains the CSS data loaded by theme\n  //tplInfo.cssPath contains the absolute path to the source CSS File\n  //else {}\n  // Images and non-transformable binary files\n\n\n  if (typeof opts.onTransform === 'function') {\n    opts.onTransform(tplInfo);\n  }\n\n  return {\n    info: tplInfo,\n    data: trx\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/json-generator.js",
      "startLine": 29,
      "endLine": 29,
      "before": "//altRez.stringify()\ngenerate(rez, f) {\n  FS.writeFileSync(f, this.invoke(rez), 'utf8');\n}",
      "after": "//altRez.stringify()\nasync generate(rez, f) {\n  FS.writeFileSync(f, await this.invoke(rez), 'utf8');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/template-generator.js",
      "startLine": 105,
      "endLine": 105,
      "before": "/** Generate a resume using file-based inputs and outputs. Requires access\nto the local filesystem.\n@method generate\n@param rez A FreshResume object.\n@param f Full path to the output resume file to generate.\n@param opts Generator options. */\ngenerate(rez, f, opts) {\n  // Prepare\n  this.opts = EXTEND(true, {}, _defaultOpts, opts); // Call the string-based generation method\n\n  const genInfo = this.invoke(rez, null);\n  const outFolder = parsePath(f).dirname;\n  const curFmt = opts.themeObj.getFormat(this.format); // Process individual files within this format. For example, the HTML\n  // output format for a theme may have multiple HTML files, CSS files,\n  // etc. Process them here.\n\n  genInfo.files.forEach(function (file) {\n    // console.dir _.omit(file.info,'cssData','data','css' )\n    // Pre-processing\n    file.info.orgPath = file.info.orgPath || '';\n    const thisFilePath = file.info.primary ? f : PATH.join(outFolder, file.info.orgPath);\n\n    if (file.info.action !== 'copy' && this.onBeforeSave) {\n      file.data = this.onBeforeSave({\n        theme: opts.themeObj,\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts,\n        ext: file.info.ext\n      });\n\n      if (!file.data) {\n        return;\n      }\n    } // Write the file\n\n\n    if (typeof opts.beforeWrite === 'function') {\n      opts.beforeWrite({\n        data: thisFilePath\n      });\n    }\n\n    MKDIRP.sync(PATH.dirname(thisFilePath));\n\n    if (file.info.action !== 'copy') {\n      FS.writeFileSync(thisFilePath, file.data, {\n        encoding: 'utf8',\n        flags: 'w'\n      });\n    } else {\n      FS.copySync(file.info.path, thisFilePath);\n    }\n\n    if (typeof opts.afterWrite === 'function') {\n      opts.afterWrite({\n        data: thisFilePath\n      });\n    } // Post-processing\n\n\n    if (this.onAfterSave) {\n      return this.onAfterSave({\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts\n      });\n    }\n  }, this); // Some themes require a symlink structure. If so, create it.\n\n  createSymLinks(curFmt, outFolder);\n  return genInfo;\n}\n/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */",
      "after": "/** Generate a resume using file-based inputs and outputs. Requires access\nto the local filesystem.\n@method generate\n@param rez A FreshResume object.\n@param f Full path to the output resume file to generate.\n@param opts Generator options. */\nasync generate(rez, f, opts) {\n  // Prepare\n  this.opts = EXTEND(true, {}, _defaultOpts, opts); // Call the string-based generation method\n\n  const genInfo = await this.invoke(rez, null);\n  const outFolder = parsePath(f).dirname;\n  const curFmt = opts.themeObj.getFormat(this.format); // Process individual files within this format. For example, the HTML\n  // output format for a theme may have multiple HTML files, CSS files,\n  // etc. Process them here.\n\n  genInfo.files.forEach(function (file) {\n    // console.dir _.omit(file.info,'cssData','data','css' )\n    // Pre-processing\n    file.info.orgPath = file.info.orgPath || '';\n    const thisFilePath = file.info.primary ? f : PATH.join(outFolder, file.info.orgPath);\n\n    if (file.info.action !== 'copy' && this.onBeforeSave) {\n      file.data = this.onBeforeSave({\n        theme: opts.themeObj,\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts,\n        ext: file.info.ext\n      });\n\n      if (!file.data) {\n        return;\n      }\n    } // Write the file\n\n\n    if (typeof opts.beforeWrite === 'function') {\n      opts.beforeWrite({\n        data: thisFilePath\n      });\n    }\n\n    MKDIRP.sync(PATH.dirname(thisFilePath));\n\n    if (file.info.action !== 'copy') {\n      FS.writeFileSync(thisFilePath, file.data, {\n        encoding: 'utf8',\n        flags: 'w'\n      });\n    } else {\n      FS.copySync(file.info.path, thisFilePath);\n    }\n\n    if (typeof opts.afterWrite === 'function') {\n      opts.afterWrite({\n        data: thisFilePath\n      });\n    } // Post-processing\n\n\n    if (this.onAfterSave) {\n      return this.onAfterSave({\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts\n      });\n    }\n  }, this); // Some themes require a symlink structure. If so, create it.\n\n  createSymLinks(curFmt, outFolder);\n  return genInfo;\n}\n/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 63,
      "endLine": 63,
      "before": "function () {\n  // Set up options\n  var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n  var opts = {\n    theme: themeLoc,\n    format: fmt,\n    prettify: true,\n    silent: false,\n    css: 'embed',\n    debug: true\n  }; // Run the command!\n\n  var v = new HackMyResume.verbs.build();\n  v.on('hmr:error', function (ex) {\n    console.error('Error thrown: %o', ex);\n    throw ex; //assert(false);\n  });\n  var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n  return p.then(function (obj) {} //,function(obj) { },\n  );\n}",
      "after": "async function () {\n  // Set up options\n  var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n  var opts = {\n    theme: themeLoc,\n    format: fmt,\n    prettify: true,\n    silent: false,\n    css: 'embed',\n    debug: true\n  }; // Run the command!\n\n  var v = new HackMyResume.verbs.build();\n  v.on('hmr:error', function (ex) {\n    console.error('Error thrown: %o', ex);\n    throw ex; //assert(false);\n  });\n  var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n  return p.then(function (obj) {} //,function(obj) { },\n  );\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 76,
      "endLine": 76,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 119,
      "endLine": 123,
      "before": "genThemes('jane-q-fullstacker', ['node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json'], 'FRESH')",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait genThemes('jane-q-fullstacker', ['node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json'], 'FRESH')"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 125,
      "endLine": 129,
      "before": "genThemes('johnny-trouble', ['node_modules/fresh-test-resumes/src/fresh/johnny-trouble.json'], 'FRESH')",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait genThemes('johnny-trouble', ['node_modules/fresh-test-resumes/src/fresh/johnny-trouble.json'], 'FRESH')"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 131,
      "endLine": 135,
      "before": "genThemes('richard-hendriks', ['node_modules/fresh-test-resumes/src/jrs/richard-hendriks.json'], 'JRS')",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait genThemes('richard-hendriks', ['node_modules/fresh-test-resumes/src/jrs/richard-hendriks.json'], 'JRS')"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 77,
      "endLine": 77,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 78,
      "endLine": 78,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 79,
      "endLine": 79,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 80,
      "endLine": 80,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 82,
      "endLine": 83,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 84,
      "endLine": 85,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 86,
      "endLine": 87,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 88,
      "endLine": 89,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-verbs.js",
      "startLine": 196,
      "endLine": 196,
      "before": "function (done) {\n  var v = new FCMD.verbs[verb]();\n  v.on('hmr:error', function (ex) {\n    assert(false);\n  });\n  var prom = v.invoke(src, dst, opts);\n  var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n  if (fnTest) {\n    prom.should.be[fulfillMethod].then(function (obj) {\n      fnTest(obj.sheet);\n    }).should.notify(done);\n  } else {\n    prom.should.be[fulfillMethod].notify(done);\n  }\n}",
      "after": "async function (done) {\n  var v = new FCMD.verbs[verb]();\n  v.on('hmr:error', function (ex) {\n    assert(false);\n  });\n  var prom = await v.invoke(src, dst, opts);\n  var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n  if (fnTest) {\n    prom.should.be[fulfillMethod].then(function (obj) {\n      fnTest(obj.sheet);\n    }).should.notify(done);\n  } else {\n    prom.should.be[fulfillMethod].notify(done);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-verbs.js",
      "startLine": 213,
      "endLine": 213,
      "before": "function (a) {\n  run.apply(\n  /* The players of */\n  null, a);\n}",
      "after": "async function (a) {\n  await run.apply(\n  /* The players of */\n  null, a);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-dates.js",
      "startLine": 81,
      "endLine": 91,
      "before": "function () {\n  tests.forEach(function (t) {\n    it(JSON.stringify(_.initial(t)), function () {\n      r.employment.history = _.initial(t);\n      var rObj = new FRESHResume();\n      rObj.parseJSON(r);\n      var dur = rObj.duration();\n      expect(dur).to.equal(_.last(t).val);\n    });\n  });\n}",
      "after": "async function () {\n  await tests.forEach(function (t) {\n    it(JSON.stringify(_.initial(t)), function () {\n      r.employment.history = _.initial(t);\n      var rObj = new FRESHResume();\n      rObj.parseJSON(r);\n      var dur = rObj.duration();\n      expect(dur).to.equal(_.last(t).val);\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-verbs.js",
      "startLine": 212,
      "endLine": 214,
      "before": "function () {\n  this.timeout(5000);\n\n  function run(verb, src, dst, opts, msg, fnTest) {\n    msg = msg || '.';\n    var shouldSucceed = true;\n\n    if (verb[0] === '!') {\n      verb = verb.substr(1);\n      shouldSucceed = false;\n    }\n\n    it('The ' + verb.toUpperCase() + ' command should ' + (shouldSucceed ? ' SUCCEED' : ' FAIL') + msg, function (done) {\n      var v = new FCMD.verbs[verb]();\n      v.on('hmr:error', function (ex) {\n        assert(false);\n      });\n      var prom = v.invoke(src, dst, opts);\n      var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n      if (fnTest) {\n        prom.should.be[fulfillMethod].then(function (obj) {\n          fnTest(obj.sheet);\n        }).should.notify(done);\n      } else {\n        prom.should.be[fulfillMethod].notify(done);\n      }\n    });\n  }\n\n  tests.forEach(function (a) {\n    run.apply(\n    /* The players of */\n    null, a);\n  });\n}",
      "after": "async function () {\n  this.timeout(5000);\n\n  function run(verb, src, dst, opts, msg, fnTest) {\n    msg = msg || '.';\n    var shouldSucceed = true;\n\n    if (verb[0] === '!') {\n      verb = verb.substr(1);\n      shouldSucceed = false;\n    }\n\n    it('The ' + verb.toUpperCase() + ' command should ' + (shouldSucceed ? ' SUCCEED' : ' FAIL') + msg, async function (done) {\n      var v = new FCMD.verbs[verb]();\n      v.on('hmr:error', function (ex) {\n        assert(false);\n      });\n      var prom = await v.invoke(src, dst, opts);\n      var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n      if (fnTest) {\n        prom.should.be[fulfillMethod].then(function (obj) {\n          fnTest(obj.sheet);\n        }).should.notify(done);\n      } else {\n        prom.should.be[fulfillMethod].notify(done);\n      }\n    });\n  }\n\n  await tests.forEach(async function (a) {\n    await run.apply(\n    /* The players of */\n    null, a);\n  });\n}"
    }
  ],
  "5": [
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/json-generator.js",
      "startLine": 29,
      "endLine": 29,
      "before": "//altRez.stringify()\ngenerate(rez, f) {\n  FS.writeFileSync(f, this.invoke(rez), 'utf8');\n}",
      "after": "//altRez.stringify()\nasync generate(rez, f) {\n  await FS.promises.writeFile(f, await this.invoke(rez), 'utf8');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/template-generator.js",
      "startLine": 180,
      "endLine": 180,
      "before": "/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */\ntransform(json, jst, format, opts, theme, curFmt) {\n  if (this.opts.freezeBreaks) {\n    jst = freeze(jst);\n  }\n\n  const eng = require(`../renderers/${theme.engine}-generator`);\n\n  let result = eng.generate(json, jst, format, curFmt, opts, theme);\n\n  if (this.opts.freezeBreaks) {\n    result = unfreeze(result);\n  }\n\n  return result;\n}",
      "after": "/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */\nasync transform(json, jst, format, opts, theme, curFmt) {\n  if (this.opts.freezeBreaks) {\n    jst = freeze(jst);\n  }\n\n  const eng = require(`../renderers/${theme.engine}-generator`);\n\n  let result = await eng.generate(json, jst, format, curFmt, opts, theme);\n\n  if (this.opts.freezeBreaks) {\n    result = unfreeze(result);\n  }\n\n  return result;\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/template-generator.js",
      "startLine": 71,
      "endLine": 71,
      "before": "function (tplInfo, idx) {\n  let trx;\n\n  if (tplInfo.action === 'transform') {\n    trx = this.transform(rez, tplInfo.data, this.format, opts, opts.themeObj, curFmt);\n\n    if (tplInfo.ext === 'css') {\n      curFmt.files[idx].data = trx;\n    } else {\n      tplInfo.ext === 'html';\n    }\n  } //tplInfo.css contains the CSS data loaded by theme\n  //tplInfo.cssPath contains the absolute path to the source CSS File\n  //else {}\n  // Images and non-transformable binary files\n\n\n  if (typeof opts.onTransform === 'function') {\n    opts.onTransform(tplInfo);\n  }\n\n  return {\n    info: tplInfo,\n    data: trx\n  };\n}",
      "after": "async function (tplInfo, idx) {\n  let trx;\n\n  if (tplInfo.action === 'transform') {\n    trx = await this.transform(rez, tplInfo.data, this.format, opts, opts.themeObj, curFmt);\n\n    if (tplInfo.ext === 'css') {\n      curFmt.files[idx].data = trx;\n    } else {\n      tplInfo.ext === 'html';\n    }\n  } //tplInfo.css contains the CSS data loaded by theme\n  //tplInfo.cssPath contains the absolute path to the source CSS File\n  //else {}\n  // Images and non-transformable binary files\n\n\n  if (typeof opts.onTransform === 'function') {\n    opts.onTransform(tplInfo);\n  }\n\n  return {\n    info: tplInfo,\n    data: trx\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/template-generator.js",
      "startLine": 105,
      "endLine": 105,
      "before": "/** Generate a resume using file-based inputs and outputs. Requires access\nto the local filesystem.\n@method generate\n@param rez A FreshResume object.\n@param f Full path to the output resume file to generate.\n@param opts Generator options. */\ngenerate(rez, f, opts) {\n  // Prepare\n  this.opts = EXTEND(true, {}, _defaultOpts, opts); // Call the string-based generation method\n\n  const genInfo = this.invoke(rez, null);\n  const outFolder = parsePath(f).dirname;\n  const curFmt = opts.themeObj.getFormat(this.format); // Process individual files within this format. For example, the HTML\n  // output format for a theme may have multiple HTML files, CSS files,\n  // etc. Process them here.\n\n  genInfo.files.forEach(function (file) {\n    // console.dir _.omit(file.info,'cssData','data','css' )\n    // Pre-processing\n    file.info.orgPath = file.info.orgPath || '';\n    const thisFilePath = file.info.primary ? f : PATH.join(outFolder, file.info.orgPath);\n\n    if (file.info.action !== 'copy' && this.onBeforeSave) {\n      file.data = this.onBeforeSave({\n        theme: opts.themeObj,\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts,\n        ext: file.info.ext\n      });\n\n      if (!file.data) {\n        return;\n      }\n    } // Write the file\n\n\n    if (typeof opts.beforeWrite === 'function') {\n      opts.beforeWrite({\n        data: thisFilePath\n      });\n    }\n\n    MKDIRP.sync(PATH.dirname(thisFilePath));\n\n    if (file.info.action !== 'copy') {\n      FS.writeFileSync(thisFilePath, file.data, {\n        encoding: 'utf8',\n        flags: 'w'\n      });\n    } else {\n      FS.copySync(file.info.path, thisFilePath);\n    }\n\n    if (typeof opts.afterWrite === 'function') {\n      opts.afterWrite({\n        data: thisFilePath\n      });\n    } // Post-processing\n\n\n    if (this.onAfterSave) {\n      return this.onAfterSave({\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts\n      });\n    }\n  }, this); // Some themes require a symlink structure. If so, create it.\n\n  createSymLinks(curFmt, outFolder);\n  return genInfo;\n}\n/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */",
      "after": "/** Generate a resume using file-based inputs and outputs. Requires access\nto the local filesystem.\n@method generate\n@param rez A FreshResume object.\n@param f Full path to the output resume file to generate.\n@param opts Generator options. */\nasync generate(rez, f, opts) {\n  // Prepare\n  this.opts = EXTEND(true, {}, _defaultOpts, opts); // Call the string-based generation method\n\n  const genInfo = await this.invoke(rez, null);\n  const outFolder = parsePath(f).dirname;\n  const curFmt = opts.themeObj.getFormat(this.format); // Process individual files within this format. For example, the HTML\n  // output format for a theme may have multiple HTML files, CSS files,\n  // etc. Process them here.\n\n  genInfo.files.forEach(function (file) {\n    // console.dir _.omit(file.info,'cssData','data','css' )\n    // Pre-processing\n    file.info.orgPath = file.info.orgPath || '';\n    const thisFilePath = file.info.primary ? f : PATH.join(outFolder, file.info.orgPath);\n\n    if (file.info.action !== 'copy' && this.onBeforeSave) {\n      file.data = this.onBeforeSave({\n        theme: opts.themeObj,\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts,\n        ext: file.info.ext\n      });\n\n      if (!file.data) {\n        return;\n      }\n    } // Write the file\n\n\n    if (typeof opts.beforeWrite === 'function') {\n      opts.beforeWrite({\n        data: thisFilePath\n      });\n    }\n\n    MKDIRP.sync(PATH.dirname(thisFilePath));\n\n    if (file.info.action !== 'copy') {\n      FS.writeFileSync(thisFilePath, file.data, {\n        encoding: 'utf8',\n        flags: 'w'\n      });\n    } else {\n      FS.copySync(file.info.path, thisFilePath);\n    }\n\n    if (typeof opts.afterWrite === 'function') {\n      opts.afterWrite({\n        data: thisFilePath\n      });\n    } // Post-processing\n\n\n    if (this.onAfterSave) {\n      return this.onAfterSave({\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts\n      });\n    }\n  }, this); // Some themes require a symlink structure. If so, create it.\n\n  createSymLinks(curFmt, outFolder);\n  return genInfo;\n}\n/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 63,
      "endLine": 63,
      "before": "function () {\n  // Set up options\n  var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n  var opts = {\n    theme: themeLoc,\n    format: fmt,\n    prettify: true,\n    silent: false,\n    css: 'embed',\n    debug: true\n  }; // Run the command!\n\n  var v = new HackMyResume.verbs.build();\n  v.on('hmr:error', function (ex) {\n    console.error('Error thrown: %o', ex);\n    throw ex; //assert(false);\n  });\n  var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n  return p.then(function (obj) {} //,function(obj) { },\n  );\n}",
      "after": "async function () {\n  // Set up options\n  var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n  var opts = {\n    theme: themeLoc,\n    format: fmt,\n    prettify: true,\n    silent: false,\n    css: 'embed',\n    debug: true\n  }; // Run the command!\n\n  var v = new HackMyResume.verbs.build();\n  v.on('hmr:error', function (ex) {\n    console.error('Error thrown: %o', ex);\n    throw ex; //assert(false);\n  });\n  var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n  return p.then(function (obj) {} //,function(obj) { },\n  );\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 76,
      "endLine": 76,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 119,
      "endLine": 123,
      "before": "genThemes('jane-q-fullstacker', ['node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json'], 'FRESH')",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait genThemes('jane-q-fullstacker', ['node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json'], 'FRESH')"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 125,
      "endLine": 129,
      "before": "genThemes('johnny-trouble', ['node_modules/fresh-test-resumes/src/fresh/johnny-trouble.json'], 'FRESH')",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait genThemes('johnny-trouble', ['node_modules/fresh-test-resumes/src/fresh/johnny-trouble.json'], 'FRESH')"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 131,
      "endLine": 135,
      "before": "genThemes('richard-hendriks', ['node_modules/fresh-test-resumes/src/jrs/richard-hendriks.json'], 'JRS')",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait genThemes('richard-hendriks', ['node_modules/fresh-test-resumes/src/jrs/richard-hendriks.json'], 'JRS')"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 77,
      "endLine": 77,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 78,
      "endLine": 78,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 79,
      "endLine": 79,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 80,
      "endLine": 80,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 82,
      "endLine": 83,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 84,
      "endLine": 85,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 86,
      "endLine": 87,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 88,
      "endLine": 89,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-verbs.js",
      "startLine": 196,
      "endLine": 196,
      "before": "function (done) {\n  var v = new FCMD.verbs[verb]();\n  v.on('hmr:error', function (ex) {\n    assert(false);\n  });\n  var prom = v.invoke(src, dst, opts);\n  var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n  if (fnTest) {\n    prom.should.be[fulfillMethod].then(function (obj) {\n      fnTest(obj.sheet);\n    }).should.notify(done);\n  } else {\n    prom.should.be[fulfillMethod].notify(done);\n  }\n}",
      "after": "async function (done) {\n  var v = new FCMD.verbs[verb]();\n  v.on('hmr:error', function (ex) {\n    assert(false);\n  });\n  var prom = await v.invoke(src, dst, opts);\n  var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n  if (fnTest) {\n    prom.should.be[fulfillMethod].then(function (obj) {\n      fnTest(obj.sheet);\n    }).should.notify(done);\n  } else {\n    prom.should.be[fulfillMethod].notify(done);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-verbs.js",
      "startLine": 213,
      "endLine": 213,
      "before": "function (a) {\n  run.apply(\n  /* The players of */\n  null, a);\n}",
      "after": "async function (a) {\n  await run.apply(\n  /* The players of */\n  null, a);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-dates.js",
      "startLine": 81,
      "endLine": 91,
      "before": "function () {\n  tests.forEach(function (t) {\n    it(JSON.stringify(_.initial(t)), function () {\n      r.employment.history = _.initial(t);\n      var rObj = new FRESHResume();\n      rObj.parseJSON(r);\n      var dur = rObj.duration();\n      expect(dur).to.equal(_.last(t).val);\n    });\n  });\n}",
      "after": "async function () {\n  await tests.forEach(function (t) {\n    it(JSON.stringify(_.initial(t)), function () {\n      r.employment.history = _.initial(t);\n      var rObj = new FRESHResume();\n      rObj.parseJSON(r);\n      var dur = rObj.duration();\n      expect(dur).to.equal(_.last(t).val);\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-verbs.js",
      "startLine": 212,
      "endLine": 214,
      "before": "function () {\n  this.timeout(5000);\n\n  function run(verb, src, dst, opts, msg, fnTest) {\n    msg = msg || '.';\n    var shouldSucceed = true;\n\n    if (verb[0] === '!') {\n      verb = verb.substr(1);\n      shouldSucceed = false;\n    }\n\n    it('The ' + verb.toUpperCase() + ' command should ' + (shouldSucceed ? ' SUCCEED' : ' FAIL') + msg, function (done) {\n      var v = new FCMD.verbs[verb]();\n      v.on('hmr:error', function (ex) {\n        assert(false);\n      });\n      var prom = v.invoke(src, dst, opts);\n      var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n      if (fnTest) {\n        prom.should.be[fulfillMethod].then(function (obj) {\n          fnTest(obj.sheet);\n        }).should.notify(done);\n      } else {\n        prom.should.be[fulfillMethod].notify(done);\n      }\n    });\n  }\n\n  tests.forEach(function (a) {\n    run.apply(\n    /* The players of */\n    null, a);\n  });\n}",
      "after": "async function () {\n  this.timeout(5000);\n\n  function run(verb, src, dst, opts, msg, fnTest) {\n    msg = msg || '.';\n    var shouldSucceed = true;\n\n    if (verb[0] === '!') {\n      verb = verb.substr(1);\n      shouldSucceed = false;\n    }\n\n    it('The ' + verb.toUpperCase() + ' command should ' + (shouldSucceed ? ' SUCCEED' : ' FAIL') + msg, async function (done) {\n      var v = new FCMD.verbs[verb]();\n      v.on('hmr:error', function (ex) {\n        assert(false);\n      });\n      var prom = await v.invoke(src, dst, opts);\n      var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n      if (fnTest) {\n        prom.should.be[fulfillMethod].then(function (obj) {\n          fnTest(obj.sheet);\n        }).should.notify(done);\n      } else {\n        prom.should.be[fulfillMethod].notify(done);\n      }\n    });\n  }\n\n  await tests.forEach(async function (a) {\n    await run.apply(\n    /* The players of */\n    null, a);\n  });\n}"
    }
  ],
  "6": [
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/json-yaml-generator.js",
      "startLine": 36,
      "endLine": 36,
      "before": "generate(rez, f\n/*, opts */\n) {\n  const data = YAML.stringify(JSON.parse(rez.stringify()), Infinity, 2);\n  FS.writeFileSync(f, data, 'utf8');\n  return data;\n}",
      "after": "async generate(rez, f\n/*, opts */\n) {\n  const data = YAML.stringify(JSON.parse(rez.stringify()), Infinity, 2);\n  await FS.promises.writeFile(f, data, 'utf8');\n  return data;\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/template-generator.js",
      "startLine": 180,
      "endLine": 180,
      "before": "/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */\ntransform(json, jst, format, opts, theme, curFmt) {\n  if (this.opts.freezeBreaks) {\n    jst = freeze(jst);\n  }\n\n  const eng = require(`../renderers/${theme.engine}-generator`);\n\n  let result = eng.generate(json, jst, format, curFmt, opts, theme);\n\n  if (this.opts.freezeBreaks) {\n    result = unfreeze(result);\n  }\n\n  return result;\n}",
      "after": "/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */\nasync transform(json, jst, format, opts, theme, curFmt) {\n  if (this.opts.freezeBreaks) {\n    jst = freeze(jst);\n  }\n\n  const eng = require(`../renderers/${theme.engine}-generator`);\n\n  let result = await eng.generate(json, jst, format, curFmt, opts, theme);\n\n  if (this.opts.freezeBreaks) {\n    result = unfreeze(result);\n  }\n\n  return result;\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/template-generator.js",
      "startLine": 71,
      "endLine": 71,
      "before": "function (tplInfo, idx) {\n  let trx;\n\n  if (tplInfo.action === 'transform') {\n    trx = this.transform(rez, tplInfo.data, this.format, opts, opts.themeObj, curFmt);\n\n    if (tplInfo.ext === 'css') {\n      curFmt.files[idx].data = trx;\n    } else {\n      tplInfo.ext === 'html';\n    }\n  } //tplInfo.css contains the CSS data loaded by theme\n  //tplInfo.cssPath contains the absolute path to the source CSS File\n  //else {}\n  // Images and non-transformable binary files\n\n\n  if (typeof opts.onTransform === 'function') {\n    opts.onTransform(tplInfo);\n  }\n\n  return {\n    info: tplInfo,\n    data: trx\n  };\n}",
      "after": "async function (tplInfo, idx) {\n  let trx;\n\n  if (tplInfo.action === 'transform') {\n    trx = await this.transform(rez, tplInfo.data, this.format, opts, opts.themeObj, curFmt);\n\n    if (tplInfo.ext === 'css') {\n      curFmt.files[idx].data = trx;\n    } else {\n      tplInfo.ext === 'html';\n    }\n  } //tplInfo.css contains the CSS data loaded by theme\n  //tplInfo.cssPath contains the absolute path to the source CSS File\n  //else {}\n  // Images and non-transformable binary files\n\n\n  if (typeof opts.onTransform === 'function') {\n    opts.onTransform(tplInfo);\n  }\n\n  return {\n    info: tplInfo,\n    data: trx\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/json-generator.js",
      "startLine": 29,
      "endLine": 29,
      "before": "//altRez.stringify()\ngenerate(rez, f) {\n  FS.writeFileSync(f, this.invoke(rez), 'utf8');\n}",
      "after": "//altRez.stringify()\nasync generate(rez, f) {\n  await FS.promises.writeFile(f, await this.invoke(rez), 'utf8');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/template-generator.js",
      "startLine": 105,
      "endLine": 105,
      "before": "/** Generate a resume using file-based inputs and outputs. Requires access\nto the local filesystem.\n@method generate\n@param rez A FreshResume object.\n@param f Full path to the output resume file to generate.\n@param opts Generator options. */\ngenerate(rez, f, opts) {\n  // Prepare\n  this.opts = EXTEND(true, {}, _defaultOpts, opts); // Call the string-based generation method\n\n  const genInfo = this.invoke(rez, null);\n  const outFolder = parsePath(f).dirname;\n  const curFmt = opts.themeObj.getFormat(this.format); // Process individual files within this format. For example, the HTML\n  // output format for a theme may have multiple HTML files, CSS files,\n  // etc. Process them here.\n\n  genInfo.files.forEach(function (file) {\n    // console.dir _.omit(file.info,'cssData','data','css' )\n    // Pre-processing\n    file.info.orgPath = file.info.orgPath || '';\n    const thisFilePath = file.info.primary ? f : PATH.join(outFolder, file.info.orgPath);\n\n    if (file.info.action !== 'copy' && this.onBeforeSave) {\n      file.data = this.onBeforeSave({\n        theme: opts.themeObj,\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts,\n        ext: file.info.ext\n      });\n\n      if (!file.data) {\n        return;\n      }\n    } // Write the file\n\n\n    if (typeof opts.beforeWrite === 'function') {\n      opts.beforeWrite({\n        data: thisFilePath\n      });\n    }\n\n    MKDIRP.sync(PATH.dirname(thisFilePath));\n\n    if (file.info.action !== 'copy') {\n      FS.writeFileSync(thisFilePath, file.data, {\n        encoding: 'utf8',\n        flags: 'w'\n      });\n    } else {\n      FS.copySync(file.info.path, thisFilePath);\n    }\n\n    if (typeof opts.afterWrite === 'function') {\n      opts.afterWrite({\n        data: thisFilePath\n      });\n    } // Post-processing\n\n\n    if (this.onAfterSave) {\n      return this.onAfterSave({\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts\n      });\n    }\n  }, this); // Some themes require a symlink structure. If so, create it.\n\n  createSymLinks(curFmt, outFolder);\n  return genInfo;\n}\n/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */",
      "after": "/** Generate a resume using file-based inputs and outputs. Requires access\nto the local filesystem.\n@method generate\n@param rez A FreshResume object.\n@param f Full path to the output resume file to generate.\n@param opts Generator options. */\nasync generate(rez, f, opts) {\n  // Prepare\n  this.opts = EXTEND(true, {}, _defaultOpts, opts); // Call the string-based generation method\n\n  const genInfo = await this.invoke(rez, null);\n  const outFolder = parsePath(f).dirname;\n  const curFmt = opts.themeObj.getFormat(this.format); // Process individual files within this format. For example, the HTML\n  // output format for a theme may have multiple HTML files, CSS files,\n  // etc. Process them here.\n\n  genInfo.files.forEach(function (file) {\n    // console.dir _.omit(file.info,'cssData','data','css' )\n    // Pre-processing\n    file.info.orgPath = file.info.orgPath || '';\n    const thisFilePath = file.info.primary ? f : PATH.join(outFolder, file.info.orgPath);\n\n    if (file.info.action !== 'copy' && this.onBeforeSave) {\n      file.data = this.onBeforeSave({\n        theme: opts.themeObj,\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts,\n        ext: file.info.ext\n      });\n\n      if (!file.data) {\n        return;\n      }\n    } // Write the file\n\n\n    if (typeof opts.beforeWrite === 'function') {\n      opts.beforeWrite({\n        data: thisFilePath\n      });\n    }\n\n    MKDIRP.sync(PATH.dirname(thisFilePath));\n\n    if (file.info.action !== 'copy') {\n      FS.writeFileSync(thisFilePath, file.data, {\n        encoding: 'utf8',\n        flags: 'w'\n      });\n    } else {\n      FS.copySync(file.info.path, thisFilePath);\n    }\n\n    if (typeof opts.afterWrite === 'function') {\n      opts.afterWrite({\n        data: thisFilePath\n      });\n    } // Post-processing\n\n\n    if (this.onAfterSave) {\n      return this.onAfterSave({\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts\n      });\n    }\n  }, this); // Some themes require a symlink structure. If so, create it.\n\n  createSymLinks(curFmt, outFolder);\n  return genInfo;\n}\n/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 63,
      "endLine": 63,
      "before": "function () {\n  // Set up options\n  var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n  var opts = {\n    theme: themeLoc,\n    format: fmt,\n    prettify: true,\n    silent: false,\n    css: 'embed',\n    debug: true\n  }; // Run the command!\n\n  var v = new HackMyResume.verbs.build();\n  v.on('hmr:error', function (ex) {\n    console.error('Error thrown: %o', ex);\n    throw ex; //assert(false);\n  });\n  var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n  return p.then(function (obj) {} //,function(obj) { },\n  );\n}",
      "after": "async function () {\n  // Set up options\n  var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n  var opts = {\n    theme: themeLoc,\n    format: fmt,\n    prettify: true,\n    silent: false,\n    css: 'embed',\n    debug: true\n  }; // Run the command!\n\n  var v = new HackMyResume.verbs.build();\n  v.on('hmr:error', function (ex) {\n    console.error('Error thrown: %o', ex);\n    throw ex; //assert(false);\n  });\n  var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n  return p.then(function (obj) {} //,function(obj) { },\n  );\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 76,
      "endLine": 76,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 119,
      "endLine": 123,
      "before": "genThemes('jane-q-fullstacker', ['node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json'], 'FRESH')",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait genThemes('jane-q-fullstacker', ['node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json'], 'FRESH')"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 125,
      "endLine": 129,
      "before": "genThemes('johnny-trouble', ['node_modules/fresh-test-resumes/src/fresh/johnny-trouble.json'], 'FRESH')",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait genThemes('johnny-trouble', ['node_modules/fresh-test-resumes/src/fresh/johnny-trouble.json'], 'FRESH')"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 131,
      "endLine": 135,
      "before": "genThemes('richard-hendriks', ['node_modules/fresh-test-resumes/src/jrs/richard-hendriks.json'], 'JRS')",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait genThemes('richard-hendriks', ['node_modules/fresh-test-resumes/src/jrs/richard-hendriks.json'], 'JRS')"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 77,
      "endLine": 77,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 78,
      "endLine": 78,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 79,
      "endLine": 79,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 80,
      "endLine": 80,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 82,
      "endLine": 83,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 84,
      "endLine": 85,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 86,
      "endLine": 87,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 88,
      "endLine": 89,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-verbs.js",
      "startLine": 196,
      "endLine": 196,
      "before": "function (done) {\n  var v = new FCMD.verbs[verb]();\n  v.on('hmr:error', function (ex) {\n    assert(false);\n  });\n  var prom = v.invoke(src, dst, opts);\n  var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n  if (fnTest) {\n    prom.should.be[fulfillMethod].then(function (obj) {\n      fnTest(obj.sheet);\n    }).should.notify(done);\n  } else {\n    prom.should.be[fulfillMethod].notify(done);\n  }\n}",
      "after": "async function (done) {\n  var v = new FCMD.verbs[verb]();\n  v.on('hmr:error', function (ex) {\n    assert(false);\n  });\n  var prom = await v.invoke(src, dst, opts);\n  var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n  if (fnTest) {\n    prom.should.be[fulfillMethod].then(function (obj) {\n      fnTest(obj.sheet);\n    }).should.notify(done);\n  } else {\n    prom.should.be[fulfillMethod].notify(done);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-verbs.js",
      "startLine": 213,
      "endLine": 213,
      "before": "function (a) {\n  run.apply(\n  /* The players of */\n  null, a);\n}",
      "after": "async function (a) {\n  await run.apply(\n  /* The players of */\n  null, a);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-verbs.js",
      "startLine": 212,
      "endLine": 214,
      "before": "function () {\n  this.timeout(5000);\n\n  function run(verb, src, dst, opts, msg, fnTest) {\n    msg = msg || '.';\n    var shouldSucceed = true;\n\n    if (verb[0] === '!') {\n      verb = verb.substr(1);\n      shouldSucceed = false;\n    }\n\n    it('The ' + verb.toUpperCase() + ' command should ' + (shouldSucceed ? ' SUCCEED' : ' FAIL') + msg, function (done) {\n      var v = new FCMD.verbs[verb]();\n      v.on('hmr:error', function (ex) {\n        assert(false);\n      });\n      var prom = v.invoke(src, dst, opts);\n      var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n      if (fnTest) {\n        prom.should.be[fulfillMethod].then(function (obj) {\n          fnTest(obj.sheet);\n        }).should.notify(done);\n      } else {\n        prom.should.be[fulfillMethod].notify(done);\n      }\n    });\n  }\n\n  tests.forEach(function (a) {\n    run.apply(\n    /* The players of */\n    null, a);\n  });\n}",
      "after": "async function () {\n  this.timeout(5000);\n\n  function run(verb, src, dst, opts, msg, fnTest) {\n    msg = msg || '.';\n    var shouldSucceed = true;\n\n    if (verb[0] === '!') {\n      verb = verb.substr(1);\n      shouldSucceed = false;\n    }\n\n    it('The ' + verb.toUpperCase() + ' command should ' + (shouldSucceed ? ' SUCCEED' : ' FAIL') + msg, async function (done) {\n      var v = new FCMD.verbs[verb]();\n      v.on('hmr:error', function (ex) {\n        assert(false);\n      });\n      var prom = await v.invoke(src, dst, opts);\n      var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n      if (fnTest) {\n        prom.should.be[fulfillMethod].then(function (obj) {\n          fnTest(obj.sheet);\n        }).should.notify(done);\n      } else {\n        prom.should.be[fulfillMethod].notify(done);\n      }\n    });\n  }\n\n  await tests.forEach(async function (a) {\n    await run.apply(\n    /* The players of */\n    null, a);\n  });\n}"
    }
  ],
  "7": [
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/template-generator.js",
      "startLine": 143,
      "endLine": 143,
      "before": "function (file) {\n  // console.dir _.omit(file.info,'cssData','data','css' )\n  // Pre-processing\n  file.info.orgPath = file.info.orgPath || '';\n  const thisFilePath = file.info.primary ? f : PATH.join(outFolder, file.info.orgPath);\n\n  if (file.info.action !== 'copy' && this.onBeforeSave) {\n    file.data = this.onBeforeSave({\n      theme: opts.themeObj,\n      outputFile: thisFilePath,\n      mk: file.data,\n      opts: this.opts,\n      ext: file.info.ext\n    });\n\n    if (!file.data) {\n      return;\n    }\n  } // Write the file\n\n\n  if (typeof opts.beforeWrite === 'function') {\n    opts.beforeWrite({\n      data: thisFilePath\n    });\n  }\n\n  MKDIRP.sync(PATH.dirname(thisFilePath));\n\n  if (file.info.action !== 'copy') {\n    FS.writeFileSync(thisFilePath, file.data, {\n      encoding: 'utf8',\n      flags: 'w'\n    });\n  } else {\n    FS.copySync(file.info.path, thisFilePath);\n  }\n\n  if (typeof opts.afterWrite === 'function') {\n    opts.afterWrite({\n      data: thisFilePath\n    });\n  } // Post-processing\n\n\n  if (this.onAfterSave) {\n    return this.onAfterSave({\n      outputFile: thisFilePath,\n      mk: file.data,\n      opts: this.opts\n    });\n  }\n}",
      "after": "async function (file) {\n  // console.dir _.omit(file.info,'cssData','data','css' )\n  // Pre-processing\n  file.info.orgPath = file.info.orgPath || '';\n  const thisFilePath = file.info.primary ? f : PATH.join(outFolder, file.info.orgPath);\n\n  if (file.info.action !== 'copy' && this.onBeforeSave) {\n    file.data = this.onBeforeSave({\n      theme: opts.themeObj,\n      outputFile: thisFilePath,\n      mk: file.data,\n      opts: this.opts,\n      ext: file.info.ext\n    });\n\n    if (!file.data) {\n      return;\n    }\n  } // Write the file\n\n\n  if (typeof opts.beforeWrite === 'function') {\n    opts.beforeWrite({\n      data: thisFilePath\n    });\n  }\n\n  MKDIRP.sync(PATH.dirname(thisFilePath));\n\n  if (file.info.action !== 'copy') {\n    await FS.promises.writeFile(thisFilePath, file.data, {\n      encoding: 'utf8',\n      flags: 'w'\n    });\n  } else {\n    FS.copySync(file.info.path, thisFilePath);\n  }\n\n  if (typeof opts.afterWrite === 'function') {\n    opts.afterWrite({\n      data: thisFilePath\n    });\n  } // Post-processing\n\n\n  if (this.onAfterSave) {\n    return this.onAfterSave({\n      outputFile: thisFilePath,\n      mk: file.data,\n      opts: this.opts\n    });\n  }\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/template-generator.js",
      "startLine": 180,
      "endLine": 180,
      "before": "/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */\ntransform(json, jst, format, opts, theme, curFmt) {\n  if (this.opts.freezeBreaks) {\n    jst = freeze(jst);\n  }\n\n  const eng = require(`../renderers/${theme.engine}-generator`);\n\n  let result = eng.generate(json, jst, format, curFmt, opts, theme);\n\n  if (this.opts.freezeBreaks) {\n    result = unfreeze(result);\n  }\n\n  return result;\n}",
      "after": "/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */\nasync transform(json, jst, format, opts, theme, curFmt) {\n  if (this.opts.freezeBreaks) {\n    jst = freeze(jst);\n  }\n\n  const eng = require(`../renderers/${theme.engine}-generator`);\n\n  let result = await eng.generate(json, jst, format, curFmt, opts, theme);\n\n  if (this.opts.freezeBreaks) {\n    result = unfreeze(result);\n  }\n\n  return result;\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/template-generator.js",
      "startLine": 71,
      "endLine": 71,
      "before": "function (tplInfo, idx) {\n  let trx;\n\n  if (tplInfo.action === 'transform') {\n    trx = this.transform(rez, tplInfo.data, this.format, opts, opts.themeObj, curFmt);\n\n    if (tplInfo.ext === 'css') {\n      curFmt.files[idx].data = trx;\n    } else {\n      tplInfo.ext === 'html';\n    }\n  } //tplInfo.css contains the CSS data loaded by theme\n  //tplInfo.cssPath contains the absolute path to the source CSS File\n  //else {}\n  // Images and non-transformable binary files\n\n\n  if (typeof opts.onTransform === 'function') {\n    opts.onTransform(tplInfo);\n  }\n\n  return {\n    info: tplInfo,\n    data: trx\n  };\n}",
      "after": "async function (tplInfo, idx) {\n  let trx;\n\n  if (tplInfo.action === 'transform') {\n    trx = await this.transform(rez, tplInfo.data, this.format, opts, opts.themeObj, curFmt);\n\n    if (tplInfo.ext === 'css') {\n      curFmt.files[idx].data = trx;\n    } else {\n      tplInfo.ext === 'html';\n    }\n  } //tplInfo.css contains the CSS data loaded by theme\n  //tplInfo.cssPath contains the absolute path to the source CSS File\n  //else {}\n  // Images and non-transformable binary files\n\n\n  if (typeof opts.onTransform === 'function') {\n    opts.onTransform(tplInfo);\n  }\n\n  return {\n    info: tplInfo,\n    data: trx\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/json-generator.js",
      "startLine": 29,
      "endLine": 29,
      "before": "//altRez.stringify()\ngenerate(rez, f) {\n  FS.writeFileSync(f, this.invoke(rez), 'utf8');\n}",
      "after": "//altRez.stringify()\nasync generate(rez, f) {\n  await FS.promises.writeFile(f, await this.invoke(rez), 'utf8');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/generators/template-generator.js",
      "startLine": 105,
      "endLine": 105,
      "before": "/** Generate a resume using file-based inputs and outputs. Requires access\nto the local filesystem.\n@method generate\n@param rez A FreshResume object.\n@param f Full path to the output resume file to generate.\n@param opts Generator options. */\ngenerate(rez, f, opts) {\n  // Prepare\n  this.opts = EXTEND(true, {}, _defaultOpts, opts); // Call the string-based generation method\n\n  const genInfo = this.invoke(rez, null);\n  const outFolder = parsePath(f).dirname;\n  const curFmt = opts.themeObj.getFormat(this.format); // Process individual files within this format. For example, the HTML\n  // output format for a theme may have multiple HTML files, CSS files,\n  // etc. Process them here.\n\n  genInfo.files.forEach(function (file) {\n    // console.dir _.omit(file.info,'cssData','data','css' )\n    // Pre-processing\n    file.info.orgPath = file.info.orgPath || '';\n    const thisFilePath = file.info.primary ? f : PATH.join(outFolder, file.info.orgPath);\n\n    if (file.info.action !== 'copy' && this.onBeforeSave) {\n      file.data = this.onBeforeSave({\n        theme: opts.themeObj,\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts,\n        ext: file.info.ext\n      });\n\n      if (!file.data) {\n        return;\n      }\n    } // Write the file\n\n\n    if (typeof opts.beforeWrite === 'function') {\n      opts.beforeWrite({\n        data: thisFilePath\n      });\n    }\n\n    MKDIRP.sync(PATH.dirname(thisFilePath));\n\n    if (file.info.action !== 'copy') {\n      FS.writeFileSync(thisFilePath, file.data, {\n        encoding: 'utf8',\n        flags: 'w'\n      });\n    } else {\n      FS.copySync(file.info.path, thisFilePath);\n    }\n\n    if (typeof opts.afterWrite === 'function') {\n      opts.afterWrite({\n        data: thisFilePath\n      });\n    } // Post-processing\n\n\n    if (this.onAfterSave) {\n      return this.onAfterSave({\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts\n      });\n    }\n  }, this); // Some themes require a symlink structure. If so, create it.\n\n  createSymLinks(curFmt, outFolder);\n  return genInfo;\n}\n/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */",
      "after": "/** Generate a resume using file-based inputs and outputs. Requires access\nto the local filesystem.\n@method generate\n@param rez A FreshResume object.\n@param f Full path to the output resume file to generate.\n@param opts Generator options. */\nasync generate(rez, f, opts) {\n  // Prepare\n  this.opts = EXTEND(true, {}, _defaultOpts, opts); // Call the string-based generation method\n\n  const genInfo = await this.invoke(rez, null);\n  const outFolder = parsePath(f).dirname;\n  const curFmt = opts.themeObj.getFormat(this.format); // Process individual files within this format. For example, the HTML\n  // output format for a theme may have multiple HTML files, CSS files,\n  // etc. Process them here.\n\n  genInfo.files.forEach(async function (file) {\n    // console.dir _.omit(file.info,'cssData','data','css' )\n    // Pre-processing\n    file.info.orgPath = file.info.orgPath || '';\n    const thisFilePath = file.info.primary ? f : PATH.join(outFolder, file.info.orgPath);\n\n    if (file.info.action !== 'copy' && this.onBeforeSave) {\n      file.data = this.onBeforeSave({\n        theme: opts.themeObj,\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts,\n        ext: file.info.ext\n      });\n\n      if (!file.data) {\n        return;\n      }\n    } // Write the file\n\n\n    if (typeof opts.beforeWrite === 'function') {\n      opts.beforeWrite({\n        data: thisFilePath\n      });\n    }\n\n    MKDIRP.sync(PATH.dirname(thisFilePath));\n\n    if (file.info.action !== 'copy') {\n      await FS.promises.writeFile(thisFilePath, file.data, {\n        encoding: 'utf8',\n        flags: 'w'\n      });\n    } else {\n      FS.copySync(file.info.path, thisFilePath);\n    }\n\n    if (typeof opts.afterWrite === 'function') {\n      opts.afterWrite({\n        data: thisFilePath\n      });\n    } // Post-processing\n\n\n    if (this.onAfterSave) {\n      return this.onAfterSave({\n        outputFile: thisFilePath,\n        mk: file.data,\n        opts: this.opts\n      });\n    }\n  }, this); // Some themes require a symlink structure. If so, create it.\n\n  createSymLinks(curFmt, outFolder);\n  return genInfo;\n}\n/** Perform a single resume resume transformation using string-based inputs\nand outputs without touching the local file system.\n@param json A FRESH or JRS resume object.\n@param jst The stringified template data\n@param format The format name, such as \"html\" or \"latex\"\n@param cssInfo Needs to be refactored.\n@param opts Options and passthrough data. */"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 63,
      "endLine": 63,
      "before": "function () {\n  // Set up options\n  var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n  var opts = {\n    theme: themeLoc,\n    format: fmt,\n    prettify: true,\n    silent: false,\n    css: 'embed',\n    debug: true\n  }; // Run the command!\n\n  var v = new HackMyResume.verbs.build();\n  v.on('hmr:error', function (ex) {\n    console.error('Error thrown: %o', ex);\n    throw ex; //assert(false);\n  });\n  var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n  return p.then(function (obj) {} //,function(obj) { },\n  );\n}",
      "after": "async function () {\n  // Set up options\n  var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n  var opts = {\n    theme: themeLoc,\n    format: fmt,\n    prettify: true,\n    silent: false,\n    css: 'embed',\n    debug: true\n  }; // Run the command!\n\n  var v = new HackMyResume.verbs.build();\n  v.on('hmr:error', function (ex) {\n    console.error('Error thrown: %o', ex);\n    throw ex; //assert(false);\n  });\n  var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n  return p.then(function (obj) {} //,function(obj) { },\n  );\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 76,
      "endLine": 76,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 119,
      "endLine": 123,
      "before": "genThemes('jane-q-fullstacker', ['node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json'], 'FRESH')",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait genThemes('jane-q-fullstacker', ['node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json'], 'FRESH')"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 125,
      "endLine": 129,
      "before": "genThemes('johnny-trouble', ['node_modules/fresh-test-resumes/src/fresh/johnny-trouble.json'], 'FRESH')",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait genThemes('johnny-trouble', ['node_modules/fresh-test-resumes/src/fresh/johnny-trouble.json'], 'FRESH')"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 131,
      "endLine": 135,
      "before": "genThemes('richard-hendriks', ['node_modules/fresh-test-resumes/src/jrs/richard-hendriks.json'], 'JRS')",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait genThemes('richard-hendriks', ['node_modules/fresh-test-resumes/src/jrs/richard-hendriks.json'], 'JRS')"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 77,
      "endLine": 77,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 78,
      "endLine": 78,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 79,
      "endLine": 79,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 80,
      "endLine": 80,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 82,
      "endLine": 83,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 84,
      "endLine": 85,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 86,
      "endLine": 87,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-themes.js",
      "startLine": 88,
      "endLine": 89,
      "before": "function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  genTheme(fmt, src, 'compact');\n  genTheme(fmt, src, 'modern');\n  genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  genTheme(fmt, src, 'awesome');\n  genTheme(fmt, src, 'positive');\n  genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}",
      "after": "async function () {\n  // Increase the timeout since resume generation can be expensive..\n  this.timeout(50000); // Define a local function to build a single resume to MULTIPLE themes\n\n  function genTheme(fmt, src, themeName, themeLoc, testTitle) {\n    themeLoc = themeLoc || themeName;\n    testTitle = themeName.toUpperCase() + ' theme (' + fmt + ') should generate without throwing an exception'; // Instantiate a test case\n\n    it(testTitle, async function () {\n      // Set up options\n      var dst = ['test/sandbox/' + fmt + '/' + title + '/' + themeName + '/resume.all'];\n      var opts = {\n        theme: themeLoc,\n        format: fmt,\n        prettify: true,\n        silent: false,\n        css: 'embed',\n        debug: true\n      }; // Run the command!\n\n      var v = new HackMyResume.verbs.build();\n      v.on('hmr:error', function (ex) {\n        console.error('Error thrown: %o', ex);\n        throw ex; //assert(false);\n      });\n      var p = await v.invoke(src, dst, opts); // Let Mocha sort out the promise result\n\n      return p.then(function (obj) {} //,function(obj) { },\n      );\n    });\n  } // Build the resume for each theme\n  //genTheme(fmt, src, 'hello-world');\n\n\n  await genTheme(fmt, src, 'compact');\n  await genTheme(fmt, src, 'modern');\n  await genTheme(fmt, src, 'underscore', 'node_modules/fresh-theme-underscore');\n  await genTheme(fmt, src, 'awesome');\n  await genTheme(fmt, src, 'positive');\n  await genTheme(fmt, src, 'jsonresume-theme-boilerplate', 'node_modules/jsonresume-theme-boilerplate');\n  await genTheme(fmt, src, 'jsonresume-theme-sceptile', 'node_modules/jsonresume-theme-sceptile');\n  await genTheme(fmt, src, 'jsonresume-theme-modern', 'node_modules/jsonresume-theme-modern');\n  await genTheme(fmt, src, 'jsonresume-theme-classy', 'node_modules/jsonresume-theme-classy');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-verbs.js",
      "startLine": 196,
      "endLine": 196,
      "before": "function (done) {\n  var v = new FCMD.verbs[verb]();\n  v.on('hmr:error', function (ex) {\n    assert(false);\n  });\n  var prom = v.invoke(src, dst, opts);\n  var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n  if (fnTest) {\n    prom.should.be[fulfillMethod].then(function (obj) {\n      fnTest(obj.sheet);\n    }).should.notify(done);\n  } else {\n    prom.should.be[fulfillMethod].notify(done);\n  }\n}",
      "after": "async function (done) {\n  var v = new FCMD.verbs[verb]();\n  v.on('hmr:error', function (ex) {\n    assert(false);\n  });\n  var prom = await v.invoke(src, dst, opts);\n  var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n  if (fnTest) {\n    prom.should.be[fulfillMethod].then(function (obj) {\n      fnTest(obj.sheet);\n    }).should.notify(done);\n  } else {\n    prom.should.be[fulfillMethod].notify(done);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-verbs.js",
      "startLine": 213,
      "endLine": 213,
      "before": "function (a) {\n  run.apply(\n  /* The players of */\n  null, a);\n}",
      "after": "async function (a) {\n  await run.apply(\n  /* The players of */\n  null, a);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-verbs.js",
      "startLine": 212,
      "endLine": 214,
      "before": "function () {\n  this.timeout(5000);\n\n  function run(verb, src, dst, opts, msg, fnTest) {\n    msg = msg || '.';\n    var shouldSucceed = true;\n\n    if (verb[0] === '!') {\n      verb = verb.substr(1);\n      shouldSucceed = false;\n    }\n\n    it('The ' + verb.toUpperCase() + ' command should ' + (shouldSucceed ? ' SUCCEED' : ' FAIL') + msg, function (done) {\n      var v = new FCMD.verbs[verb]();\n      v.on('hmr:error', function (ex) {\n        assert(false);\n      });\n      var prom = v.invoke(src, dst, opts);\n      var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n      if (fnTest) {\n        prom.should.be[fulfillMethod].then(function (obj) {\n          fnTest(obj.sheet);\n        }).should.notify(done);\n      } else {\n        prom.should.be[fulfillMethod].notify(done);\n      }\n    });\n  }\n\n  tests.forEach(function (a) {\n    run.apply(\n    /* The players of */\n    null, a);\n  });\n}",
      "after": "async function () {\n  this.timeout(5000);\n\n  function run(verb, src, dst, opts, msg, fnTest) {\n    msg = msg || '.';\n    var shouldSucceed = true;\n\n    if (verb[0] === '!') {\n      verb = verb.substr(1);\n      shouldSucceed = false;\n    }\n\n    it('The ' + verb.toUpperCase() + ' command should ' + (shouldSucceed ? ' SUCCEED' : ' FAIL') + msg, async function (done) {\n      var v = new FCMD.verbs[verb]();\n      v.on('hmr:error', function (ex) {\n        assert(false);\n      });\n      var prom = await v.invoke(src, dst, opts);\n      var fulfillMethod = shouldSucceed ? 'fulfilled' : 'rejected';\n\n      if (fnTest) {\n        prom.should.be[fulfillMethod].then(function (obj) {\n          fnTest(obj.sheet);\n        }).should.notify(done);\n      } else {\n        prom.should.be[fulfillMethod].notify(done);\n      }\n    });\n  }\n\n  await tests.forEach(async function (a) {\n    await run.apply(\n    /* The players of */\n    null, a);\n  });\n}"
    }
  ],
  "8": [
    {
      "filename": "/home/osboxes/HackMyResume/src/utils/file-contains.js",
      "startLine": 11,
      "endLine": 11,
      "before": "(file, needle) => require('fs').readFileSync(file, 'utf-8').indexOf(needle) > -1",
      "after": "async (file, needle) => (await require('fs').promises.readFile(file, 'utf-8')).indexOf(needle) > -1"
    }
  ],
  "9": [
    {
      "filename": "/home/osboxes/HackMyResume/src/utils/safe-json-loader.js",
      "startLine": 18,
      "endLine": 18,
      "before": "function (file) {\n  const ret = {};\n\n  try {\n    ret.raw = FS.readFileSync(file, 'utf8');\n    ret.json = JSON.parse(ret.raw);\n  } catch (err) {\n    // If we get here, either FS.readFileSync or JSON.parse failed.\n    // We'll return HMSTATUS.readError or HMSTATUS.parseError.\n    const retRaw = ret.raw && ret.raw.trim();\n    ret.ex = {\n      op: retRaw ? 'parse' : 'read',\n      inner: SyntaxErrorEx.is(err) ? new SyntaxErrorEx(err, retRaw) : err,\n      file\n    };\n  }\n\n  return ret;\n}",
      "after": "async function (file) {\n  const ret = {};\n\n  try {\n    ret.raw = await FS.promises.readFile(file, 'utf8');\n    ret.json = JSON.parse(ret.raw);\n  } catch (err) {\n    // If we get here, either FS.readFileSync or JSON.parse failed.\n    // We'll return HMSTATUS.readError or HMSTATUS.parseError.\n    const retRaw = ret.raw && ret.raw.trim();\n    ret.ex = {\n      op: retRaw ? 'parse' : 'read',\n      inner: SyntaxErrorEx.is(err) ? new SyntaxErrorEx(err, retRaw) : err,\n      file\n    };\n  }\n\n  return ret;\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/main.js",
      "startLine": 258,
      "endLine": 258,
      "before": "function (ar) {\n  let oJSON, oVerb;\n  oVerb;\n  let verb = '';\n  const args = ar.slice();\n  const cleanArgs = args.slice(2);\n  oJSON;\n\n  if (cleanArgs.length) {\n    // Support case-insensitive sub-commands (build, generate, validate, etc)\n    const vidx = _.findIndex(cleanArgs, v => v[0] !== '-');\n\n    if (vidx !== -1) {\n      oVerb = cleanArgs[vidx];\n      verb = args[vidx + 2] = oVerb.trim().toLowerCase();\n    } // Remove --options --opts -o and process separately\n\n\n    const optsIdx = _.findIndex(cleanArgs, v => v === '-o' || v === '--options' || v === '--opts');\n\n    if (optsIdx !== -1) {\n      let optStr = cleanArgs[optsIdx + 1];\n      args.splice(optsIdx + 2, 2);\n\n      if (optStr && (optStr = optStr.trim())) {\n        //var myJSON = JSON.parse(optStr);\n        if (optStr[0] === '{') {\n          // TODO: remove use of evil(). - hacksalot\n\n          /* jshint ignore:start */\n          oJSON = eval(`(${optStr})`); // jshint ignore:line <-- no worky\n\n          /* jshint ignore:end */\n        } else {\n          const inf = safeLoadJSON(optStr);\n\n          if (!inf.ex) {\n            oJSON = inf.json;\n          } else {\n            return inf;\n          }\n        }\n      }\n    }\n  } // Grab the --debug flag, --silent, --assert and --no-color flags\n\n\n  const isDebug = _.some(args, v => v === '-d' || v === '--debug');\n\n  const isSilent = _.some(args, v => v === '-s' || v === '--silent');\n\n  const isAssert = _.some(args, v => v === '-a' || v === '--assert');\n\n  const isMono = _.some(args, v => v === '--no-color');\n\n  const isNoEscape = _.some(args, v => v === '--no-escape');\n\n  return {\n    color: !isMono,\n    debug: isDebug,\n    silent: isSilent,\n    assert: isAssert,\n    noescape: isNoEscape,\n    orgVerb: oVerb,\n    verb,\n    json: oJSON,\n    args\n  };\n}",
      "after": "async function (ar) {\n  let oJSON, oVerb;\n  oVerb;\n  let verb = '';\n  const args = ar.slice();\n  const cleanArgs = args.slice(2);\n  oJSON;\n\n  if (cleanArgs.length) {\n    // Support case-insensitive sub-commands (build, generate, validate, etc)\n    const vidx = _.findIndex(cleanArgs, v => v[0] !== '-');\n\n    if (vidx !== -1) {\n      oVerb = cleanArgs[vidx];\n      verb = args[vidx + 2] = oVerb.trim().toLowerCase();\n    } // Remove --options --opts -o and process separately\n\n\n    const optsIdx = _.findIndex(cleanArgs, v => v === '-o' || v === '--options' || v === '--opts');\n\n    if (optsIdx !== -1) {\n      let optStr = cleanArgs[optsIdx + 1];\n      args.splice(optsIdx + 2, 2);\n\n      if (optStr && (optStr = optStr.trim())) {\n        //var myJSON = JSON.parse(optStr);\n        if (optStr[0] === '{') {\n          // TODO: remove use of evil(). - hacksalot\n\n          /* jshint ignore:start */\n          oJSON = eval(`(${optStr})`); // jshint ignore:line <-- no worky\n\n          /* jshint ignore:end */\n        } else {\n          const inf = await safeLoadJSON(optStr);\n\n          if (!inf.ex) {\n            oJSON = inf.json;\n          } else {\n            return inf;\n          }\n        }\n      }\n    }\n  } // Grab the --debug flag, --silent, --assert and --no-color flags\n\n\n  const isDebug = _.some(args, v => v === '-d' || v === '--debug');\n\n  const isSilent = _.some(args, v => v === '-s' || v === '--silent');\n\n  const isAssert = _.some(args, v => v === '-a' || v === '--assert');\n\n  const isMono = _.some(args, v => v === '--no-color');\n\n  const isNoEscape = _.some(args, v => v === '--no-escape');\n\n  return {\n    color: !isMono,\n    debug: isDebug,\n    silent: isSilent,\n    assert: isAssert,\n    noescape: isNoEscape,\n    orgVerb: oVerb,\n    verb,\n    json: oJSON,\n    args\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/main.js",
      "startLine": 163,
      "endLine": 163,
      "before": "function (ar, exitCallback) {\n  _exitCallback = exitCallback || process.exit;\n  const o = initOptions(ar);\n\n  if (o.ex) {\n    _err.init(false, true, false);\n\n    if (o.ex.op === 'parse') {\n      _err.err({\n        fluenterror: o.ex.op === 'parse' ? HMSTATUS.invalidOptionsFile : HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    } else {\n      _err.err({\n        fluenterror: HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    }\n\n    return null;\n  }\n\n  o.silent || logMsg(_title); // Emit debug prelude if --debug was specified\n\n  if (o.debug) {\n    _out.log(chalk.cyan('The -d or --debug switch was specified. DEBUG mode engaged.'));\n\n    _out.log('');\n\n    _out.log(chalk.cyan(PAD('  Platform:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.platform === 'win32' ? 'windows' : process.platform));\n\n    _out.log(chalk.cyan(PAD('  Node.js:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.version));\n\n    _out.log(chalk.cyan(PAD('  HackMyResume:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(`v${PKG.version}`));\n\n    _out.log(chalk.cyan(PAD('  FRESCA:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(PKG.dependencies.fresca)); //_out.log(chalk.cyan(PAD('  fresh-themes:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-themes'] ))\n    //_out.log(chalk.cyan(PAD('  fresh-jrs-converter:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-jrs-converter'] ))\n\n\n    _out.log('');\n  }\n\n  _err.init(o.debug, o.assert, o.silent); // Handle invalid verbs here (a bit easier here than in commander.js)...\n\n\n  if (o.verb && !HMR.verbs[o.verb] && !HMR.alias[o.verb] && o.verb !== 'help') {\n    _err.err({\n      fluenterror: HMSTATUS.invalidCommand,\n      quit: true,\n      attempted: o.orgVerb\n    }, true);\n  } // Override the .missingArgument behavior\n\n\n  Command.prototype.missingArgument = function () {\n    if (this.name() !== 'help') {\n      _err.err({\n        verb: this.name(),\n        fluenterror: HMSTATUS.resumeNotFound\n      }, true);\n    }\n  }; // Override the .helpInformation behavior\n\n\n  Command.prototype.helpInformation = function () {\n    const manPage = FS.readFileSync(PATH.join(__dirname, 'help/use.txt'), 'utf8');\n    return M2C(manPage, 'white', 'yellow');\n  };\n\n  return {\n    args: o.args,\n    options: o.json\n  };\n}",
      "after": "async function (ar, exitCallback) {\n  _exitCallback = exitCallback || process.exit;\n  const o = await initOptions(ar);\n\n  if (o.ex) {\n    _err.init(false, true, false);\n\n    if (o.ex.op === 'parse') {\n      await _err.err({\n        fluenterror: o.ex.op === 'parse' ? HMSTATUS.invalidOptionsFile : HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    } else {\n      await _err.err({\n        fluenterror: HMSTATUS.optionsFileNotFound,\n        inner: o.ex.inner,\n        quit: true\n      });\n    }\n\n    return null;\n  }\n\n  o.silent || logMsg(_title); // Emit debug prelude if --debug was specified\n\n  if (o.debug) {\n    _out.log(chalk.cyan('The -d or --debug switch was specified. DEBUG mode engaged.'));\n\n    _out.log('');\n\n    _out.log(chalk.cyan(PAD('  Platform:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.platform === 'win32' ? 'windows' : process.platform));\n\n    _out.log(chalk.cyan(PAD('  Node.js:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(process.version));\n\n    _out.log(chalk.cyan(PAD('  HackMyResume:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(`v${PKG.version}`));\n\n    _out.log(chalk.cyan(PAD('  FRESCA:', 25, null, PAD.RIGHT)) + chalk.cyan.bold(PKG.dependencies.fresca)); //_out.log(chalk.cyan(PAD('  fresh-themes:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-themes'] ))\n    //_out.log(chalk.cyan(PAD('  fresh-jrs-converter:',25, null, PAD.RIGHT)) + chalk.cyan.bold( PKG.dependencies['fresh-jrs-converter'] ))\n\n\n    _out.log('');\n  }\n\n  _err.init(o.debug, o.assert, o.silent); // Handle invalid verbs here (a bit easier here than in commander.js)...\n\n\n  if (o.verb && !HMR.verbs[o.verb] && !HMR.alias[o.verb] && o.verb !== 'help') {\n    await _err.err({\n      fluenterror: HMSTATUS.invalidCommand,\n      quit: true,\n      attempted: o.orgVerb\n    }, true);\n  } // Override the .missingArgument behavior\n\n\n  Command.prototype.missingArgument = function () {\n    if (this.name() !== 'help') {\n      _err.err({\n        verb: this.name(),\n        fluenterror: HMSTATUS.resumeNotFound\n      }, true);\n    }\n  }; // Override the .helpInformation behavior\n\n\n  Command.prototype.helpInformation = function () {\n    const manPage = FS.readFileSync(PATH.join(__dirname, 'help/use.txt'), 'utf8');\n    return M2C(manPage, 'white', 'yellow');\n  };\n\n  return {\n    args: o.args,\n    options: o.json\n  };\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/main.js",
      "startLine": 46,
      "endLine": 46,
      "before": "function (rawArgs, exitCallback) {\n  const initInfo = initialize(rawArgs, exitCallback);\n\n  if (initInfo === null) {\n    return;\n  }\n\n  const {\n    args\n  } = initInfo; // Create the top-level (application) command...\n\n  const program = new Command('hackmyresume').version(PKG.version).description(chalk.yellow.bold('*** HackMyResume ***')).option('-s --silent', 'Run in silent mode').option('--no-color', 'Disable colors').option('--color', 'Enable colors').option('-d --debug', 'Enable diagnostics', false).option('-a --assert', 'Treat warnings as errors', false).option('-v --version', 'Show the version').allowUnknownOption();\n  program.jsonArgs = initInfo.options; // Create the NEW command\n\n  program.command('new').arguments('<sources...>').option('-f --format <fmt>', 'FRESH or JRS format', 'FRESH').alias('create').description('Create resume(s) in FRESH or JSON RESUME format.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the VALIDATE command\n\n  program.command('validate').arguments('<sources...>').description('Validate a resume in FRESH or JSON RESUME format.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the CONVERT command\n\n  program.command('convert').description('Convert a resume to/from FRESH or JSON RESUME format.').option('-f --format <fmt>', 'FRESH or JRS format and optional version', undefined).action(function () {\n    const x = splitSrcDest.call(this);\n    execute.call(this, x.src, x.dst, this.opts(), logMsg);\n  }); // Create the ANALYZE command\n\n  program.command('analyze').arguments('<sources...>').option('--private', 'Include resume fields marked as private', false).description('Analyze one or more resumes.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the PEEK command\n\n  program.command('peek').arguments('<sources...>').description('Peek at a resume field or section') //.action(( sources, sectionOrField ) ->\n  .action(function (sources) {\n    const dst = sources && sources.length > 1 ? [sources.pop()] : [];\n    execute.call(this, sources, dst, this.opts(), logMsg);\n  }); // Create the BUILD command\n\n  program.command('build').alias('generate').option('-t --theme <theme>', 'Theme name or path').option('-n --no-prettify', 'Disable HTML prettification', true).option('-c --css <option>', 'CSS linking / embedding').option('-p --pdf <engine>', 'PDF generation engine').option('--no-sort', 'Sort resume sections by date', false).option('--tips', 'Display theme tips and warnings.', false).option('--private', 'Include resume fields marked as private', false).option('--no-escape', 'Turn off encoding in Handlebars themes.', false).description('Generate resume to multiple formats') //.action(( sources, targets, options ) ->\n  .action(function () {\n    const x = splitSrcDest.call(this);\n    execute.call(this, x.src, x.dst, this.opts(), logMsg);\n  }); // Create the HELP command\n\n  program.command('help').arguments('[command]').description('Get help on a HackMyResume command').action(function (cmd) {\n    cmd = cmd || 'use';\n    const manPage = FS.readFileSync(PATH.join(__dirname, `help/${cmd}.txt`), 'utf8');\n\n    _out.log(M2C(manPage, 'white', 'yellow.bold'));\n  });\n  program.parse(args);\n\n  if (!program.args.length) {\n    throw {\n      fluenterror: 4\n    };\n  }\n}",
      "after": "async function (rawArgs, exitCallback) {\n  const initInfo = await initialize(rawArgs, exitCallback);\n\n  if (initInfo === null) {\n    return;\n  }\n\n  const {\n    args\n  } = initInfo; // Create the top-level (application) command...\n\n  const program = new Command('hackmyresume').version(PKG.version).description(chalk.yellow.bold('*** HackMyResume ***')).option('-s --silent', 'Run in silent mode').option('--no-color', 'Disable colors').option('--color', 'Enable colors').option('-d --debug', 'Enable diagnostics', false).option('-a --assert', 'Treat warnings as errors', false).option('-v --version', 'Show the version').allowUnknownOption();\n  program.jsonArgs = initInfo.options; // Create the NEW command\n\n  program.command('new').arguments('<sources...>').option('-f --format <fmt>', 'FRESH or JRS format', 'FRESH').alias('create').description('Create resume(s) in FRESH or JSON RESUME format.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the VALIDATE command\n\n  program.command('validate').arguments('<sources...>').description('Validate a resume in FRESH or JSON RESUME format.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the CONVERT command\n\n  program.command('convert').description('Convert a resume to/from FRESH or JSON RESUME format.').option('-f --format <fmt>', 'FRESH or JRS format and optional version', undefined).action(function () {\n    const x = splitSrcDest.call(this);\n    execute.call(this, x.src, x.dst, this.opts(), logMsg);\n  }); // Create the ANALYZE command\n\n  program.command('analyze').arguments('<sources...>').option('--private', 'Include resume fields marked as private', false).description('Analyze one or more resumes.').action(function (sources) {\n    execute.call(this, sources, [], this.opts(), logMsg);\n  }); // Create the PEEK command\n\n  program.command('peek').arguments('<sources...>').description('Peek at a resume field or section') //.action(( sources, sectionOrField ) ->\n  .action(function (sources) {\n    const dst = sources && sources.length > 1 ? [sources.pop()] : [];\n    execute.call(this, sources, dst, this.opts(), logMsg);\n  }); // Create the BUILD command\n\n  program.command('build').alias('generate').option('-t --theme <theme>', 'Theme name or path').option('-n --no-prettify', 'Disable HTML prettification', true).option('-c --css <option>', 'CSS linking / embedding').option('-p --pdf <engine>', 'PDF generation engine').option('--no-sort', 'Sort resume sections by date', false).option('--tips', 'Display theme tips and warnings.', false).option('--private', 'Include resume fields marked as private', false).option('--no-escape', 'Turn off encoding in Handlebars themes.', false).description('Generate resume to multiple formats') //.action(( sources, targets, options ) ->\n  .action(function () {\n    const x = splitSrcDest.call(this);\n    execute.call(this, x.src, x.dst, this.opts(), logMsg);\n  }); // Create the HELP command\n\n  program.command('help').arguments('[command]').description('Get help on a HackMyResume command').action(function (cmd) {\n    cmd = cmd || 'use';\n    const manPage = FS.readFileSync(PATH.join(__dirname, `help/${cmd}.txt`), 'utf8');\n\n    _out.log(M2C(manPage, 'white', 'yellow.bold'));\n  });\n  program.parse(args);\n\n  if (!program.args.length) {\n    throw {\n      fluenterror: 4\n    };\n  }\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/src/cli/index.js",
      "startLine": 15,
      "endLine": 15,
      "before": "require('./main')(process.argv)",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait require('./main')(process.argv)"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 56,
      "endLine": 56,
      "before": "// HackMyResume CLI stub. Handle a single HMR invocation.\nfunction HackMyResumeOutputStub(args) {\n  console.log = MyConsoleLog;\n  process.exit = MyProcessExit;\n  CHALK.enabled = false;\n\n  try {\n    args.unshift(process.argv[1]);\n    args.unshift(process.argv[0]);\n    HMRMAIN(args);\n  } catch (ex) {\n    console.error(ex);\n\n    require('../../src/cli/error').err(ex, false);\n  }\n\n  CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n  console.log = ConsoleLogOrg;\n} // Run a test through the stub, gathering console.log output into \"gather\"\n// and testing against it.",
      "after": "// HackMyResume CLI stub. Handle a single HMR invocation.\nasync function HackMyResumeOutputStub(args) {\n  console.log = MyConsoleLog;\n  process.exit = MyProcessExit;\n  CHALK.enabled = false;\n\n  try {\n    args.unshift(process.argv[1]);\n    args.unshift(process.argv[0]);\n    await HMRMAIN(args);\n  } catch (ex) {\n    console.error(ex);\n    await require('../../src/cli/error').err(ex, false);\n  }\n\n  CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n  console.log = ConsoleLogOrg;\n} // Run a test through the stub, gathering console.log output into \"gather\"\n// and testing against it."
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 74,
      "endLine": 74,
      "before": "function () {\n  gather = '';\n  HackMyResumeOutputStub(args);\n  expect(_.all(tests, function (t) {\n    return gather.indexOf(t) > -1;\n  })).to.equal(true);\n}",
      "after": "async function () {\n  gather = '';\n  await HackMyResumeOutputStub(args);\n  expect(_.all(tests, function (t) {\n    return gather.indexOf(t) > -1;\n  })).to.equal(true);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 96,
      "endLine": 97,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 99,
      "endLine": 100,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 102,
      "endLine": 103,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 105,
      "endLine": 109,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 111,
      "endLine": 112,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 114,
      "endLine": 115,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 120,
      "endLine": 121,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 123,
      "endLine": 131,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 133,
      "endLine": 141,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 143,
      "endLine": 154,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 156,
      "endLine": 167,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 169,
      "endLine": 180,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    }
  ],
  "10": [
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-cli.js",
      "startLine": 41,
      "endLine": 41,
      "before": "function () {\n  this.timeout(50000);\n\n  function run(args, expErr) {\n    var title = args;\n    it('Testing: \"' + title + '\"\\n\\n', function (done) {\n      try {\n        EXEC('hackmyresume ' + args, null, function (err, stdo, stde) {\n          var errCode = err && err.code || 0;\n          errCode.should.equal(parseInt(expErr, 10));\n          done();\n        });\n      } catch (ex) {\n        ex.status.should.equal(parseInt(expErr, 10));\n        done();\n      }\n    });\n  }\n\n  var testFile = PATH.join(__dirname, './test-hmr.txt');\n  var lines = FS.readFileSync(testFile, 'utf8').split('\\n');\n  lines.forEach(function (l) {\n    if (l && l.trim()) {\n      if (l[0] !== '#') {\n        var lineInfo = l.split('|');\n        var errCode = lineInfo[0];\n        run(lineInfo.length > 1 ? lineInfo[1] : '', errCode);\n      }\n    }\n  });\n}",
      "after": "async function () {\n  this.timeout(50000);\n\n  function run(args, expErr) {\n    var title = args;\n    it('Testing: \"' + title + '\"\\n\\n', function (done) {\n      try {\n        EXEC('hackmyresume ' + args, null, function (err, stdo, stde) {\n          var errCode = err && err.code || 0;\n          errCode.should.equal(parseInt(expErr, 10));\n          done();\n        });\n      } catch (ex) {\n        ex.status.should.equal(parseInt(expErr, 10));\n        done();\n      }\n    });\n  }\n\n  var testFile = PATH.join(__dirname, './test-hmr.txt');\n  var lines = (await FS.promises.readFile(testFile, 'utf8')).split('\\n');\n  lines.forEach(function (l) {\n    if (l && l.trim()) {\n      if (l[0] !== '#') {\n        var lineInfo = l.split('|');\n        var errCode = lineInfo[0];\n        run(lineInfo.length > 1 ? lineInfo[1] : '', errCode);\n      }\n    }\n  });\n}"
    }
  ],
  "11": [
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 87,
      "endLine": 87,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = (await FS.promises.readFile(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8')).replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    }
  ],
  "12": [
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 90,
      "endLine": 90,
      "before": "function (verb) {\n  manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n}",
      "after": "async function (verb) {\n  manPages[verb] = (await FS.promises.readFile(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8')).replace(/\\*\\*/g, '');\n}"
    },
    {
      "filename": "/home/osboxes/HackMyResume/test/scripts/test-output.js",
      "startLine": 89,
      "endLine": 91,
      "before": "function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n\n      require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, function () {\n      gather = '';\n      HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8').replace(/\\*\\*/g, '');\n  var manPages = {};\n  ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(function (verb) {\n    manPages[verb] = FS.readFileSync(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8').replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  run('HMR should output help doc with --help', ['--help'], [manPage]);\n  run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}",
      "after": "async function () {\n  this.timeout(50000); // HackMyResume CLI stub. Handle a single HMR invocation.\n\n  async function HackMyResumeOutputStub(args) {\n    console.log = MyConsoleLog;\n    process.exit = MyProcessExit;\n    CHALK.enabled = false;\n\n    try {\n      args.unshift(process.argv[1]);\n      args.unshift(process.argv[0]);\n      await HMRMAIN(args);\n    } catch (ex) {\n      console.error(ex);\n      await require('../../src/cli/error').err(ex, false);\n    }\n\n    CHALK.enabled = true; //process.exit = ProcessExitOrg;\n\n    console.log = ConsoleLogOrg;\n  } // Run a test through the stub, gathering console.log output into \"gather\"\n  // and testing against it.\n\n\n  function run(title, args, tests) {\n    it(title, async function () {\n      gather = '';\n      await HackMyResumeOutputStub(args);\n      expect(_.all(tests, function (t) {\n        return gather.indexOf(t) > -1;\n      })).to.equal(true);\n    });\n  }\n\n  var title = '*** HackMyResume v' + PKG.version + ' ***';\n  var feedMe = 'Please feed me a resume in FRESH or JSON Resume format.';\n  var manPage = (await FS.promises.readFile(PATH.resolve(__dirname, '../../src/cli/help/use.txt'), 'utf8')).replace(/\\*\\*/g, '');\n  var manPages = {};\n  await ['build', 'new', 'convert', 'analyze', 'validate', 'peek'].forEach(async function (verb) {\n    manPages[verb] = (await FS.promises.readFile(PATH.resolve(__dirname, '../../src/cli/help/' + verb + '.txt'), 'utf8')).replace(/\\*\\*/g, '');\n  }); // run('HMR should output a help string when no command is specified',\n  //     [], [ title, 'Please give me a command (BUILD, ANALYZE, VALIDATE, CONVERT, NEW, or PEEK).' ]);\n\n  await run('BUILD should output a help message when no source is specified', ['build'], [title, manPages.build]);\n  await run('VALIDATE should output a help message when no source is specified', ['validate'], [title, manPages.validate]);\n  await run('ANALYZE should output a help message when no source is specified', ['analyze'], [title, manPages.analyze]);\n  await run('BUILD should display an error on a broken resume', ['build', 'node_modules/fresh-test-resumes/src/fresh/johnny-trouble.broken.json', '-t', 'modern'], [title, 'Error: Invalid or corrupt JSON on line']);\n  await run('CONVERT should output a help message when no source is specified', ['convert'], [title, manPages.convert]);\n  await run('NEW should output a help message when no source is specified', ['new'], [title, manPages.new]); // This will cause the HELP doc to be emitted, followed by an \"unknown option --help\"\n  // error in the log, based on the way we're calling into HMR. As long as the test\n  // passes, any extraneous error messages can be ignored here.\n\n  await run('HMR should output help doc with --help', ['--help'], [manPage]);\n  await run('HMR should accept raw JSON via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-1.all', '-o', \"{ theme: 'compact', debug: true, pdf: 'wkhtmltopdf' }\"], ['Applying COMPACT theme (', '(with wkhtmltopdf)']);\n  await run('HMR should accept a JSON settings file via --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-2.all', '--options', \"test/scripts/hmr-options.json\"], ['Applying POSITIVE theme']);\n  await run('Explicit command line options should override --options', ['build', 'node_modules/fresh-test-resumes/src/fresh/jane-fullstacker.json', 'to', 'test/sandbox/temp/janeq-3.all', '--options', \"test/scripts/hmr-options.json\", \"-t\", \"modern\"], ['Applying MODERN theme']);\n  await run('HMR should detect a missing or inaccessible options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-nonexistent.json\", \"-t\", \"modern\"], ['The specified options file is missing or inaccessible']);\n  await run('HMR should detect an invalid or malformed options file', ['build', 'doesntmatter.json', 'to', 'dontcare.all', '--options', \"test/scripts/hmr-options-broken.json\", \"-t\", \"modern\"], ['The specified options file is invalid']);\n}"
    }
  ]
}