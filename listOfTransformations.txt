{
  "0": [
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 44,
      "endLine": 48,
      "before": "async function download() {\n  try {\n    fs.writeFileSync(lumo, '#!/usr/bin/env node\\n' + 'console.log(\"Please wait until the \\'lumo\\' installation completes!\")\\n');\n  } catch (err) {\n    if (err.code === 'EACCES') {\n      warn('Please try installing Lumo again with the `--unsafe-perm` option.');\n      info('Example: `npm i -g --unsafe-perm lumo-cljs`');\n      process.exit();\n    }\n\n    throw err;\n  }\n\n  onDeath(() => {\n    fs.writeFileSync(lumo, '#!/usr/bin/env node\\n' + 'console.log(\"The \\'lumo\\' installation did not complete successfully.\")\\n' + 'console.log(\"Please run \\'npm i -g lumo-cljs\\' to reinstall!\")\\n');\n    process.exit();\n  });\n  info('For the source code, check out: https://github.com/anmonteiro/lumo'); // Print an empty line\n\n  console.log('');\n  await retry(async () => {\n    enableProgress('Downloading Lumo ' + packageJSON.version);\n    showProgress(0);\n\n    try {\n      const name = platformToName[platform];\n      const url = `https://github.com/anmonteiro/lumo/releases/download/${packageJSON.version}/${name}.gz`;\n      const resp = await fetch(url, {\n        compress: false\n      });\n\n      if (resp.status !== 200) {\n        throw new Error(resp.statusText + ' ' + url);\n      }\n\n      const size = resp.headers.get('content-length');\n      const ws = fs.createWriteStream(partial);\n      await new Promise((resolve, reject) => {\n        let bytesRead = 0;\n        resp.body.on('error', reject).on('data', chunk => {\n          bytesRead += chunk.length;\n\n          if (size) {\n            showProgress(100 * bytesRead / size);\n          }\n        });\n        const gunzip = zlib.createGunzip();\n        gunzip.on('error', reject);\n        resp.body.pipe(gunzip).pipe(ws);\n        ws.on('error', reject).on('close', () => {\n          showProgress(100);\n          resolve();\n        });\n      });\n    } finally {\n      disableProgress();\n    }\n  }, {\n    retries: 500,\n    onRetry: err => console.error(err)\n  });\n  fs.renameSync(partial, target);\n  fs.writeFileSync(backup, fs.readFileSync(target));\n}",
      "after": "async function download() {\n  try {\n    await fs.promises.writeFile(lumo, '#!/usr/bin/env node\\n' + 'console.log(\"Please wait until the \\'lumo\\' installation completes!\")\\n');\n  } catch (err) {\n    if (err.code === 'EACCES') {\n      warn('Please try installing Lumo again with the `--unsafe-perm` option.');\n      info('Example: `npm i -g --unsafe-perm lumo-cljs`');\n      process.exit();\n    }\n\n    throw err;\n  }\n\n  onDeath(() => {\n    fs.writeFileSync(lumo, '#!/usr/bin/env node\\n' + 'console.log(\"The \\'lumo\\' installation did not complete successfully.\")\\n' + 'console.log(\"Please run \\'npm i -g lumo-cljs\\' to reinstall!\")\\n');\n    process.exit();\n  });\n  info('For the source code, check out: https://github.com/anmonteiro/lumo'); // Print an empty line\n\n  console.log('');\n  await retry(async () => {\n    enableProgress('Downloading Lumo ' + packageJSON.version);\n    showProgress(0);\n\n    try {\n      const name = platformToName[platform];\n      const url = `https://github.com/anmonteiro/lumo/releases/download/${packageJSON.version}/${name}.gz`;\n      const resp = await fetch(url, {\n        compress: false\n      });\n\n      if (resp.status !== 200) {\n        throw new Error(resp.statusText + ' ' + url);\n      }\n\n      const size = resp.headers.get('content-length');\n      const ws = fs.createWriteStream(partial);\n      await new Promise((resolve, reject) => {\n        let bytesRead = 0;\n        resp.body.on('error', reject).on('data', chunk => {\n          bytesRead += chunk.length;\n\n          if (size) {\n            showProgress(100 * bytesRead / size);\n          }\n        });\n        const gunzip = zlib.createGunzip();\n        gunzip.on('error', reject);\n        resp.body.pipe(gunzip).pipe(ws);\n        ws.on('error', reject).on('close', () => {\n          showProgress(100);\n          resolve();\n        });\n      });\n    } finally {\n      disableProgress();\n    }\n  }, {\n    retries: 500,\n    onRetry: err => console.error(err)\n  });\n  fs.renameSync(partial, target);\n  fs.writeFileSync(backup, fs.readFileSync(target));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 149,
      "endLine": 149,
      "before": "async function main() {\n  if (fs.existsSync(backup)) {\n    fs.writeFileSync(target, fs.readFileSync(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      fs.writeFileSync(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}",
      "after": "async function main() {\n  if (fs.existsSync(backup)) {\n    fs.writeFileSync(target, fs.readFileSync(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      fs.writeFileSync(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 176,
      "endLine": 176,
      "before": "main()",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait main()"
    }
  ],
  "1": [
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 63,
      "endLine": 68,
      "before": "() => {\n  fs.writeFileSync(lumo, '#!/usr/bin/env node\\n' + 'console.log(\"The \\'lumo\\' installation did not complete successfully.\")\\n' + 'console.log(\"Please run \\'npm i -g lumo-cljs\\' to reinstall!\")\\n');\n  process.exit();\n}",
      "after": "async () => {\n  await fs.promises.writeFile(lumo, '#!/usr/bin/env node\\n' + 'console.log(\"The \\'lumo\\' installation did not complete successfully.\")\\n' + 'console.log(\"Please run \\'npm i -g lumo-cljs\\' to reinstall!\")\\n');\n  process.exit();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 149,
      "endLine": 149,
      "before": "async function main() {\n  if (fs.existsSync(backup)) {\n    fs.writeFileSync(target, fs.readFileSync(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      fs.writeFileSync(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}",
      "after": "async function main() {\n  if (fs.existsSync(backup)) {\n    fs.writeFileSync(target, fs.readFileSync(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      fs.writeFileSync(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 176,
      "endLine": 176,
      "before": "main()",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait main()"
    }
  ],
  "2": [
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 129,
      "endLine": 129,
      "before": "async function download() {\n  try {\n    fs.writeFileSync(lumo, '#!/usr/bin/env node\\n' + 'console.log(\"Please wait until the \\'lumo\\' installation completes!\")\\n');\n  } catch (err) {\n    if (err.code === 'EACCES') {\n      warn('Please try installing Lumo again with the `--unsafe-perm` option.');\n      info('Example: `npm i -g --unsafe-perm lumo-cljs`');\n      process.exit();\n    }\n\n    throw err;\n  }\n\n  onDeath(() => {\n    fs.writeFileSync(lumo, '#!/usr/bin/env node\\n' + 'console.log(\"The \\'lumo\\' installation did not complete successfully.\")\\n' + 'console.log(\"Please run \\'npm i -g lumo-cljs\\' to reinstall!\")\\n');\n    process.exit();\n  });\n  info('For the source code, check out: https://github.com/anmonteiro/lumo'); // Print an empty line\n\n  console.log('');\n  await retry(async () => {\n    enableProgress('Downloading Lumo ' + packageJSON.version);\n    showProgress(0);\n\n    try {\n      const name = platformToName[platform];\n      const url = `https://github.com/anmonteiro/lumo/releases/download/${packageJSON.version}/${name}.gz`;\n      const resp = await fetch(url, {\n        compress: false\n      });\n\n      if (resp.status !== 200) {\n        throw new Error(resp.statusText + ' ' + url);\n      }\n\n      const size = resp.headers.get('content-length');\n      const ws = fs.createWriteStream(partial);\n      await new Promise((resolve, reject) => {\n        let bytesRead = 0;\n        resp.body.on('error', reject).on('data', chunk => {\n          bytesRead += chunk.length;\n\n          if (size) {\n            showProgress(100 * bytesRead / size);\n          }\n        });\n        const gunzip = zlib.createGunzip();\n        gunzip.on('error', reject);\n        resp.body.pipe(gunzip).pipe(ws);\n        ws.on('error', reject).on('close', () => {\n          showProgress(100);\n          resolve();\n        });\n      });\n    } finally {\n      disableProgress();\n    }\n  }, {\n    retries: 500,\n    onRetry: err => console.error(err)\n  });\n  fs.renameSync(partial, target);\n  fs.writeFileSync(backup, fs.readFileSync(target));\n}",
      "after": "async function download() {\n  try {\n    await fs.promises.writeFile(lumo, '#!/usr/bin/env node\\n' + 'console.log(\"Please wait until the \\'lumo\\' installation completes!\")\\n');\n  } catch (err) {\n    if (err.code === 'EACCES') {\n      warn('Please try installing Lumo again with the `--unsafe-perm` option.');\n      info('Example: `npm i -g --unsafe-perm lumo-cljs`');\n      process.exit();\n    }\n\n    throw err;\n  }\n\n  onDeath(async () => {\n    await fs.promises.writeFile(lumo, '#!/usr/bin/env node\\n' + 'console.log(\"The \\'lumo\\' installation did not complete successfully.\")\\n' + 'console.log(\"Please run \\'npm i -g lumo-cljs\\' to reinstall!\")\\n');\n    process.exit();\n  });\n  info('For the source code, check out: https://github.com/anmonteiro/lumo'); // Print an empty line\n\n  console.log('');\n  await retry(async () => {\n    enableProgress('Downloading Lumo ' + packageJSON.version);\n    showProgress(0);\n\n    try {\n      const name = platformToName[platform];\n      const url = `https://github.com/anmonteiro/lumo/releases/download/${packageJSON.version}/${name}.gz`;\n      const resp = await fetch(url, {\n        compress: false\n      });\n\n      if (resp.status !== 200) {\n        throw new Error(resp.statusText + ' ' + url);\n      }\n\n      const size = resp.headers.get('content-length');\n      const ws = fs.createWriteStream(partial);\n      await new Promise((resolve, reject) => {\n        let bytesRead = 0;\n        resp.body.on('error', reject).on('data', chunk => {\n          bytesRead += chunk.length;\n\n          if (size) {\n            showProgress(100 * bytesRead / size);\n          }\n        });\n        const gunzip = zlib.createGunzip();\n        gunzip.on('error', reject);\n        resp.body.pipe(gunzip).pipe(ws);\n        ws.on('error', reject).on('close', () => {\n          showProgress(100);\n          resolve();\n        });\n      });\n    } finally {\n      disableProgress();\n    }\n  }, {\n    retries: 500,\n    onRetry: err => console.error(err)\n  });\n  fs.renameSync(partial, target);\n  await fs.promises.writeFile(backup, fs.readFileSync(target));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 149,
      "endLine": 149,
      "before": "async function main() {\n  if (fs.existsSync(backup)) {\n    fs.writeFileSync(target, fs.readFileSync(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      fs.writeFileSync(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}",
      "after": "async function main() {\n  if (fs.existsSync(backup)) {\n    fs.writeFileSync(target, fs.readFileSync(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      fs.writeFileSync(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 176,
      "endLine": 176,
      "before": "main()",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait main()"
    }
  ],
  "3": [
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 129,
      "endLine": 129,
      "before": "async function download() {\n  try {\n    fs.writeFileSync(lumo, '#!/usr/bin/env node\\n' + 'console.log(\"Please wait until the \\'lumo\\' installation completes!\")\\n');\n  } catch (err) {\n    if (err.code === 'EACCES') {\n      warn('Please try installing Lumo again with the `--unsafe-perm` option.');\n      info('Example: `npm i -g --unsafe-perm lumo-cljs`');\n      process.exit();\n    }\n\n    throw err;\n  }\n\n  onDeath(() => {\n    fs.writeFileSync(lumo, '#!/usr/bin/env node\\n' + 'console.log(\"The \\'lumo\\' installation did not complete successfully.\")\\n' + 'console.log(\"Please run \\'npm i -g lumo-cljs\\' to reinstall!\")\\n');\n    process.exit();\n  });\n  info('For the source code, check out: https://github.com/anmonteiro/lumo'); // Print an empty line\n\n  console.log('');\n  await retry(async () => {\n    enableProgress('Downloading Lumo ' + packageJSON.version);\n    showProgress(0);\n\n    try {\n      const name = platformToName[platform];\n      const url = `https://github.com/anmonteiro/lumo/releases/download/${packageJSON.version}/${name}.gz`;\n      const resp = await fetch(url, {\n        compress: false\n      });\n\n      if (resp.status !== 200) {\n        throw new Error(resp.statusText + ' ' + url);\n      }\n\n      const size = resp.headers.get('content-length');\n      const ws = fs.createWriteStream(partial);\n      await new Promise((resolve, reject) => {\n        let bytesRead = 0;\n        resp.body.on('error', reject).on('data', chunk => {\n          bytesRead += chunk.length;\n\n          if (size) {\n            showProgress(100 * bytesRead / size);\n          }\n        });\n        const gunzip = zlib.createGunzip();\n        gunzip.on('error', reject);\n        resp.body.pipe(gunzip).pipe(ws);\n        ws.on('error', reject).on('close', () => {\n          showProgress(100);\n          resolve();\n        });\n      });\n    } finally {\n      disableProgress();\n    }\n  }, {\n    retries: 500,\n    onRetry: err => console.error(err)\n  });\n  fs.renameSync(partial, target);\n  fs.writeFileSync(backup, fs.readFileSync(target));\n}",
      "after": "async function download() {\n  try {\n    await fs.promises.writeFile(lumo, '#!/usr/bin/env node\\n' + 'console.log(\"Please wait until the \\'lumo\\' installation completes!\")\\n');\n  } catch (err) {\n    if (err.code === 'EACCES') {\n      warn('Please try installing Lumo again with the `--unsafe-perm` option.');\n      info('Example: `npm i -g --unsafe-perm lumo-cljs`');\n      process.exit();\n    }\n\n    throw err;\n  }\n\n  onDeath(async () => {\n    await fs.promises.writeFile(lumo, '#!/usr/bin/env node\\n' + 'console.log(\"The \\'lumo\\' installation did not complete successfully.\")\\n' + 'console.log(\"Please run \\'npm i -g lumo-cljs\\' to reinstall!\")\\n');\n    process.exit();\n  });\n  info('For the source code, check out: https://github.com/anmonteiro/lumo'); // Print an empty line\n\n  console.log('');\n  await retry(async () => {\n    enableProgress('Downloading Lumo ' + packageJSON.version);\n    showProgress(0);\n\n    try {\n      const name = platformToName[platform];\n      const url = `https://github.com/anmonteiro/lumo/releases/download/${packageJSON.version}/${name}.gz`;\n      const resp = await fetch(url, {\n        compress: false\n      });\n\n      if (resp.status !== 200) {\n        throw new Error(resp.statusText + ' ' + url);\n      }\n\n      const size = resp.headers.get('content-length');\n      const ws = fs.createWriteStream(partial);\n      await new Promise((resolve, reject) => {\n        let bytesRead = 0;\n        resp.body.on('error', reject).on('data', chunk => {\n          bytesRead += chunk.length;\n\n          if (size) {\n            showProgress(100 * bytesRead / size);\n          }\n        });\n        const gunzip = zlib.createGunzip();\n        gunzip.on('error', reject);\n        resp.body.pipe(gunzip).pipe(ws);\n        ws.on('error', reject).on('close', () => {\n          showProgress(100);\n          resolve();\n        });\n      });\n    } finally {\n      disableProgress();\n    }\n  }, {\n    retries: 500,\n    onRetry: err => console.error(err)\n  });\n  fs.renameSync(partial, target);\n  await fs.promises.writeFile(backup, await fs.promises.readFile(target));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 149,
      "endLine": 149,
      "before": "async function main() {\n  if (fs.existsSync(backup)) {\n    fs.writeFileSync(target, fs.readFileSync(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      fs.writeFileSync(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}",
      "after": "async function main() {\n  if (fs.existsSync(backup)) {\n    fs.writeFileSync(target, fs.readFileSync(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      fs.writeFileSync(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 176,
      "endLine": 176,
      "before": "main()",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait main()"
    }
  ],
  "4": [
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 147,
      "endLine": 147,
      "before": "async function main() {\n  if (fs.existsSync(backup)) {\n    fs.writeFileSync(target, fs.readFileSync(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      fs.writeFileSync(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}",
      "after": "async function main() {\n  if (fs.existsSync(backup)) {\n    await fs.promises.writeFile(target, fs.readFileSync(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      fs.writeFileSync(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 176,
      "endLine": 176,
      "before": "main()",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait main()"
    }
  ],
  "5": [
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 147,
      "endLine": 147,
      "before": "async function main() {\n  if (fs.existsSync(backup)) {\n    fs.writeFileSync(target, fs.readFileSync(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      fs.writeFileSync(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}",
      "after": "async function main() {\n  if (fs.existsSync(backup)) {\n    await fs.promises.writeFile(target, await fs.promises.readFile(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      fs.writeFileSync(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 176,
      "endLine": 176,
      "before": "main()",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait main()"
    }
  ],
  "6": [
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 154,
      "endLine": 154,
      "before": "async function main() {\n  if (fs.existsSync(backup)) {\n    fs.writeFileSync(target, fs.readFileSync(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      fs.writeFileSync(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}",
      "after": "async function main() {\n  if (fs.existsSync(backup)) {\n    await fs.promises.writeFile(target, await fs.promises.readFile(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      await fs.promises.writeFile(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 176,
      "endLine": 176,
      "before": "main()",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait main()"
    }
  ],
  "7": [
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 162,
      "endLine": 164,
      "before": "async function main() {\n  if (fs.existsSync(backup)) {\n    fs.writeFileSync(target, fs.readFileSync(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      fs.writeFileSync(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}",
      "after": "async function main() {\n  if (fs.existsSync(backup)) {\n    await fs.promises.writeFile(target, await fs.promises.readFile(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      await fs.promises.writeFile(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      await fs.promises.writeFile(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 176,
      "endLine": 176,
      "before": "main()",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait main()"
    }
  ],
  "8": [
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 163,
      "endLine": 163,
      "before": "async function main() {\n  if (fs.existsSync(backup)) {\n    fs.writeFileSync(target, fs.readFileSync(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      fs.writeFileSync(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      fs.writeFileSync(gitBashFile, modifyGitBashFile(fs.readFileSync(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}",
      "after": "async function main() {\n  if (fs.existsSync(backup)) {\n    await fs.promises.writeFile(target, await fs.promises.readFile(backup));\n  } else {\n    await download();\n  }\n\n  if (platform === 'win32') {\n    try {\n      await fs.promises.writeFile(lumo, ''); // Workaround for https://github.com/npm/cmd-shim/pull/25\n\n      const globalPath = path.dirname(await which('npm'));\n      let gitBashFile = path.join(globalPath, 'lumo');\n\n      if (!fs.existsSync(gitBashFile)) {\n        gitBashFile = path.join(process.env.APPDATA, 'npm/lumo');\n      }\n\n      await fs.promises.writeFile(gitBashFile, modifyGitBashFile(await fs.promises.readFile(gitBashFile, 'utf8')));\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // Not a problem. only git cmd will not work\n        console.error(err);\n      }\n    }\n  } else {\n    plusxSync(lumo);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 176,
      "endLine": 176,
      "before": "main()",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait main()"
    }
  ],
  "10": [
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 159,
      "endLine": 159,
      "before": "function load(filename: string): ?string {\n  if (__DEV__) {\n    try {\n      return fs.readFileSync(`${__dirname}/${filename}`, 'utf8');\n    } catch (e) {\n      return null;\n    }\n  }\n\n  const fname = util.isWindows ? filename.replace(/\\//g, '\\\\') : filename;\n  const gzipped = lumo.internal.embedded.get(fname);\n\n  if (gzipped != null) {\n    return zlib.inflateSync(gzipped).toString();\n  }\n\n  return null;\n}",
      "after": "async function load(filename: string): ?string {\n  if (__DEV__) {\n    try {\n      return await fs.promises.readFile(`${__dirname}/${filename}`, 'utf8');\n    } catch (e) {\n      return null;\n    }\n  }\n\n  const fname = util.isWindows ? filename.replace(/\\//g, '\\\\') : filename;\n  const gzipped = lumo.internal.embedded.get(fname);\n\n  if (gzipped != null) {\n    return zlib.inflateSync(gzipped).toString();\n  }\n\n  return null;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 34,
      "endLine": 34,
      "before": "() => {\n  expect(lumo.load('foo')).toBe('fooContents');\n}",
      "after": "async () => {\n  expect(await lumo.load('foo')).toBe('fooContents');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 38,
      "endLine": 38,
      "before": "() => {\n  expect(lumo.load('nonExistent')).toBe(null);\n}",
      "after": "async () => {\n  expect(await lumo.load('nonExistent')).toBe(null);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 73,
      "endLine": 73,
      "before": "() => {\n  expect(lumo.load('foo')).toBe('fooContents');\n}",
      "after": "async () => {\n  expect(await lumo.load('foo')).toBe('fooContents');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 77,
      "endLine": 77,
      "before": "() => {\n  expect(lumo.load('nonExistent')).toBe(null);\n}",
      "after": "async () => {\n  expect(await lumo.load('nonExistent')).toBe(null);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cli.js",
      "startLine": 41,
      "endLine": 41,
      "before": "function createBanner(): string {\n  // $FlowFixMe: we know for sure this file will exist.\n  const cljsVersion: string = lumo.load('clojurescript-version');\n  return `Lumo ${lumoVersion}\nClojureScript ${cljsVersion}\nNode.js ${process.version}\n Docs: (doc function-name-here)\n       (find-doc \"part-of-name-here\")\n Source: (source function-name-here)\n Exit: Control+D or :cljs/quit or exit\n\n`;\n}",
      "after": "async function createBanner(): string {\n  // $FlowFixMe: we know for sure this file will exist.\n  const cljsVersion: string = await lumo.load('clojurescript-version');\n  return `Lumo ${lumoVersion}\nClojureScript ${cljsVersion}\nNode.js ${process.version}\n Docs: (doc function-name-here)\n       (find-doc \"part-of-name-here\")\n Source: (source function-name-here)\n Exit: Control+D or :cljs/quit or exit\n\n`;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cli.js",
      "startLine": 54,
      "endLine": 54,
      "before": "function printBanner(): void {\n  process.stdout.write(createBanner());\n}",
      "after": "async function printBanner(): void {\n  process.stdout.write(await createBanner());\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cli.js",
      "startLine": 336,
      "endLine": 336,
      "before": "function startCLI(): mixed {\n  const opts = getCLIOpts();\n  const {\n    args,\n    cache,\n    classpath,\n    dependencies,\n    unrecognized,\n    help,\n    legal,\n    mainNsName,\n    mainScript,\n    quiet,\n    scripts,\n    version\n  } = opts;\n  const autoCache = opts['auto-cache'];\n  const localRepo = opts['local-repo'];\n  const dumpSDK = opts['dump-sdk']; // if help, print help and bail\n\n  if (help) {\n    printHelp();\n    return process.exit(unrecognized ? 1 : 0);\n  }\n\n  if (version) {\n    return printVersion();\n  }\n\n  if (legal) {\n    return printLegal();\n  }\n\n  if (dumpSDK != null) {\n    return lumo.dumpSDK(dumpSDK);\n  }\n\n  v8.setFlagsFromString('--use_strict');\n\n  if (scripts.length === 0 && !mainNsName && !mainScript && args.length === 0) {\n    opts.repl = true;\n  }\n\n  if (cache || autoCache) {\n    const cachePath = cache || '.lumo_cache';\n    util.ensureDir(cachePath);\n    opts.cache = cachePath;\n  } // TODO: print classpath to stdout if `:verbose`\n\n\n  if (classpath.length !== 0) {\n    // if (verbose) {\n    //   console.log(`Classpath resolves to: `);\n    // }\n    const srcPaths = util.srcPathsFromClasspathStrings(classpath);\n    opts.classpath = srcPaths;\n    lumo.addSourcePaths(srcPaths);\n  }\n\n  if (dependencies.length !== 0) {\n    const mvnPaths = util.srcPathsFromMavenDependencies(dependencies, localRepo);\n    opts.classpath.push(...mvnPaths);\n    lumo.addSourcePaths(mvnPaths);\n  }\n\n  if (opts.repl && !quiet) {\n    printBanner();\n  }\n\n  return startClojureScriptEngine(opts);\n}",
      "after": "async function startCLI(): mixed {\n  const opts = getCLIOpts();\n  const {\n    args,\n    cache,\n    classpath,\n    dependencies,\n    unrecognized,\n    help,\n    legal,\n    mainNsName,\n    mainScript,\n    quiet,\n    scripts,\n    version\n  } = opts;\n  const autoCache = opts['auto-cache'];\n  const localRepo = opts['local-repo'];\n  const dumpSDK = opts['dump-sdk']; // if help, print help and bail\n\n  if (help) {\n    printHelp();\n    return process.exit(unrecognized ? 1 : 0);\n  }\n\n  if (version) {\n    return printVersion();\n  }\n\n  if (legal) {\n    return printLegal();\n  }\n\n  if (dumpSDK != null) {\n    return lumo.dumpSDK(dumpSDK);\n  }\n\n  v8.setFlagsFromString('--use_strict');\n\n  if (scripts.length === 0 && !mainNsName && !mainScript && args.length === 0) {\n    opts.repl = true;\n  }\n\n  if (cache || autoCache) {\n    const cachePath = cache || '.lumo_cache';\n    util.ensureDir(cachePath);\n    opts.cache = cachePath;\n  } // TODO: print classpath to stdout if `:verbose`\n\n\n  if (classpath.length !== 0) {\n    // if (verbose) {\n    //   console.log(`Classpath resolves to: `);\n    // }\n    const srcPaths = util.srcPathsFromClasspathStrings(classpath);\n    opts.classpath = srcPaths;\n    lumo.addSourcePaths(srcPaths);\n  }\n\n  if (dependencies.length !== 0) {\n    const mvnPaths = util.srcPathsFromMavenDependencies(dependencies, localRepo);\n    opts.classpath.push(...mvnPaths);\n    lumo.addSourcePaths(mvnPaths);\n  }\n\n  if (opts.repl && !quiet) {\n    await printBanner();\n  }\n\n  return startClojureScriptEngine(opts);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 79,
      "endLine": 79,
      "before": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-vsqdfK']\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(true);\n  expect(parsedOpts['static-fns']).toBe(true);\n  expect(parsedOpts['fn-invoke-direct']).toBe(true);\n  expect(parsedOpts['dumb-terminal']).toBe(true);\n  expect(parsedOpts['auto-cache']).toBe(true);\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-vsqdfK']\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(true);\n  expect(parsedOpts['static-fns']).toBe(true);\n  expect(parsedOpts['fn-invoke-direct']).toBe(true);\n  expect(parsedOpts['dumb-terminal']).toBe(true);\n  expect(parsedOpts['auto-cache']).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 97,
      "endLine": 97,
      "before": "async () => {\n  const args = '-i foo.cljs -e :foo -e :bar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(false);\n  expect(parsedOpts.scripts.length).toEqual(3);\n}",
      "after": "async () => {\n  const args = '-i foo.cljs -e :foo -e :bar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(false);\n  expect(parsedOpts.scripts.length).toEqual(3);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 109,
      "endLine": 109,
      "before": "async () => {\n  const args = '-i foo.cljs -e :foo -i bar.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.scripts.length).toEqual(3);\n  expect(parsedOpts.scripts).toEqual([['path', 'foo.cljs'], ['text', ':foo'], ['path', 'bar.cljs']]);\n}",
      "after": "async () => {\n  const args = '-i foo.cljs -e :foo -i bar.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.scripts.length).toEqual(3);\n  expect(parsedOpts.scripts).toEqual([['path', 'foo.cljs'], ['text', ':foo'], ['path', 'bar.cljs']]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 127,
      "endLine": 127,
      "before": "async () => {\n  const args = `-c foo${delim}bar`;\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual(['foo', 'bar']);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith(['foo', 'bar']);\n}",
      "after": "async () => {\n  const args = `-c foo${delim}bar`;\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual(['foo', 'bar']);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith(['foo', 'bar']);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 140,
      "endLine": 140,
      "before": "async () => {\n  const args = '-r foo.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['foo.cljs']);\n  expect(parsedOpts.repl).toBe(true);\n}",
      "after": "async () => {\n  const args = '-r foo.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['foo.cljs']);\n  expect(parsedOpts.repl).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 153,
      "endLine": 153,
      "before": "async () => {\n  const args = '-r --verbose --socket-repl localhost:5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['--verbose', '--socket-repl', 'localhost:5555']);\n  expect(parsedOpts.repl).toBe(true);\n}",
      "after": "async () => {\n  const args = '-r --verbose --socket-repl localhost:5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['--verbose', '--socket-repl', 'localhost:5555']);\n  expect(parsedOpts.repl).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 170,
      "endLine": 170,
      "before": "async () => {\n  const args = 'foo.cljs -r';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['-r']);\n  expect(parsedOpts.repl).toBe(false);\n}",
      "after": "async () => {\n  const args = 'foo.cljs -r';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['-r']);\n  expect(parsedOpts.repl).toBe(false);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 183,
      "endLine": 183,
      "before": "async () => {\n  const args = '-k src';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.cache).toEqual('src');\n}",
      "after": "async () => {\n  const args = '-k src';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.cache).toEqual('src');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 196,
      "endLine": 196,
      "before": "async () => {\n  const args = '-k';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-k';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 208,
      "endLine": 208,
      "before": "async () => {\n  const args = '-m foo.core foo bar baz qux';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.mainNsName).toEqual('foo.core');\n  expect(parsedOpts.args).toEqual(['foo', 'bar', 'baz', 'qux']);\n}",
      "after": "async () => {\n  const args = '-m foo.core foo bar baz qux';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.mainNsName).toEqual('foo.core');\n  expect(parsedOpts.args).toEqual(['foo', 'bar', 'baz', 'qux']);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 223,
      "endLine": 223,
      "before": "async () => {\n  const args = '-a';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}",
      "after": "async () => {\n  const args = '-a';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 236,
      "endLine": 236,
      "before": "async () => {\n  const args = '--elide-asserts';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}",
      "after": "async () => {\n  const args = '--elide-asserts';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 251,
      "endLine": 251,
      "before": "async () => {\n  const args = '-A warn';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('warn');\n}",
      "after": "async () => {\n  const args = '-A warn';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('warn');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 264,
      "endLine": 264,
      "before": "async () => {\n  const args = '--checked-arrays error';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('error');\n}",
      "after": "async () => {\n  const args = '--checked-arrays error';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('error');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 288,
      "endLine": 288,
      "before": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0/react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}",
      "after": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0/react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 322,
      "endLine": 322,
      "before": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0 -L ~/some-location';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}",
      "after": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0 -L ~/some-location';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 376,
      "endLine": 376,
      "before": "async () => {\n  jest.resetModules();\n  jest.mock('../socketRepl');\n  socketRepl = require('../socketRepl');\n  startCLI = require('../cli').default;\n  const args = '-n 5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(socketRepl.open).toHaveBeenCalledTimes(1);\n  expect(socketRepl.open).toHaveBeenCalledWith({\n    host: undefined,\n    port: 5555\n  });\n}",
      "after": "async () => {\n  jest.resetModules();\n  jest.mock('../socketRepl');\n  socketRepl = require('../socketRepl');\n  startCLI = require('../cli').default;\n  const args = '-n 5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(socketRepl.open).toHaveBeenCalledTimes(1);\n  expect(socketRepl.open).toHaveBeenCalledWith({\n    host: undefined,\n    port: 5555\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 392,
      "endLine": 392,
      "before": "async () => {\n  const args = '-n';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect.assertions(2);\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect.assertions(2);\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 405,
      "endLine": 405,
      "before": "async () => {\n  const args = '-n {}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 417,
      "endLine": 417,
      "before": "async () => {\n  const args = '-n {port: 12345}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {port: 12345}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 429,
      "endLine": 429,
      "before": "async () => {\n  const args = '-n localhost';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n localhost';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 441,
      "endLine": 441,
      "before": "async () => {\n  const args = '-n {\"host\":\"localhost\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"host\":\"localhost\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 453,
      "endLine": 453,
      "before": "async () => {\n  const args = '-n foobar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n foobar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 465,
      "endLine": 465,
      "before": "async () => {\n  const args = '-n {\"port\":\"foobar\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":\"foobar\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 477,
      "endLine": 477,
      "before": "async () => {\n  const args = '-n {\"port\":0}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":0}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 489,
      "endLine": 489,
      "before": "async () => {\n  const args = '-n {\"port\":-1000}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":-1000}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 501,
      "endLine": 501,
      "before": "async () => {\n  const args = '-n {\"port\":7753888}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":7753888}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 531,
      "endLine": 531,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  await startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 540,
      "endLine": 540,
      "before": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-n', '5555']\n  });\n  await startCLI();\n  socketRepl.close();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-n', '5555']\n  });\n  await startCLI();\n  socketRepl.close();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 550,
      "endLine": 550,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-q']\n  });\n  startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-q']\n  });\n  await startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 559,
      "endLine": 559,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', 'foo.cljs']\n  });\n  startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', 'foo.cljs']\n  });\n  await startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 568,
      "endLine": 568,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-']\n  });\n  startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-']\n  });\n  await startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 579,
      "endLine": 579,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-h']\n  });\n  startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-h']\n  });\n  await startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 590,
      "endLine": 590,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-l']\n  });\n  startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-l']\n  });\n  await startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 607,
      "endLine": 607,
      "before": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  await startCLI();\n  expect(v8.setFlagsFromString).toHaveBeenCalledWith('--use_strict');\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  await startCLI();\n  expect(v8.setFlagsFromString).toHaveBeenCalledWith('--use_strict');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 49,
      "endLine": 52,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 59,
      "endLine": 63,
      "before": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}",
      "after": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 70,
      "endLine": 74,
      "before": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}",
      "after": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 81,
      "endLine": 85,
      "before": "async () => {\n  await startCLJS({\n    repl: false,\n    mainScript: 'foo.cljs',\n    scripts: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: false,\n    mainScript: 'foo.cljs',\n    scripts: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 91,
      "endLine": 96,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    // scripts will init the ClojureScript engine\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    // scripts will init the ClojureScript engine\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 103,
      "endLine": 107,
      "before": "async () => {\n  await startCLJS({\n    mainNsName: 'foo.core',\n    args: ['a', 'b', 'c'],\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(vm.ctx.cljs.core.seq).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    mainNsName: 'foo.core',\n    args: ['a', 'b', 'c'],\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(vm.ctx.cljs.core.seq).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 119,
      "endLine": 123,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(vm.createContext).toHaveBeenCalled();\n  expect(vm.createContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(vm.createContext).toHaveBeenCalled();\n  expect(vm.createContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 134,
      "endLine": 137,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 167,
      "endLine": 171,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    _: [],\n    scripts: []\n  });\n  jest.runAllTicks();\n  vm.ctx.$$LUMO_GLOBALS.eval('source');\n  expect(vm.runInContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    _: [],\n    scripts: []\n  });\n  jest.runAllTicks();\n  vm.ctx.$$LUMO_GLOBALS.eval('source');\n  expect(vm.runInContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 207,
      "endLine": 212,
      "before": "async () => {\n  expect.assertions(1);\n  await startClojureScriptEngine({\n    repl: true,\n    _: [],\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  global.$$LUMO_GLOBALS.eval('source', false);\n  expect(vm.runInThisContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  expect.assertions(1);\n  await startClojureScriptEngine({\n    repl: true,\n    _: [],\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  global.$$LUMO_GLOBALS.eval('source', false);\n  expect(vm.runInThisContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 109,
      "endLine": 109,
      "before": "() => {\n  startREPL({});\n  expect(replHistory).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(replHistory).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 115,
      "endLine": 115,
      "before": "() => {\n  startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalled();\n  expect(mockPrompt).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalled();\n  expect(mockPrompt).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 122,
      "endLine": 122,
      "before": "() => {\n  startREPL({});\n  const onCalls = on.mock.calls;\n  expect(on).toHaveBeenCalledTimes(4);\n  expect(onCalls[0][0]).toBe('line');\n  expect(onCalls[1][0]).toBe('SIGINT');\n  expect(onCalls[2][0]).toBe('close');\n  expect(onCalls[3][0]).toBe('SIGCONT');\n}",
      "after": "async () => {\n  await startREPL({});\n  const onCalls = on.mock.calls;\n  expect(on).toHaveBeenCalledTimes(4);\n  expect(onCalls[0][0]).toBe('line');\n  expect(onCalls[1][0]).toBe('SIGINT');\n  expect(onCalls[2][0]).toBe('close');\n  expect(onCalls[3][0]).toBe('SIGCONT');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 133,
      "endLine": 133,
      "before": "() => {\n  startREPL({});\n  const onCalls = process.stdin.on.mock.calls;\n  expect(process.stdin.on).toHaveBeenCalledTimes(1);\n  expect(onCalls[0][0]).toBe('keypress');\n}",
      "after": "async () => {\n  await startREPL({});\n  const onCalls = process.stdin.on.mock.calls;\n  expect(process.stdin.on).toHaveBeenCalledTimes(1);\n  expect(onCalls[0][0]).toBe('keypress');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 154,
      "endLine": 156,
      "before": "() => {\n  startREPL({\n    'dumb-terminal': false\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(true);\n}",
      "after": "async () => {\n  await startREPL({\n    'dumb-terminal': false\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 165,
      "endLine": 167,
      "before": "() => {\n  startREPL({\n    'dumb-terminal': true\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(false);\n}",
      "after": "async () => {\n  await startREPL({\n    'dumb-terminal': true\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(false);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 177,
      "endLine": 179,
      "before": "() => {\n  startREPL({\n    'dumb-terminal': true\n  });\n  expect(process.stdin.setRawMode).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startREPL({\n    'dumb-terminal': true\n  });\n  expect(process.stdin.setRawMode).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 187,
      "endLine": 189,
      "before": "() => {\n  util.isWindows = false;\n  startREPL({\n    'dumb-terminal': false\n  });\n  expect(process.stdin.setRawMode).toHaveBeenCalledWith(true);\n}",
      "after": "async () => {\n  util.isWindows = false;\n  await startREPL({\n    'dumb-terminal': false\n  });\n  expect(process.stdin.setRawMode).toHaveBeenCalledWith(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 212,
      "endLine": 212,
      "before": "() => {\n  mockReplHistory(':cljs/quit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory(':cljs/quit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 222,
      "endLine": 222,
      "before": "() => {\n  mockReplHistory('exit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory('exit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 232,
      "endLine": 232,
      "before": "() => {\n  mockReplHistory('  :cljs/quit  ', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory('  :cljs/quit  ', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 244,
      "endLine": 244,
      "before": "() => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  startREPL = require('../repl').default;\n\n  const {\n    close\n  } = require('../socketRepl');\n  /* eslint-enable global-require */\n\n\n  startREPL({});\n  expect(close).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  startREPL = require('../repl').default;\n\n  const {\n    close\n  } = require('../socketRepl');\n  /* eslint-enable global-require */\n\n\n  await startREPL({});\n  expect(close).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 273,
      "endLine": 273,
      "before": "() => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  const repl = require('../repl');\n\n  startREPL = repl.default;\n  /* eslint-enable global-require */\n\n  const originalObjectKeys = Object.keys;\n  let sessions;\n  Object.keys = jest.fn((x: {\n    [key: mixed]: mixed\n  }) => {\n    const result = originalObjectKeys(x);\n    const everyNumber = result.every((k: string) => {\n      try {\n        return !Number.isNaN(parseInt(k, 10));\n      } catch (_) {\n        return false;\n      }\n    });\n\n    if (everyNumber) {\n      sessions = x;\n    }\n\n    return result;\n  });\n  startREPL({});\n  expect(originalObjectKeys(sessions).length).toBe(0);\n  Object.keys = originalObjectKeys;\n}",
      "after": "async () => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  const repl = require('../repl');\n\n  startREPL = repl.default;\n  /* eslint-enable global-require */\n\n  const originalObjectKeys = Object.keys;\n  let sessions;\n  Object.keys = jest.fn((x: {\n    [key: mixed]: mixed\n  }) => {\n    const result = originalObjectKeys(x);\n    const everyNumber = result.every((k: string) => {\n      try {\n        return !Number.isNaN(parseInt(k, 10));\n      } catch (_) {\n        return false;\n      }\n    });\n\n    if (everyNumber) {\n      sessions = x;\n    }\n\n    return result;\n  });\n  await startREPL({});\n  expect(originalObjectKeys(sessions).length).toBe(0);\n  Object.keys = originalObjectKeys;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 325,
      "endLine": 325,
      "before": "() => {\n  const repl = require('../repl'); // eslint-disable-line global-require\n\n\n  const replCreateSession = repl.createSession;\n  repl.createSession = jest.fn((rl: readline$Interface) => ({\n    rl,\n    id: 0\n  }));\n  startREPL({});\n  handleConnection(socket);\n  handleConnection(socket);\n  expect(repl.createSession).toHaveBeenCalledTimes(2);\n  repl.createSession = replCreateSession;\n}",
      "after": "async () => {\n  const repl = require('../repl'); // eslint-disable-line global-require\n\n\n  const replCreateSession = repl.createSession;\n  repl.createSession = jest.fn((rl: readline$Interface) => ({\n    rl,\n    id: 0\n  }));\n  await startREPL({});\n  handleConnection(socket);\n  handleConnection(socket);\n  expect(repl.createSession).toHaveBeenCalledTimes(2);\n  repl.createSession = replCreateSession;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 336,
      "endLine": 336,
      "before": "() => {\n  startREPL({});\n  expect(handleConnection(socket)).toBe(1);\n  expect(handleConnection(socket)).toBe(2);\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(handleConnection(socket)).toBe(1);\n  expect(handleConnection(socket)).toBe(2);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 354,
      "endLine": 354,
      "before": "() => {\n  startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('cljs.user=> ');\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('cljs.user=> ');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 370,
      "endLine": 370,
      "before": "() => {\n  jest.resetModules();\n  jest.mock('../cljs', () => ({\n    isReadable: jest.fn((input: string) => null),\n    execute: jest.fn(),\n    getCurrentNamespace: jest.fn(() => 'cljs.user'),\n    indentSpaceCount: jest.fn((text: string) => 0)\n  })); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('       #_=> ');\n}",
      "after": "async () => {\n  jest.resetModules();\n  jest.mock('../cljs', () => ({\n    isReadable: jest.fn((input: string) => null),\n    execute: jest.fn(),\n    getCurrentNamespace: jest.fn(() => 'cljs.user'),\n    indentSpaceCount: jest.fn((text: string) => 0)\n  })); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('       #_=> ');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/index.js",
      "startLine": 5,
      "endLine": 5,
      "before": "startCLI()",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait startCLI()"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 39,
      "endLine": 39,
      "before": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nfunction openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  socket.on('close', () => {\n    deleteSession(session);\n  });\n  socket.on('error', () => {});\n  rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle",
      "after": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nasync function openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  socket.on('close', () => {\n    deleteSession(session);\n  });\n  socket.on('error', () => {});\n  rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(await createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 52,
      "endLine": 52,
      "before": "// Calls the `accept` function on the socket and handles the socket lifecycle\nfunction handleConnection(socket: net$Socket, accept: AcceptFn, args: Array<mixed> = []): number {\n  if (typeof accept === 'string') {\n    runAcceptFN(accept, socket, args);\n  } else {\n    accept(socket);\n  } // The index needs to be unique for the socket server, but not for anyone else.\n  // For that reason we're using a module global `sessionCount` variable\n\n\n  socket.on('close', () => {\n    delete sockets[sessionCount];\n  });\n  sockets[sessionCount] = socket;\n  sessionCount += 1;\n  return sessionCount;\n}",
      "after": "// Calls the `accept` function on the socket and handles the socket lifecycle\nasync function handleConnection(socket: net$Socket, accept: AcceptFn, args: Array<mixed> = []): number {\n  if (typeof accept === 'string') {\n    runAcceptFN(accept, socket, args);\n  } else {\n    await accept(socket);\n  } // The index needs to be unique for the socket server, but not for anyone else.\n  // For that reason we're using a module global `sessionCount` variable\n\n\n  socket.on('close', () => {\n    delete sockets[sessionCount];\n  });\n  sockets[sessionCount] = socket;\n  sessionCount += 1;\n  return sessionCount;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 93,
      "endLine": 93,
      "before": "(resolve: ((mixed) => void), reject: ((Error) => void)) => {\n  socketServer = net.createServer((socket: net$Socket) => handleConnection(socket, accept, args)); // $FlowIssue - wrong type definitions for `listen`\n\n  socketServer.listen(port, host, () => {\n    resolve();\n    process.on('SIGTERM', close);\n    process.on('SIGHUP', close);\n  }).on('error', reject);\n}",
      "after": "async (resolve: ((mixed) => void), reject: ((Error) => void)) => {\n  socketServer = net.createServer(async (socket: net$Socket) => await handleConnection(socket, accept, args)); // $FlowIssue - wrong type definitions for `listen`\n\n  socketServer.listen(port, host, () => {\n    resolve();\n    process.on('SIGTERM', close);\n    process.on('SIGHUP', close);\n  }).on('error', reject);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 168,
      "endLine": 168,
      "before": "function newDevelopmentContext(): vm$Context {\n  // $FlowFixMe: we know for sure this file will exist.\n  const cljsScript = new vm.Script(lumo.load('main.js'), {});\n  const context = {\n    module,\n    exports,\n    require,\n    process,\n    console,\n    setTimeout,\n    $$LUMO_GLOBALS: {\n      crypto,\n      fs,\n      path,\n      getGoogleClosureCompiler: lumo.getGoogleClosureCompiler,\n      getJSCompletions: lumo.getJSCompletions,\n      doPrint,\n      JSZip,\n      load: lumo.load,\n      readCache: lumo.readCache,\n      readSource: lumo.readSource,\n      readFile: lumo.readFile,\n      writeCache: lumo.writeCache,\n      loadUpstreamJsLibs: lumo.loadUpstreamJsLibs,\n      loadUpstreamDataReaders: lumo.loadUpstreamDataReaders,\n      resource: lumo.resource,\n      readSourceFromJar: lumo.readSourceFromJar,\n      readDirFromJar: lumo.readDirFromJar,\n      eval: lumoEval,\n      addSourcePaths: lumo.addSourcePaths,\n      getSourcePaths: lumo.getSourcePaths,\n      removeSourcePath: lumo.removeSourcePath\n    },\n    global: undefined\n  };\n  context.global = context;\n  const ctx = vm.createContext(context);\n  cljsScript.runInContext(ctx);\n  return ctx;\n}",
      "after": "async function newDevelopmentContext(): vm$Context {\n  // $FlowFixMe: we know for sure this file will exist.\n  const cljsScript = new vm.Script(await lumo.load('main.js'), {});\n  const context = {\n    module,\n    exports,\n    require,\n    process,\n    console,\n    setTimeout,\n    $$LUMO_GLOBALS: {\n      crypto,\n      fs,\n      path,\n      getGoogleClosureCompiler: lumo.getGoogleClosureCompiler,\n      getJSCompletions: lumo.getJSCompletions,\n      doPrint,\n      JSZip,\n      load: lumo.load,\n      readCache: lumo.readCache,\n      readSource: lumo.readSource,\n      readFile: lumo.readFile,\n      writeCache: lumo.writeCache,\n      loadUpstreamJsLibs: lumo.loadUpstreamJsLibs,\n      loadUpstreamDataReaders: lumo.loadUpstreamDataReaders,\n      resource: lumo.resource,\n      readSourceFromJar: lumo.readSourceFromJar,\n      readDirFromJar: lumo.readDirFromJar,\n      eval: lumoEval,\n      addSourcePaths: lumo.addSourcePaths,\n      getSourcePaths: lumo.getSourcePaths,\n      removeSourcePath: lumo.removeSourcePath\n    },\n    global: undefined\n  };\n  context.global = context;\n  const ctx = vm.createContext(context);\n  cljsScript.runInContext(ctx);\n  return ctx;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 301,
      "endLine": 301,
      "before": "function initClojureScriptEngine(opts: CLIOptsType): void {\n  if (ClojureScriptContext != null) {\n    return;\n  }\n\n  const {\n    args\n  } = opts;\n  ClojureScriptContext = __DEV__ ? newDevelopmentContext() : newClojureScriptContext(); // $FlowIssue: context can have globals\n\n  ClojureScriptContext.cljs.user = {};\n  setPrintFns();\n\n  if (args != null && args.length > 0) {\n    // $FlowIssue: context can have globals\n    ClojureScriptContext.cljs.core._STAR_command_line_args_STAR_ = // $FlowIssue: context can have globals\n    ClojureScriptContext.cljs.core.seq(args);\n  }\n\n  setRuntimeOpts(opts);\n}",
      "after": "async function initClojureScriptEngine(opts: CLIOptsType): void {\n  if (ClojureScriptContext != null) {\n    return;\n  }\n\n  const {\n    args\n  } = opts;\n  ClojureScriptContext = __DEV__ ? await newDevelopmentContext() : newClojureScriptContext(); // $FlowIssue: context can have globals\n\n  ClojureScriptContext.cljs.user = {};\n  setPrintFns();\n\n  if (args != null && args.length > 0) {\n    // $FlowIssue: context can have globals\n    ClojureScriptContext.cljs.core._STAR_command_line_args_STAR_ = // $FlowIssue: context can have globals\n    ClojureScriptContext.cljs.core.seq(args);\n  }\n\n  setRuntimeOpts(opts);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 528,
      "endLine": 528,
      "before": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    process.nextTick(() => {\n      initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}",
      "after": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    await initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    process.nextTick(() => {\n      initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cli.js",
      "startLine": 339,
      "endLine": 339,
      "before": "function startCLI(): mixed {\n  const opts = getCLIOpts();\n  const {\n    args,\n    cache,\n    classpath,\n    dependencies,\n    unrecognized,\n    help,\n    legal,\n    mainNsName,\n    mainScript,\n    quiet,\n    scripts,\n    version\n  } = opts;\n  const autoCache = opts['auto-cache'];\n  const localRepo = opts['local-repo'];\n  const dumpSDK = opts['dump-sdk']; // if help, print help and bail\n\n  if (help) {\n    printHelp();\n    return process.exit(unrecognized ? 1 : 0);\n  }\n\n  if (version) {\n    return printVersion();\n  }\n\n  if (legal) {\n    return printLegal();\n  }\n\n  if (dumpSDK != null) {\n    return lumo.dumpSDK(dumpSDK);\n  }\n\n  v8.setFlagsFromString('--use_strict');\n\n  if (scripts.length === 0 && !mainNsName && !mainScript && args.length === 0) {\n    opts.repl = true;\n  }\n\n  if (cache || autoCache) {\n    const cachePath = cache || '.lumo_cache';\n    util.ensureDir(cachePath);\n    opts.cache = cachePath;\n  } // TODO: print classpath to stdout if `:verbose`\n\n\n  if (classpath.length !== 0) {\n    // if (verbose) {\n    //   console.log(`Classpath resolves to: `);\n    // }\n    const srcPaths = util.srcPathsFromClasspathStrings(classpath);\n    opts.classpath = srcPaths;\n    lumo.addSourcePaths(srcPaths);\n  }\n\n  if (dependencies.length !== 0) {\n    const mvnPaths = util.srcPathsFromMavenDependencies(dependencies, localRepo);\n    opts.classpath.push(...mvnPaths);\n    lumo.addSourcePaths(mvnPaths);\n  }\n\n  if (opts.repl && !quiet) {\n    printBanner();\n  }\n\n  return startClojureScriptEngine(opts);\n}",
      "after": "async function startCLI(): mixed {\n  const opts = getCLIOpts();\n  const {\n    args,\n    cache,\n    classpath,\n    dependencies,\n    unrecognized,\n    help,\n    legal,\n    mainNsName,\n    mainScript,\n    quiet,\n    scripts,\n    version\n  } = opts;\n  const autoCache = opts['auto-cache'];\n  const localRepo = opts['local-repo'];\n  const dumpSDK = opts['dump-sdk']; // if help, print help and bail\n\n  if (help) {\n    printHelp();\n    return process.exit(unrecognized ? 1 : 0);\n  }\n\n  if (version) {\n    return printVersion();\n  }\n\n  if (legal) {\n    return printLegal();\n  }\n\n  if (dumpSDK != null) {\n    return lumo.dumpSDK(dumpSDK);\n  }\n\n  v8.setFlagsFromString('--use_strict');\n\n  if (scripts.length === 0 && !mainNsName && !mainScript && args.length === 0) {\n    opts.repl = true;\n  }\n\n  if (cache || autoCache) {\n    const cachePath = cache || '.lumo_cache';\n    util.ensureDir(cachePath);\n    opts.cache = cachePath;\n  } // TODO: print classpath to stdout if `:verbose`\n\n\n  if (classpath.length !== 0) {\n    // if (verbose) {\n    //   console.log(`Classpath resolves to: `);\n    // }\n    const srcPaths = util.srcPathsFromClasspathStrings(classpath);\n    opts.classpath = srcPaths;\n    lumo.addSourcePaths(srcPaths);\n  }\n\n  if (dependencies.length !== 0) {\n    const mvnPaths = util.srcPathsFromMavenDependencies(dependencies, localRepo);\n    opts.classpath.push(...mvnPaths);\n    lumo.addSourcePaths(mvnPaths);\n  }\n\n  if (opts.repl && !quiet) {\n    await printBanner();\n  }\n\n  return await startClojureScriptEngine(opts);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 533,
      "endLine": 533,
      "before": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    process.nextTick(() => {\n      initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}",
      "after": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    await initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    await initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    process.nextTick(() => {\n      initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 542,
      "endLine": 542,
      "before": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    process.nextTick(() => {\n      initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}",
      "after": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    await initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    await initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    await initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    process.nextTick(() => {\n      initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 548,
      "endLine": 548,
      "before": "() => {\n  initClojureScriptEngine(opts);\n\n  if (!__DEV__) {\n    setPrintFns(new DiscardingSender());\n  }\n\n  execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n  setPrintFns();\n}",
      "after": "async () => {\n  await initClojureScriptEngine(opts);\n\n  if (!__DEV__) {\n    setPrintFns(new DiscardingSender());\n  }\n\n  execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n  setPrintFns();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 547,
      "endLine": 565,
      "before": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    process.nextTick(() => {\n      initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}",
      "after": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    await initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    await initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    await initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    await process.nextTick(async () => {\n      await initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 571,
      "endLine": 571,
      "before": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    process.nextTick(() => {\n      initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}",
      "after": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    await initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    await initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    await initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    await process.nextTick(async () => {\n      await initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    await initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 193,
      "endLine": 193,
      "before": "function readSource(filename: string): ?SourceType {\n  // $FlowIssue: getters not supported\n  for (const srcPath of sourcePaths.paths.values()) {\n    try {\n      if (srcPath.endsWith('.jar')) {\n        const data = fs.readFileSync(srcPath);\n        const zip = new JSZip().load(data);\n        const file = zip.file(filename);\n\n        if (file != null) {\n          return {\n            source: file.asText(),\n            modified: file.date.getTime()\n          };\n        }\n      }\n\n      const filePath = path.join(srcPath, filename);\n      return {\n        source: fs.readFileSync(filePath, 'utf8'),\n        modified: fs.statSync(filePath).mtimeMs\n      };\n    } catch (_) {} // eslint-disable-line no-empty\n\n  }\n\n  return null;\n}",
      "after": "async function readSource(filename: string): ?SourceType {\n  // $FlowIssue: getters not supported\n  for (const srcPath of sourcePaths.paths.values()) {\n    try {\n      if (srcPath.endsWith('.jar')) {\n        const data = fs.readFileSync(srcPath);\n        const zip = await new JSZip().load(data);\n        const file = zip.file(filename);\n\n        if (file != null) {\n          return {\n            source: file.asText(),\n            modified: file.date.getTime()\n          };\n        }\n      }\n\n      const filePath = path.join(srcPath, filename);\n      return {\n        source: fs.readFileSync(filePath, 'utf8'),\n        modified: fs.statSync(filePath).mtimeMs\n      };\n    } catch (_) {} // eslint-disable-line no-empty\n\n  }\n\n  return null;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 154,
      "endLine": 154,
      "before": "() => {\n  const srcPaths = ['a', 'b', 'c'];\n  lumo.addSourcePaths(srcPaths);\n  const lumoPaths = [process.cwd(), ...srcPaths];\n  fs.readFileSync = jest.fn((filename: string) => {\n    throw new Error(`file doesn't exist: ${filename}`);\n  });\n  const source = lumo.readSource('bar/baz');\n  const mockCalls = fs.readFileSync.mock.calls;\n  expect(source).toBe(null);\n  expect(mockCalls.map((x: string[]) => x[0]).filter((x: string) => new Set(lumoPaths.map((p: string) => path.join(p, 'bar/baz'))).has(x))).toEqual(lumoPaths.map((p: string) => path.join(p, 'bar/baz')));\n}",
      "after": "async () => {\n  const srcPaths = ['a', 'b', 'c'];\n  lumo.addSourcePaths(srcPaths);\n  const lumoPaths = [process.cwd(), ...srcPaths];\n  fs.readFileSync = jest.fn((filename: string) => {\n    throw new Error(`file doesn't exist: ${filename}`);\n  });\n  const source = await lumo.readSource('bar/baz');\n  const mockCalls = fs.readFileSync.mock.calls;\n  expect(source).toBe(null);\n  expect(mockCalls.map((x: string[]) => x[0]).filter((x: string) => new Set(lumoPaths.map((p: string) => path.join(p, 'bar/baz'))).has(x))).toEqual(lumoPaths.map((p: string) => path.join(p, 'bar/baz')));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 174,
      "endLine": 174,
      "before": "() => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = lumo.readSource('some/thing');\n  expect(source).toEqual({\n    source: 'zipContents',\n    modified: expect.any(Number)\n  });\n}",
      "after": "async () => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = await lumo.readSource('some/thing');\n  expect(source).toEqual({\n    source: 'zipContents',\n    modified: expect.any(Number)\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 183,
      "endLine": 183,
      "before": "() => {\n  const source = lumo.readSource('some/thing');\n  expect(source).toBe(null);\n}",
      "after": "async () => {\n  const source = await lumo.readSource('some/thing');\n  expect(source).toBe(null);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 250,
      "endLine": 250,
      "before": "function loadUpstreamJsLibs(): string[] {\n  const ret = []; // $FlowIssue: getters not supported\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    try {\n      if (srcPath.endsWith('.jar')) {\n        const data = fs.readFileSync(srcPath);\n        const zip = new JSZip().load(data);\n        const source = zip.file('deps.cljs');\n\n        if (source != null) {\n          ret.push(source.asText());\n        }\n      } else {\n        const source = fs.readFileSync(path.join(srcPath, 'deps.cljs'), 'utf8');\n        ret.push(source);\n      }\n    } catch (_) {} // eslint-disable-line no-empty\n\n  }\n\n  return ret;\n}",
      "after": "async function loadUpstreamJsLibs(): string[] {\n  const ret = []; // $FlowIssue: getters not supported\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    try {\n      if (srcPath.endsWith('.jar')) {\n        const data = fs.readFileSync(srcPath);\n        const zip = await new JSZip().load(data);\n        const source = zip.file('deps.cljs');\n\n        if (source != null) {\n          ret.push(source.asText());\n        }\n      } else {\n        const source = fs.readFileSync(path.join(srcPath, 'deps.cljs'), 'utf8');\n        ret.push(source);\n      }\n    } catch (_) {} // eslint-disable-line no-empty\n\n  }\n\n  return ret;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 200,
      "endLine": 200,
      "before": "() => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual(['zipContents']);\n}",
      "after": "async () => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = await lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual(['zipContents']);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 206,
      "endLine": 206,
      "before": "() => {\n  const source = lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual([]);\n}",
      "after": "async () => {\n  const source = await lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual([]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 215,
      "endLine": 215,
      "before": "() => {\n  const srcPaths = ['bar.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual([]);\n}",
      "after": "async () => {\n  const srcPaths = ['bar.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = await lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual([]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 275,
      "endLine": 275,
      "before": "function loadUpstreamDataReaders(): {\n  url: string,\n  source: string,\n}[] {\n  const ret = []; // $FlowIssue: getters not supported\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    for (const filename of ['data_readers.cljs', 'data_readers.cljc']) {\n      const url = path.join(srcPath, filename);\n\n      try {\n        if (srcPath.endsWith('.jar')) {\n          const data = fs.readFileSync(srcPath);\n          const zip = new JSZip().load(data);\n          const source = zip.file(filename);\n\n          if (source != null) {\n            ret.push({\n              url,\n              source: source.asText()\n            });\n          }\n        } else {\n          const source = fs.readFileSync(url, 'utf8');\n          ret.push({\n            url,\n            source\n          });\n        }\n      } catch (_) {} // eslint-disable-line no-empty\n\n    }\n  }\n\n  return ret;\n}",
      "after": "async function loadUpstreamDataReaders(): {\n  url: string,\n  source: string,\n}[] {\n  const ret = []; // $FlowIssue: getters not supported\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    for (const filename of ['data_readers.cljs', 'data_readers.cljc']) {\n      const url = path.join(srcPath, filename);\n\n      try {\n        if (srcPath.endsWith('.jar')) {\n          const data = fs.readFileSync(srcPath);\n          const zip = await new JSZip().load(data);\n          const source = zip.file(filename);\n\n          if (source != null) {\n            ret.push({\n              url,\n              source: source.asText()\n            });\n          }\n        } else {\n          const source = fs.readFileSync(url, 'utf8');\n          ret.push({\n            url,\n            source\n          });\n        }\n      } catch (_) {} // eslint-disable-line no-empty\n\n    }\n  }\n\n  return ret;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 309,
      "endLine": 309,
      "before": "function resource(filename: string): ?ResourceType {\n  if (isBundled(filename)) {\n    return {\n      type: 'bundled',\n      src: filename\n    };\n  } // $FlowIssue: getters not supported\n\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    if (srcPath.endsWith('.jar')) {\n      const data = fs.readFileSync(srcPath);\n      const zip = new JSZip().load(data);\n      const entries = zip.filter((pathInJar: string) => pathInJar === filename);\n\n      if (entries.length > 0) {\n        const entry = entries[0];\n        return {\n          type: 'jar',\n          jarPath: path.resolve(srcPath),\n          src: filename,\n          modified: entry.date.getTime()\n        };\n      }\n    }\n\n    if (fs.existsSync(path.join(srcPath, filename))) {\n      return {\n        type: 'file',\n        src: path.resolve(srcPath, filename)\n      };\n    }\n  }\n\n  return null;\n}",
      "after": "async function resource(filename: string): ?ResourceType {\n  if (isBundled(filename)) {\n    return {\n      type: 'bundled',\n      src: filename\n    };\n  } // $FlowIssue: getters not supported\n\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    if (srcPath.endsWith('.jar')) {\n      const data = fs.readFileSync(srcPath);\n      const zip = await new JSZip().load(data);\n      const entries = zip.filter((pathInJar: string) => pathInJar === filename);\n\n      if (entries.length > 0) {\n        const entry = entries[0];\n        return {\n          type: 'jar',\n          jarPath: path.resolve(srcPath),\n          src: filename,\n          modified: entry.date.getTime()\n        };\n      }\n    }\n\n    if (fs.existsSync(path.join(srcPath, filename))) {\n      return {\n        type: 'file',\n        src: path.resolve(srcPath, filename)\n      };\n    }\n  }\n\n  return null;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 241,
      "endLine": 241,
      "before": "() => {\n  const srcPaths = ['a', 'b', 'c'];\n  lumo.addSourcePaths(srcPaths);\n  const lumoPaths = [process.cwd(), ...srcPaths];\n  fs.existsSync = jest.fn((_: string) => false);\n  const exists = lumo.resource('bar/baz');\n  const mockCalls = fs.existsSync.mock.calls;\n  expect(exists).toBe(null);\n  expect(fs.existsSync).toHaveBeenCalledTimes(5);\n  expect(mockCalls.map((x: string[]) => x[0])).toEqual(['./target/bar/baz'].concat(lumoPaths.map((p: string) => path.join(p, 'bar/baz'))));\n}",
      "after": "async () => {\n  const srcPaths = ['a', 'b', 'c'];\n  lumo.addSourcePaths(srcPaths);\n  const lumoPaths = [process.cwd(), ...srcPaths];\n  fs.existsSync = jest.fn((_: string) => false);\n  const exists = await lumo.resource('bar/baz');\n  const mockCalls = fs.existsSync.mock.calls;\n  expect(exists).toBe(null);\n  expect(fs.existsSync).toHaveBeenCalledTimes(5);\n  expect(mockCalls.map((x: string[]) => x[0])).toEqual(['./target/bar/baz'].concat(lumoPaths.map((p: string) => path.join(p, 'bar/baz'))));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 255,
      "endLine": 255,
      "before": "() => {\n  fs.existsSync = jest.fn((_: string) => true);\n  expect(lumo.resource('some-file')).toEqual({\n    type: 'bundled',\n    src: 'some-file'\n  });\n}",
      "after": "async () => {\n  fs.existsSync = jest.fn((_: string) => true);\n  expect(await lumo.resource('some-file')).toEqual({\n    type: 'bundled',\n    src: 'some-file'\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 268,
      "endLine": 268,
      "before": "() => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  fs.existsSync = jest.fn((fname: string) => /foo/.test(fname));\n  expect(lumo.resource('some/thing')).toMatchObject({\n    type: 'jar',\n    src: 'some/thing'\n  });\n}",
      "after": "async () => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  fs.existsSync = jest.fn((fname: string) => /foo/.test(fname));\n  expect(await lumo.resource('some/thing')).toMatchObject({\n    type: 'jar',\n    src: 'some/thing'\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 275,
      "endLine": 275,
      "before": "() => {\n  expect(lumo.resource('some/thing')).toBe(null);\n}",
      "after": "async () => {\n  expect(await lumo.resource('some/thing')).toBe(null);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 360,
      "endLine": 360,
      "before": "function readSourceFromJar({\n  jarPath,\n  src\n}: {\n  type: string,\n  jarPath: string,\n  src: string,\n}): string {\n  const data = fs.readFileSync(jarPath);\n  const zip = new JSZip().load(data);\n  const source = zip.file(src);\n  return source.asText();\n}",
      "after": "async function readSourceFromJar({\n  jarPath,\n  src\n}: {\n  type: string,\n  jarPath: string,\n  src: string,\n}): string {\n  const data = fs.readFileSync(jarPath);\n  const zip = await new JSZip().load(data);\n  const source = zip.file(src);\n  return source.asText();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 368,
      "endLine": 368,
      "before": "function readDirFromJar(jarPath: string, dir: string): string[] {\n  const data = fs.readFileSync(jarPath);\n  const zip = new JSZip().load(data);\n  return zip.file(new RegExp(`^${dir}`)).map((x: {\n    name: string\n  }) => x.name);\n}",
      "after": "async function readDirFromJar(jarPath: string, dir: string): string[] {\n  const data = fs.readFileSync(jarPath);\n  const zip = await new JSZip().load(data);\n  return zip.file(new RegExp(`^${dir}`)).map((x: {\n    name: string\n  }) => x.name);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 383,
      "endLine": 383,
      "before": "(res: string) => {\n  const idx = res.lastIndexOf('/');\n\n  if (idx !== -1) {\n    util.ensureDir(path.join(outdir, res.slice(0, idx)));\n  } // $FlowFixMe: need to check result of res, but bundled resources will be\n\n\n  fs.writeFileSync(path.join(outdir, res), load(res), 'utf8');\n}",
      "after": "async (res: string) => {\n  const idx = res.lastIndexOf('/');\n\n  if (idx !== -1) {\n    util.ensureDir(path.join(outdir, res.slice(0, idx)));\n  } // $FlowFixMe: need to check result of res, but bundled resources will be\n\n\n  fs.writeFileSync(path.join(outdir, res), await load(res), 'utf8');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 375,
      "endLine": 384,
      "before": "function dumpSDK(outdir: string): void {\n  if (!__DEV__) {\n    lumo.internal.embedded.keys().forEach((res: string) => {\n      const idx = res.lastIndexOf('/');\n\n      if (idx !== -1) {\n        util.ensureDir(path.join(outdir, res.slice(0, idx)));\n      } // $FlowFixMe: need to check result of res, but bundled resources will be\n\n\n      fs.writeFileSync(path.join(outdir, res), load(res), 'utf8');\n    });\n  }\n}",
      "after": "async function dumpSDK(outdir: string): void {\n  if (!__DEV__) {\n    await lumo.internal.embedded.keys().forEach(async (res: string) => {\n      const idx = res.lastIndexOf('/');\n\n      if (idx !== -1) {\n        util.ensureDir(path.join(outdir, res.slice(0, idx)));\n      } // $FlowFixMe: need to check result of res, but bundled resources will be\n\n\n      fs.writeFileSync(path.join(outdir, res), await load(res), 'utf8');\n    });\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cli.js",
      "startLine": 298,
      "endLine": 298,
      "before": "function startCLI(): mixed {\n  const opts = getCLIOpts();\n  const {\n    args,\n    cache,\n    classpath,\n    dependencies,\n    unrecognized,\n    help,\n    legal,\n    mainNsName,\n    mainScript,\n    quiet,\n    scripts,\n    version\n  } = opts;\n  const autoCache = opts['auto-cache'];\n  const localRepo = opts['local-repo'];\n  const dumpSDK = opts['dump-sdk']; // if help, print help and bail\n\n  if (help) {\n    printHelp();\n    return process.exit(unrecognized ? 1 : 0);\n  }\n\n  if (version) {\n    return printVersion();\n  }\n\n  if (legal) {\n    return printLegal();\n  }\n\n  if (dumpSDK != null) {\n    return lumo.dumpSDK(dumpSDK);\n  }\n\n  v8.setFlagsFromString('--use_strict');\n\n  if (scripts.length === 0 && !mainNsName && !mainScript && args.length === 0) {\n    opts.repl = true;\n  }\n\n  if (cache || autoCache) {\n    const cachePath = cache || '.lumo_cache';\n    util.ensureDir(cachePath);\n    opts.cache = cachePath;\n  } // TODO: print classpath to stdout if `:verbose`\n\n\n  if (classpath.length !== 0) {\n    // if (verbose) {\n    //   console.log(`Classpath resolves to: `);\n    // }\n    const srcPaths = util.srcPathsFromClasspathStrings(classpath);\n    opts.classpath = srcPaths;\n    lumo.addSourcePaths(srcPaths);\n  }\n\n  if (dependencies.length !== 0) {\n    const mvnPaths = util.srcPathsFromMavenDependencies(dependencies, localRepo);\n    opts.classpath.push(...mvnPaths);\n    lumo.addSourcePaths(mvnPaths);\n  }\n\n  if (opts.repl && !quiet) {\n    printBanner();\n  }\n\n  return startClojureScriptEngine(opts);\n}",
      "after": "async function startCLI(): mixed {\n  const opts = getCLIOpts();\n  const {\n    args,\n    cache,\n    classpath,\n    dependencies,\n    unrecognized,\n    help,\n    legal,\n    mainNsName,\n    mainScript,\n    quiet,\n    scripts,\n    version\n  } = opts;\n  const autoCache = opts['auto-cache'];\n  const localRepo = opts['local-repo'];\n  const dumpSDK = opts['dump-sdk']; // if help, print help and bail\n\n  if (help) {\n    printHelp();\n    return process.exit(unrecognized ? 1 : 0);\n  }\n\n  if (version) {\n    return printVersion();\n  }\n\n  if (legal) {\n    return printLegal();\n  }\n\n  if (dumpSDK != null) {\n    return await lumo.dumpSDK(dumpSDK);\n  }\n\n  v8.setFlagsFromString('--use_strict');\n\n  if (scripts.length === 0 && !mainNsName && !mainScript && args.length === 0) {\n    opts.repl = true;\n  }\n\n  if (cache || autoCache) {\n    const cachePath = cache || '.lumo_cache';\n    util.ensureDir(cachePath);\n    opts.cache = cachePath;\n  } // TODO: print classpath to stdout if `:verbose`\n\n\n  if (classpath.length !== 0) {\n    // if (verbose) {\n    //   console.log(`Classpath resolves to: `);\n    // }\n    const srcPaths = util.srcPathsFromClasspathStrings(classpath);\n    opts.classpath = srcPaths;\n    lumo.addSourcePaths(srcPaths);\n  }\n\n  if (dependencies.length !== 0) {\n    const mvnPaths = util.srcPathsFromMavenDependencies(dependencies, localRepo);\n    opts.classpath.push(...mvnPaths);\n    lumo.addSourcePaths(mvnPaths);\n  }\n\n  if (opts.repl && !quiet) {\n    await printBanner();\n  }\n\n  return await startClojureScriptEngine(opts);\n}"
    }
  ],
  "11": [
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 192,
      "endLine": 192,
      "before": "function readSource(filename: string): ?SourceType {\n  // $FlowIssue: getters not supported\n  for (const srcPath of sourcePaths.paths.values()) {\n    try {\n      if (srcPath.endsWith('.jar')) {\n        const data = fs.readFileSync(srcPath);\n        const zip = new JSZip().load(data);\n        const file = zip.file(filename);\n\n        if (file != null) {\n          return {\n            source: file.asText(),\n            modified: file.date.getTime()\n          };\n        }\n      }\n\n      const filePath = path.join(srcPath, filename);\n      return {\n        source: fs.readFileSync(filePath, 'utf8'),\n        modified: fs.statSync(filePath).mtimeMs\n      };\n    } catch (_) {} // eslint-disable-line no-empty\n\n  }\n\n  return null;\n}",
      "after": "async function readSource(filename: string): ?SourceType {\n  // $FlowIssue: getters not supported\n  for (const srcPath of sourcePaths.paths.values()) {\n    try {\n      if (srcPath.endsWith('.jar')) {\n        const data = await fs.promises.readFile(srcPath);\n        const zip = await new JSZip().load(data);\n        const file = zip.file(filename);\n\n        if (file != null) {\n          return {\n            source: file.asText(),\n            modified: file.date.getTime()\n          };\n        }\n      }\n\n      const filePath = path.join(srcPath, filename);\n      return {\n        source: fs.readFileSync(filePath, 'utf8'),\n        modified: fs.statSync(filePath).mtimeMs\n      };\n    } catch (_) {} // eslint-disable-line no-empty\n\n  }\n\n  return null;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 154,
      "endLine": 154,
      "before": "() => {\n  const srcPaths = ['a', 'b', 'c'];\n  lumo.addSourcePaths(srcPaths);\n  const lumoPaths = [process.cwd(), ...srcPaths];\n  fs.readFileSync = jest.fn((filename: string) => {\n    throw new Error(`file doesn't exist: ${filename}`);\n  });\n  const source = lumo.readSource('bar/baz');\n  const mockCalls = fs.readFileSync.mock.calls;\n  expect(source).toBe(null);\n  expect(mockCalls.map((x: string[]) => x[0]).filter((x: string) => new Set(lumoPaths.map((p: string) => path.join(p, 'bar/baz'))).has(x))).toEqual(lumoPaths.map((p: string) => path.join(p, 'bar/baz')));\n}",
      "after": "async () => {\n  const srcPaths = ['a', 'b', 'c'];\n  lumo.addSourcePaths(srcPaths);\n  const lumoPaths = [process.cwd(), ...srcPaths];\n  fs.readFileSync = jest.fn((filename: string) => {\n    throw new Error(`file doesn't exist: ${filename}`);\n  });\n  const source = await lumo.readSource('bar/baz');\n  const mockCalls = fs.readFileSync.mock.calls;\n  expect(source).toBe(null);\n  expect(mockCalls.map((x: string[]) => x[0]).filter((x: string) => new Set(lumoPaths.map((p: string) => path.join(p, 'bar/baz'))).has(x))).toEqual(lumoPaths.map((p: string) => path.join(p, 'bar/baz')));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 174,
      "endLine": 174,
      "before": "() => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = lumo.readSource('some/thing');\n  expect(source).toEqual({\n    source: 'zipContents',\n    modified: expect.any(Number)\n  });\n}",
      "after": "async () => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = await lumo.readSource('some/thing');\n  expect(source).toEqual({\n    source: 'zipContents',\n    modified: expect.any(Number)\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 183,
      "endLine": 183,
      "before": "() => {\n  const source = lumo.readSource('some/thing');\n  expect(source).toBe(null);\n}",
      "after": "async () => {\n  const source = await lumo.readSource('some/thing');\n  expect(source).toBe(null);\n}"
    }
  ],
  "12": [
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 205,
      "endLine": 205,
      "before": "function readSource(filename: string): ?SourceType {\n  // $FlowIssue: getters not supported\n  for (const srcPath of sourcePaths.paths.values()) {\n    try {\n      if (srcPath.endsWith('.jar')) {\n        const data = fs.readFileSync(srcPath);\n        const zip = new JSZip().load(data);\n        const file = zip.file(filename);\n\n        if (file != null) {\n          return {\n            source: file.asText(),\n            modified: file.date.getTime()\n          };\n        }\n      }\n\n      const filePath = path.join(srcPath, filename);\n      return {\n        source: fs.readFileSync(filePath, 'utf8'),\n        modified: fs.statSync(filePath).mtimeMs\n      };\n    } catch (_) {} // eslint-disable-line no-empty\n\n  }\n\n  return null;\n}",
      "after": "async function readSource(filename: string): ?SourceType {\n  // $FlowIssue: getters not supported\n  for (const srcPath of sourcePaths.paths.values()) {\n    try {\n      if (srcPath.endsWith('.jar')) {\n        const data = await fs.promises.readFile(srcPath);\n        const zip = await new JSZip().load(data);\n        const file = zip.file(filename);\n\n        if (file != null) {\n          return {\n            source: file.asText(),\n            modified: file.date.getTime()\n          };\n        }\n      }\n\n      const filePath = path.join(srcPath, filename);\n      return {\n        source: await fs.promises.readFile(filePath, 'utf8'),\n        modified: fs.statSync(filePath).mtimeMs\n      };\n    } catch (_) {} // eslint-disable-line no-empty\n\n  }\n\n  return null;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 154,
      "endLine": 154,
      "before": "() => {\n  const srcPaths = ['a', 'b', 'c'];\n  lumo.addSourcePaths(srcPaths);\n  const lumoPaths = [process.cwd(), ...srcPaths];\n  fs.readFileSync = jest.fn((filename: string) => {\n    throw new Error(`file doesn't exist: ${filename}`);\n  });\n  const source = lumo.readSource('bar/baz');\n  const mockCalls = fs.readFileSync.mock.calls;\n  expect(source).toBe(null);\n  expect(mockCalls.map((x: string[]) => x[0]).filter((x: string) => new Set(lumoPaths.map((p: string) => path.join(p, 'bar/baz'))).has(x))).toEqual(lumoPaths.map((p: string) => path.join(p, 'bar/baz')));\n}",
      "after": "async () => {\n  const srcPaths = ['a', 'b', 'c'];\n  lumo.addSourcePaths(srcPaths);\n  const lumoPaths = [process.cwd(), ...srcPaths];\n  fs.readFileSync = jest.fn((filename: string) => {\n    throw new Error(`file doesn't exist: ${filename}`);\n  });\n  const source = await lumo.readSource('bar/baz');\n  const mockCalls = fs.readFileSync.mock.calls;\n  expect(source).toBe(null);\n  expect(mockCalls.map((x: string[]) => x[0]).filter((x: string) => new Set(lumoPaths.map((p: string) => path.join(p, 'bar/baz'))).has(x))).toEqual(lumoPaths.map((p: string) => path.join(p, 'bar/baz')));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 174,
      "endLine": 174,
      "before": "() => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = lumo.readSource('some/thing');\n  expect(source).toEqual({\n    source: 'zipContents',\n    modified: expect.any(Number)\n  });\n}",
      "after": "async () => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = await lumo.readSource('some/thing');\n  expect(source).toEqual({\n    source: 'zipContents',\n    modified: expect.any(Number)\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 183,
      "endLine": 183,
      "before": "() => {\n  const source = lumo.readSource('some/thing');\n  expect(source).toBe(null);\n}",
      "after": "async () => {\n  const source = await lumo.readSource('some/thing');\n  expect(source).toBe(null);\n}"
    }
  ],
  "13": [
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 216,
      "endLine": 216,
      "before": "function readFile(filename: string): ?SourceType {\n  try {\n    return {\n      source: fs.readFileSync(filename, 'utf8'),\n      modified: fs.statSync(filename).mtimeMs\n    };\n  } catch (_) {} // eslint-disable-line no-empty\n\n\n  return null;\n}",
      "after": "async function readFile(filename: string): ?SourceType {\n  try {\n    return {\n      source: await fs.promises.readFile(filename, 'utf8'),\n      modified: fs.statSync(filename).mtimeMs\n    };\n  } catch (_) {} // eslint-disable-line no-empty\n\n\n  return null;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 946,
      "endLine": 1070,
      "before": "/**\n * Patch flags.cc from deps/v8/src to use hard-coded flags.\n * this function is very closely ready to accept custom injection code.\n **/\nfunction _monkeyPatchv8FlagsCc(compiler, options, complete) {\n  var mainPath = path.join(compiler.dir, 'deps/v8/src', 'flags.cc');\n  fs.readFile(mainPath, {\n    encoding: 'utf8'\n  }, function (err, contents) {\n    if (err) {\n      return _log('error', 'failed to read', mainPath);\n    } // Super simple injection here. Perhaps make it an array at somepoint?\n\n\n    var injection = '\\\nconst char* nexevargs = \"{{args}}\";\\n\\\nint nexevargslen = strlen(nexevargs);\\n\\\nSetFlagsFromString(nexevargs, nexevargslen);\\n\\\n';\n    var injectionSplit = injection.split('\\n');\n    var injectionLength = injectionSplit.length;\n    var contentsSplit = contents.split('\\n');\n    var contentsLength = contentsSplit.length;\n    var lastInjectionLine = injectionSplit[injectionLength - 2];\n    var lineToInjectAfter = contentsSplit.indexOf('  ComputeFlagListHash();');\n    var haveWeInjectedBefore = contentsSplit.indexOf(lastInjectionLine);\n    var lineInjectDifference = contentsLength - lineToInjectAfter; // support for 0.12.x\n\n    if (lineToInjectAfter === -1) {\n      _log('warn', 'Using an expiramental support patch for 0.12.x');\n\n      lineToInjectAfter = contentsSplit.indexOf('#undef FLAG_MODE_DEFINE_IMPLICATIONS');\n    } // support for 0.10.x\n\n\n    if (lineToInjectAfter === -1) {\n      _log('warn', '0.12.x patch failed. Trying 0.10.0 patch');\n\n      lineToInjectAfter = contentsSplit.indexOf('#define FLAG_MODE_DEFINE_IMPLICATIONS') + 1;\n    } // this is debug, comment out.\n    // _log('v8 injection is', injectionLength, 'newlines long');\n    // _log('v8 flags source is', contentsLength, 'newlines long');\n    // console.log(finalContents)\n\n\n    var finalContents, dontCombine;\n\n    if (lineToInjectAfter !== -1 && haveWeInjectedBefore === -1) {\n      _log('injecting v8/flags.cc'); // super debug\n      // _log('v8 injection determined by', lastInjectionLine);\n      // _log('v8 inject after line', lineToInjectAfter);\n      // _log('v8 inject needs to shift', lineInjectDifference, 'amount of lines by', injectionLength);\n      // compute out the amount of space we'll need in this.\n\n\n      var startShiftLine = contentsLength - 1; // minus one to make up for 0 arg line.\n\n      var endShiftLine = lineToInjectAfter;\n      var injectRoom = injectionLength - 1;\n      injectionSplit[0] = injectionSplit[0].replace('{{args}}', options.jsFlags);\n\n      for (var i = startShiftLine; i !== endShiftLine; i--) {\n        contentsSplit[i + injectRoom] = contentsSplit[i];\n        contentsSplit[i] = '';\n      }\n\n      var injectionPos = 0;\n\n      for (var i = 0; i !== injectionLength - 1; i++) {\n        contentsSplit[lineToInjectAfter + 1 + injectionPos] = injectionSplit[injectionPos];\n        injectionPos++;\n      }\n    } else if (lineToInjectAfter !== -1 && haveWeInjectedBefore !== -1) {\n      _log('re-injecting v8 args');\n\n      dontCombine = true;\n      finalContents = contentsSplit.join('\\n');\n      finalContents = finalContents.replace(/const char\\* nexevargs = \"[A-Z\\-\\_]*\";/gi, 'const char* nexevargs = \"' + options.jsFlags + '\";');\n    } else {\n      _log('error', 'failed to find a suitable injection point for v8 args.', 'File a bug report with the node version and log.');\n\n      _log('lineToInjectAfter=' + lineToInjectAfter, 'haveWeInjectedBefore=' + haveWeInjectedBefore);\n\n      return process.exit(1);\n    }\n\n    if (!dontCombine) {\n      finalContents = contentsSplit.join('\\n');\n    } // write the file contents\n\n\n    fs.writeFile(mainPath, finalContents, {\n      encoding: 'utf8'\n    }, function (err) {\n      if (err) {\n        _log('error', 'failed to write to', mainPath);\n\n        return process.exit(1);\n      }\n\n      return complete();\n    });\n  });\n}\n/**\n * Get the first directory of a string.\n */",
      "after": "/**\n * Patch flags.cc from deps/v8/src to use hard-coded flags.\n * this function is very closely ready to accept custom injection code.\n **/\nasync function _monkeyPatchv8FlagsCc(compiler, options, complete) {\n  var mainPath = path.join(compiler.dir, 'deps/v8/src', 'flags.cc');\n  await fs.readFile(mainPath, {\n    encoding: 'utf8'\n  }, function (err, contents) {\n    if (err) {\n      return _log('error', 'failed to read', mainPath);\n    } // Super simple injection here. Perhaps make it an array at somepoint?\n\n\n    var injection = '\\\nconst char* nexevargs = \"{{args}}\";\\n\\\nint nexevargslen = strlen(nexevargs);\\n\\\nSetFlagsFromString(nexevargs, nexevargslen);\\n\\\n';\n    var injectionSplit = injection.split('\\n');\n    var injectionLength = injectionSplit.length;\n    var contentsSplit = contents.split('\\n');\n    var contentsLength = contentsSplit.length;\n    var lastInjectionLine = injectionSplit[injectionLength - 2];\n    var lineToInjectAfter = contentsSplit.indexOf('  ComputeFlagListHash();');\n    var haveWeInjectedBefore = contentsSplit.indexOf(lastInjectionLine);\n    var lineInjectDifference = contentsLength - lineToInjectAfter; // support for 0.12.x\n\n    if (lineToInjectAfter === -1) {\n      _log('warn', 'Using an expiramental support patch for 0.12.x');\n\n      lineToInjectAfter = contentsSplit.indexOf('#undef FLAG_MODE_DEFINE_IMPLICATIONS');\n    } // support for 0.10.x\n\n\n    if (lineToInjectAfter === -1) {\n      _log('warn', '0.12.x patch failed. Trying 0.10.0 patch');\n\n      lineToInjectAfter = contentsSplit.indexOf('#define FLAG_MODE_DEFINE_IMPLICATIONS') + 1;\n    } // this is debug, comment out.\n    // _log('v8 injection is', injectionLength, 'newlines long');\n    // _log('v8 flags source is', contentsLength, 'newlines long');\n    // console.log(finalContents)\n\n\n    var finalContents, dontCombine;\n\n    if (lineToInjectAfter !== -1 && haveWeInjectedBefore === -1) {\n      _log('injecting v8/flags.cc'); // super debug\n      // _log('v8 injection determined by', lastInjectionLine);\n      // _log('v8 inject after line', lineToInjectAfter);\n      // _log('v8 inject needs to shift', lineInjectDifference, 'amount of lines by', injectionLength);\n      // compute out the amount of space we'll need in this.\n\n\n      var startShiftLine = contentsLength - 1; // minus one to make up for 0 arg line.\n\n      var endShiftLine = lineToInjectAfter;\n      var injectRoom = injectionLength - 1;\n      injectionSplit[0] = injectionSplit[0].replace('{{args}}', options.jsFlags);\n\n      for (var i = startShiftLine; i !== endShiftLine; i--) {\n        contentsSplit[i + injectRoom] = contentsSplit[i];\n        contentsSplit[i] = '';\n      }\n\n      var injectionPos = 0;\n\n      for (var i = 0; i !== injectionLength - 1; i++) {\n        contentsSplit[lineToInjectAfter + 1 + injectionPos] = injectionSplit[injectionPos];\n        injectionPos++;\n      }\n    } else if (lineToInjectAfter !== -1 && haveWeInjectedBefore !== -1) {\n      _log('re-injecting v8 args');\n\n      dontCombine = true;\n      finalContents = contentsSplit.join('\\n');\n      finalContents = finalContents.replace(/const char\\* nexevargs = \"[A-Z\\-\\_]*\";/gi, 'const char* nexevargs = \"' + options.jsFlags + '\";');\n    } else {\n      _log('error', 'failed to find a suitable injection point for v8 args.', 'File a bug report with the node version and log.');\n\n      _log('lineToInjectAfter=' + lineToInjectAfter, 'haveWeInjectedBefore=' + haveWeInjectedBefore);\n\n      return process.exit(1);\n    }\n\n    if (!dontCombine) {\n      finalContents = contentsSplit.join('\\n');\n    } // write the file contents\n\n\n    fs.writeFile(mainPath, finalContents, {\n      encoding: 'utf8'\n    }, function (err) {\n      if (err) {\n        _log('error', 'failed to write to', mainPath);\n\n        return process.exit(1);\n      }\n\n      return complete();\n    });\n  });\n}\n/**\n * Get the first directory of a string.\n */"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 233,
      "endLine": 233,
      "before": "function monkeyPatchv8FlagsCc(next) {\n  if (options.jsFlags) {\n    return _monkeyPatchv8FlagsCc(nodeCompiler, options, next);\n  }\n\n  return next();\n}",
      "after": "async function monkeyPatchv8FlagsCc(next) {\n  if (options.jsFlags) {\n    return await _monkeyPatchv8FlagsCc(nodeCompiler, options, next);\n  }\n\n  return next();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/monkeypatch.js",
      "startLine": 43,
      "endLine": 43,
      "before": "function read(next) {\n  fs.readFile(filePath, 'utf8', next);\n}",
      "after": "async function read(next) {\n  await fs.readFile(filePath, 'utf8', next);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 766,
      "endLine": 782,
      "before": "/**\n * patch the gyp file to allow our custom includes\n */\nfunction _monkeyPatchGyp(compiler, options, complete) {\n  const hasNexeres = options.resourceFiles.length > 0;\n  const gypPath = path.join(compiler.dir, 'node.gyp');\n  let replacementString = \"'lib/fs.js', 'lib/_third_party_main.js', \";\n\n  if (hasNexeres) {\n    replacementString += \"'lib/nexeres.js', \";\n  }\n\n  _monkeypatch(gypPath, function (content) {\n    return ~content.indexOf('lib/_third_party_main.js');\n  }, function (content, next) {\n    content = content.replace(\"'lib/fs.js',\", replacementString);\n    content = content.replace(\"'deps/node-inspect/lib/internal/inspect_repl.js',\", `'deps/node-inspect/lib/internal/inspect_repl.js',\n      'google-closure-compiler-js.js',`);\n    next(null, content);\n  }, complete);\n}",
      "after": "/**\n * patch the gyp file to allow our custom includes\n */\nasync function _monkeyPatchGyp(compiler, options, complete) {\n  const hasNexeres = options.resourceFiles.length > 0;\n  const gypPath = path.join(compiler.dir, 'node.gyp');\n  let replacementString = \"'lib/fs.js', 'lib/_third_party_main.js', \";\n\n  if (hasNexeres) {\n    replacementString += \"'lib/nexeres.js', \";\n  }\n\n  await _monkeypatch(gypPath, function (content) {\n    return ~content.indexOf('lib/_third_party_main.js');\n  }, function (content, next) {\n    content = content.replace(\"'lib/fs.js',\", replacementString);\n    content = content.replace(\"'deps/node-inspect/lib/internal/inspect_repl.js',\", `'deps/node-inspect/lib/internal/inspect_repl.js',\n      'google-closure-compiler-js.js',`);\n    next(null, content);\n  }, complete);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 735,
      "endLine": 735,
      "before": "/**\n * monkeypatch the gyp file to include the nexe.js and nexeres.js files\n */\nfunction (next) {\n  _monkeyPatchGyp(compiler, options, next);\n}",
      "after": "/**\n * monkeypatch the gyp file to include the nexe.js and nexeres.js files\n */\nasync function (next) {\n  await _monkeyPatchGyp(compiler, options, next);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 217,
      "endLine": 217,
      "before": "/**\n * monkeypatch some files so that the nexe.js file is loaded when the app runs\n */\nfunction monkeyPatchNodeConfig(next) {\n  _monkeyPatchNodeConfig(nodeCompiler, next, options);\n}",
      "after": "/**\n * monkeypatch some files so that the nexe.js file is loaded when the app runs\n */\nasync function monkeyPatchNodeConfig(next) {\n  await _monkeyPatchNodeConfig(nodeCompiler, next, options);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 788,
      "endLine": 802,
      "before": "function patchNodeFlags(compiler, options, complete) {\n  const nodeCCPath = path.join(compiler.dir, 'src/node.cc');\n\n  _monkeypatch(nodeCCPath, function (content) {\n    return ~content.indexOf('//ProcessGlobalArgs');\n  }, function (content, next) {\n    const newContent = content.replace(/(?<!int )ProcessGlobalArgs\\(/g, '0;//ProcessGlobalArgs(');\n    next(null, newContent);\n  }, complete);\n}\n/**\n * patch the configure file to allow for custom startup snapshots\n */",
      "after": "async function patchNodeFlags(compiler, options, complete) {\n  const nodeCCPath = path.join(compiler.dir, 'src/node.cc');\n  await _monkeypatch(nodeCCPath, function (content) {\n    return ~content.indexOf('//ProcessGlobalArgs');\n  }, function (content, next) {\n    const newContent = content.replace(/(?<!int )ProcessGlobalArgs\\(/g, '0;//ProcessGlobalArgs(');\n    next(null, newContent);\n  }, complete);\n}\n/**\n * patch the configure file to allow for custom startup snapshots\n */"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 739,
      "endLine": 739,
      "before": "function (next) {\n  patchNodeFlags(compiler, options, next);\n}",
      "after": "async function (next) {\n  await patchNodeFlags(compiler, options, next);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 816,
      "endLine": 833,
      "before": "/**\n * patch the configure file to allow for custom startup snapshots\n */\nfunction _monkeyPatchConfigure(compiler, complete, options) {\n  var configurePath = path.join(compiler.dir, 'configure.py');\n  var snapshotPath = options.startupSnapshot;\n\n  if (snapshotPath != null) {\n    _log('monkey patching configure file');\n\n    snapshotPath = path.join(process.cwd(), snapshotPath);\n    return _monkeypatch(configurePath, function (content) {\n      return ~content.indexOf('v8_embed_script');\n    }, function (content, next) {\n      next(null, content.replace('def configure_v8(o):', `def configure_v8(o):\n  o['variables']['v8_embed_script'] = r'${snapshotPath}'\n  o['variables']['v8_warmup_script'] = r'${snapshotPath}'`));\n    }, complete);\n  } else {\n    _log('not  patching configure file');\n  }\n\n  return complete();\n}\n/**\n * Patch node.cc to not check the internal arguments.\n */",
      "after": "/**\n * patch the configure file to allow for custom startup snapshots\n */\nasync function _monkeyPatchConfigure(compiler, complete, options) {\n  var configurePath = path.join(compiler.dir, 'configure.py');\n  var snapshotPath = options.startupSnapshot;\n\n  if (snapshotPath != null) {\n    _log('monkey patching configure file');\n\n    snapshotPath = path.join(process.cwd(), snapshotPath);\n    return await _monkeypatch(configurePath, function (content) {\n      return ~content.indexOf('v8_embed_script');\n    }, function (content, next) {\n      next(null, content.replace('def configure_v8(o):', `def configure_v8(o):\n  o['variables']['v8_embed_script'] = r'${snapshotPath}'\n  o['variables']['v8_warmup_script'] = r'${snapshotPath}'`));\n    }, complete);\n  } else {\n    _log('not  patching configure file');\n  }\n\n  return complete();\n}\n/**\n * Patch node.cc to not check the internal arguments.\n */"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 746,
      "endLine": 746,
      "before": "/**\n * patch the configure file to allow for custom startup snapshots\n */\nfunction (next) {\n  _monkeyPatchConfigure(compiler, next, options);\n}",
      "after": "/**\n * patch the configure file to allow for custom startup snapshots\n */\nasync function (next) {\n  await _monkeyPatchConfigure(compiler, next, options);\n}"
    }
  ],
  "14": [
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 227,
      "endLine": 227,
      "before": "function readCache(filename: string): ?SourceType {\n  try {\n    return {\n      source: fs.readFileSync(filename, 'utf8'),\n      modified: fs.statSync(filename).mtimeMs\n    };\n  } catch (_) {\n    return null;\n  }\n}",
      "after": "async function readCache(filename: string): ?SourceType {\n  try {\n    return {\n      source: await fs.promises.readFile(filename, 'utf8'),\n      modified: fs.statSync(filename).mtimeMs\n    };\n  } catch (_) {\n    return null;\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 95,
      "endLine": 95,
      "before": "() => {\n  expect(lumo.readCache('foo')).toEqual({\n    source: 'fooContents',\n    modified: expect.any(Number)\n  });\n}",
      "after": "async () => {\n  expect(await lumo.readCache('foo')).toEqual({\n    source: 'fooContents',\n    modified: expect.any(Number)\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 102,
      "endLine": 102,
      "before": "() => {\n  expect(lumo.readCache('nonExistent')).toBe(null);\n}",
      "after": "async () => {\n  expect(await lumo.readCache('nonExistent')).toBe(null);\n}"
    }
  ],
  "15": [
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 237,
      "endLine": 237,
      "before": "function writeCache(filename: string, source: string): ?Error {\n  try {\n    return fs.writeFileSync(filename, source, 'utf8');\n  } catch (e) {\n    return e;\n  }\n}",
      "after": "async function writeCache(filename: string, source: string): ?Error {\n  try {\n    return await fs.promises.writeFile(filename, source, 'utf8');\n  } catch (e) {\n    return e;\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 124,
      "endLine": 124,
      "before": "() => {\n  expect(lumo.writeCache('foo', 'bar')).toBeUndefined();\n}",
      "after": "async () => {\n  expect(await lumo.writeCache('foo', 'bar')).toBeUndefined();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 128,
      "endLine": 128,
      "before": "() => {\n  expect(lumo.writeCache('nonExistent', 'contents')).toBeInstanceOf(Error);\n}",
      "after": "async () => {\n  expect(await lumo.writeCache('nonExistent', 'contents')).toBeInstanceOf(Error);\n}"
    }
  ],
  "16": [
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 249,
      "endLine": 249,
      "before": "function loadUpstreamJsLibs(): string[] {\n  const ret = []; // $FlowIssue: getters not supported\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    try {\n      if (srcPath.endsWith('.jar')) {\n        const data = fs.readFileSync(srcPath);\n        const zip = new JSZip().load(data);\n        const source = zip.file('deps.cljs');\n\n        if (source != null) {\n          ret.push(source.asText());\n        }\n      } else {\n        const source = fs.readFileSync(path.join(srcPath, 'deps.cljs'), 'utf8');\n        ret.push(source);\n      }\n    } catch (_) {} // eslint-disable-line no-empty\n\n  }\n\n  return ret;\n}",
      "after": "async function loadUpstreamJsLibs(): string[] {\n  const ret = []; // $FlowIssue: getters not supported\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    try {\n      if (srcPath.endsWith('.jar')) {\n        const data = await fs.promises.readFile(srcPath);\n        const zip = await new JSZip().load(data);\n        const source = zip.file('deps.cljs');\n\n        if (source != null) {\n          ret.push(source.asText());\n        }\n      } else {\n        const source = fs.readFileSync(path.join(srcPath, 'deps.cljs'), 'utf8');\n        ret.push(source);\n      }\n    } catch (_) {} // eslint-disable-line no-empty\n\n  }\n\n  return ret;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 200,
      "endLine": 200,
      "before": "() => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual(['zipContents']);\n}",
      "after": "async () => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = await lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual(['zipContents']);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 206,
      "endLine": 206,
      "before": "() => {\n  const source = lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual([]);\n}",
      "after": "async () => {\n  const source = await lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual([]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 215,
      "endLine": 215,
      "before": "() => {\n  const srcPaths = ['bar.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual([]);\n}",
      "after": "async () => {\n  const srcPaths = ['bar.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = await lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual([]);\n}"
    }
  ],
  "17": [
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 257,
      "endLine": 257,
      "before": "function loadUpstreamJsLibs(): string[] {\n  const ret = []; // $FlowIssue: getters not supported\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    try {\n      if (srcPath.endsWith('.jar')) {\n        const data = fs.readFileSync(srcPath);\n        const zip = new JSZip().load(data);\n        const source = zip.file('deps.cljs');\n\n        if (source != null) {\n          ret.push(source.asText());\n        }\n      } else {\n        const source = fs.readFileSync(path.join(srcPath, 'deps.cljs'), 'utf8');\n        ret.push(source);\n      }\n    } catch (_) {} // eslint-disable-line no-empty\n\n  }\n\n  return ret;\n}",
      "after": "async function loadUpstreamJsLibs(): string[] {\n  const ret = []; // $FlowIssue: getters not supported\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    try {\n      if (srcPath.endsWith('.jar')) {\n        const data = await fs.promises.readFile(srcPath);\n        const zip = await new JSZip().load(data);\n        const source = zip.file('deps.cljs');\n\n        if (source != null) {\n          ret.push(source.asText());\n        }\n      } else {\n        const source = await fs.promises.readFile(path.join(srcPath, 'deps.cljs'), 'utf8');\n        ret.push(source);\n      }\n    } catch (_) {} // eslint-disable-line no-empty\n\n  }\n\n  return ret;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 200,
      "endLine": 200,
      "before": "() => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual(['zipContents']);\n}",
      "after": "async () => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = await lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual(['zipContents']);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 206,
      "endLine": 206,
      "before": "() => {\n  const source = lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual([]);\n}",
      "after": "async () => {\n  const source = await lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual([]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 215,
      "endLine": 215,
      "before": "() => {\n  const srcPaths = ['bar.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual([]);\n}",
      "after": "async () => {\n  const srcPaths = ['bar.jar'];\n  lumo.addSourcePaths(srcPaths);\n  const source = await lumo.loadUpstreamJsLibs('some/thing');\n  expect(source).toEqual([]);\n}"
    }
  ],
  "18": [
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 274,
      "endLine": 274,
      "before": "function loadUpstreamDataReaders(): {\n  url: string,\n  source: string,\n}[] {\n  const ret = []; // $FlowIssue: getters not supported\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    for (const filename of ['data_readers.cljs', 'data_readers.cljc']) {\n      const url = path.join(srcPath, filename);\n\n      try {\n        if (srcPath.endsWith('.jar')) {\n          const data = fs.readFileSync(srcPath);\n          const zip = new JSZip().load(data);\n          const source = zip.file(filename);\n\n          if (source != null) {\n            ret.push({\n              url,\n              source: source.asText()\n            });\n          }\n        } else {\n          const source = fs.readFileSync(url, 'utf8');\n          ret.push({\n            url,\n            source\n          });\n        }\n      } catch (_) {} // eslint-disable-line no-empty\n\n    }\n  }\n\n  return ret;\n}",
      "after": "async function loadUpstreamDataReaders(): {\n  url: string,\n  source: string,\n}[] {\n  const ret = []; // $FlowIssue: getters not supported\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    for (const filename of ['data_readers.cljs', 'data_readers.cljc']) {\n      const url = path.join(srcPath, filename);\n\n      try {\n        if (srcPath.endsWith('.jar')) {\n          const data = await fs.promises.readFile(srcPath);\n          const zip = await new JSZip().load(data);\n          const source = zip.file(filename);\n\n          if (source != null) {\n            ret.push({\n              url,\n              source: source.asText()\n            });\n          }\n        } else {\n          const source = fs.readFileSync(url, 'utf8');\n          ret.push({\n            url,\n            source\n          });\n        }\n      } catch (_) {} // eslint-disable-line no-empty\n\n    }\n  }\n\n  return ret;\n}"
    }
  ],
  "19": [
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 285,
      "endLine": 285,
      "before": "function loadUpstreamDataReaders(): {\n  url: string,\n  source: string,\n}[] {\n  const ret = []; // $FlowIssue: getters not supported\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    for (const filename of ['data_readers.cljs', 'data_readers.cljc']) {\n      const url = path.join(srcPath, filename);\n\n      try {\n        if (srcPath.endsWith('.jar')) {\n          const data = fs.readFileSync(srcPath);\n          const zip = new JSZip().load(data);\n          const source = zip.file(filename);\n\n          if (source != null) {\n            ret.push({\n              url,\n              source: source.asText()\n            });\n          }\n        } else {\n          const source = fs.readFileSync(url, 'utf8');\n          ret.push({\n            url,\n            source\n          });\n        }\n      } catch (_) {} // eslint-disable-line no-empty\n\n    }\n  }\n\n  return ret;\n}",
      "after": "async function loadUpstreamDataReaders(): {\n  url: string,\n  source: string,\n}[] {\n  const ret = []; // $FlowIssue: getters not supported\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    for (const filename of ['data_readers.cljs', 'data_readers.cljc']) {\n      const url = path.join(srcPath, filename);\n\n      try {\n        if (srcPath.endsWith('.jar')) {\n          const data = await fs.promises.readFile(srcPath);\n          const zip = await new JSZip().load(data);\n          const source = zip.file(filename);\n\n          if (source != null) {\n            ret.push({\n              url,\n              source: source.asText()\n            });\n          }\n        } else {\n          const source = await fs.promises.readFile(url, 'utf8');\n          ret.push({\n            url,\n            source\n          });\n        }\n      } catch (_) {} // eslint-disable-line no-empty\n\n    }\n  }\n\n  return ret;\n}"
    }
  ],
  "20": [
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 308,
      "endLine": 308,
      "before": "function resource(filename: string): ?ResourceType {\n  if (isBundled(filename)) {\n    return {\n      type: 'bundled',\n      src: filename\n    };\n  } // $FlowIssue: getters not supported\n\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    if (srcPath.endsWith('.jar')) {\n      const data = fs.readFileSync(srcPath);\n      const zip = new JSZip().load(data);\n      const entries = zip.filter((pathInJar: string) => pathInJar === filename);\n\n      if (entries.length > 0) {\n        const entry = entries[0];\n        return {\n          type: 'jar',\n          jarPath: path.resolve(srcPath),\n          src: filename,\n          modified: entry.date.getTime()\n        };\n      }\n    }\n\n    if (fs.existsSync(path.join(srcPath, filename))) {\n      return {\n        type: 'file',\n        src: path.resolve(srcPath, filename)\n      };\n    }\n  }\n\n  return null;\n}",
      "after": "async function resource(filename: string): ?ResourceType {\n  if (isBundled(filename)) {\n    return {\n      type: 'bundled',\n      src: filename\n    };\n  } // $FlowIssue: getters not supported\n\n\n  for (const srcPath of sourcePaths.paths.values()) {\n    if (srcPath.endsWith('.jar')) {\n      const data = await fs.promises.readFile(srcPath);\n      const zip = await new JSZip().load(data);\n      const entries = zip.filter((pathInJar: string) => pathInJar === filename);\n\n      if (entries.length > 0) {\n        const entry = entries[0];\n        return {\n          type: 'jar',\n          jarPath: path.resolve(srcPath),\n          src: filename,\n          modified: entry.date.getTime()\n        };\n      }\n    }\n\n    if (fs.existsSync(path.join(srcPath, filename))) {\n      return {\n        type: 'file',\n        src: path.resolve(srcPath, filename)\n      };\n    }\n  }\n\n  return null;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 241,
      "endLine": 241,
      "before": "() => {\n  const srcPaths = ['a', 'b', 'c'];\n  lumo.addSourcePaths(srcPaths);\n  const lumoPaths = [process.cwd(), ...srcPaths];\n  fs.existsSync = jest.fn((_: string) => false);\n  const exists = lumo.resource('bar/baz');\n  const mockCalls = fs.existsSync.mock.calls;\n  expect(exists).toBe(null);\n  expect(fs.existsSync).toHaveBeenCalledTimes(5);\n  expect(mockCalls.map((x: string[]) => x[0])).toEqual(['./target/bar/baz'].concat(lumoPaths.map((p: string) => path.join(p, 'bar/baz'))));\n}",
      "after": "async () => {\n  const srcPaths = ['a', 'b', 'c'];\n  lumo.addSourcePaths(srcPaths);\n  const lumoPaths = [process.cwd(), ...srcPaths];\n  fs.existsSync = jest.fn((_: string) => false);\n  const exists = await lumo.resource('bar/baz');\n  const mockCalls = fs.existsSync.mock.calls;\n  expect(exists).toBe(null);\n  expect(fs.existsSync).toHaveBeenCalledTimes(5);\n  expect(mockCalls.map((x: string[]) => x[0])).toEqual(['./target/bar/baz'].concat(lumoPaths.map((p: string) => path.join(p, 'bar/baz'))));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 255,
      "endLine": 255,
      "before": "() => {\n  fs.existsSync = jest.fn((_: string) => true);\n  expect(lumo.resource('some-file')).toEqual({\n    type: 'bundled',\n    src: 'some-file'\n  });\n}",
      "after": "async () => {\n  fs.existsSync = jest.fn((_: string) => true);\n  expect(await lumo.resource('some-file')).toEqual({\n    type: 'bundled',\n    src: 'some-file'\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 268,
      "endLine": 268,
      "before": "() => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  fs.existsSync = jest.fn((fname: string) => /foo/.test(fname));\n  expect(lumo.resource('some/thing')).toMatchObject({\n    type: 'jar',\n    src: 'some/thing'\n  });\n}",
      "after": "async () => {\n  const srcPaths = ['foo.jar'];\n  lumo.addSourcePaths(srcPaths);\n  fs.existsSync = jest.fn((fname: string) => /foo/.test(fname));\n  expect(await lumo.resource('some/thing')).toMatchObject({\n    type: 'jar',\n    src: 'some/thing'\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/lumo-test.js",
      "startLine": 275,
      "endLine": 275,
      "before": "() => {\n  expect(lumo.resource('some/thing')).toBe(null);\n}",
      "after": "async () => {\n  expect(await lumo.resource('some/thing')).toBe(null);\n}"
    }
  ],
  "21": [
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 359,
      "endLine": 359,
      "before": "function readSourceFromJar({\n  jarPath,\n  src\n}: {\n  type: string,\n  jarPath: string,\n  src: string,\n}): string {\n  const data = fs.readFileSync(jarPath);\n  const zip = new JSZip().load(data);\n  const source = zip.file(src);\n  return source.asText();\n}",
      "after": "async function readSourceFromJar({\n  jarPath,\n  src\n}: {\n  type: string,\n  jarPath: string,\n  src: string,\n}): string {\n  const data = await fs.promises.readFile(jarPath);\n  const zip = await new JSZip().load(data);\n  const source = zip.file(src);\n  return source.asText();\n}"
    }
  ],
  "22": [
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 367,
      "endLine": 367,
      "before": "function readDirFromJar(jarPath: string, dir: string): string[] {\n  const data = fs.readFileSync(jarPath);\n  const zip = new JSZip().load(data);\n  return zip.file(new RegExp(`^${dir}`)).map((x: {\n    name: string\n  }) => x.name);\n}",
      "after": "async function readDirFromJar(jarPath: string, dir: string): string[] {\n  const data = await fs.promises.readFile(jarPath);\n  const zip = await new JSZip().load(data);\n  return zip.file(new RegExp(`^${dir}`)).map((x: {\n    name: string\n  }) => x.name);\n}"
    }
  ],
  "23": [
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 383,
      "endLine": 383,
      "before": "(res: string) => {\n  const idx = res.lastIndexOf('/');\n\n  if (idx !== -1) {\n    util.ensureDir(path.join(outdir, res.slice(0, idx)));\n  } // $FlowFixMe: need to check result of res, but bundled resources will be\n\n\n  fs.writeFileSync(path.join(outdir, res), load(res), 'utf8');\n}",
      "after": "async (res: string) => {\n  const idx = res.lastIndexOf('/');\n\n  if (idx !== -1) {\n    util.ensureDir(path.join(outdir, res.slice(0, idx)));\n  } // $FlowFixMe: need to check result of res, but bundled resources will be\n\n\n  await fs.promises.writeFile(path.join(outdir, res), await load(res), 'utf8');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/lumo.js",
      "startLine": 375,
      "endLine": 384,
      "before": "function dumpSDK(outdir: string): void {\n  if (!__DEV__) {\n    lumo.internal.embedded.keys().forEach((res: string) => {\n      const idx = res.lastIndexOf('/');\n\n      if (idx !== -1) {\n        util.ensureDir(path.join(outdir, res.slice(0, idx)));\n      } // $FlowFixMe: need to check result of res, but bundled resources will be\n\n\n      fs.writeFileSync(path.join(outdir, res), load(res), 'utf8');\n    });\n  }\n}",
      "after": "async function dumpSDK(outdir: string): void {\n  if (!__DEV__) {\n    await lumo.internal.embedded.keys().forEach(async (res: string) => {\n      const idx = res.lastIndexOf('/');\n\n      if (idx !== -1) {\n        util.ensureDir(path.join(outdir, res.slice(0, idx)));\n      } // $FlowFixMe: need to check result of res, but bundled resources will be\n\n\n      await fs.promises.writeFile(path.join(outdir, res), await load(res), 'utf8');\n    });\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cli.js",
      "startLine": 298,
      "endLine": 298,
      "before": "function startCLI(): mixed {\n  const opts = getCLIOpts();\n  const {\n    args,\n    cache,\n    classpath,\n    dependencies,\n    unrecognized,\n    help,\n    legal,\n    mainNsName,\n    mainScript,\n    quiet,\n    scripts,\n    version\n  } = opts;\n  const autoCache = opts['auto-cache'];\n  const localRepo = opts['local-repo'];\n  const dumpSDK = opts['dump-sdk']; // if help, print help and bail\n\n  if (help) {\n    printHelp();\n    return process.exit(unrecognized ? 1 : 0);\n  }\n\n  if (version) {\n    return printVersion();\n  }\n\n  if (legal) {\n    return printLegal();\n  }\n\n  if (dumpSDK != null) {\n    return lumo.dumpSDK(dumpSDK);\n  }\n\n  v8.setFlagsFromString('--use_strict');\n\n  if (scripts.length === 0 && !mainNsName && !mainScript && args.length === 0) {\n    opts.repl = true;\n  }\n\n  if (cache || autoCache) {\n    const cachePath = cache || '.lumo_cache';\n    util.ensureDir(cachePath);\n    opts.cache = cachePath;\n  } // TODO: print classpath to stdout if `:verbose`\n\n\n  if (classpath.length !== 0) {\n    // if (verbose) {\n    //   console.log(`Classpath resolves to: `);\n    // }\n    const srcPaths = util.srcPathsFromClasspathStrings(classpath);\n    opts.classpath = srcPaths;\n    lumo.addSourcePaths(srcPaths);\n  }\n\n  if (dependencies.length !== 0) {\n    const mvnPaths = util.srcPathsFromMavenDependencies(dependencies, localRepo);\n    opts.classpath.push(...mvnPaths);\n    lumo.addSourcePaths(mvnPaths);\n  }\n\n  if (opts.repl && !quiet) {\n    printBanner();\n  }\n\n  return startClojureScriptEngine(opts);\n}",
      "after": "async function startCLI(): mixed {\n  const opts = getCLIOpts();\n  const {\n    args,\n    cache,\n    classpath,\n    dependencies,\n    unrecognized,\n    help,\n    legal,\n    mainNsName,\n    mainScript,\n    quiet,\n    scripts,\n    version\n  } = opts;\n  const autoCache = opts['auto-cache'];\n  const localRepo = opts['local-repo'];\n  const dumpSDK = opts['dump-sdk']; // if help, print help and bail\n\n  if (help) {\n    printHelp();\n    return process.exit(unrecognized ? 1 : 0);\n  }\n\n  if (version) {\n    return printVersion();\n  }\n\n  if (legal) {\n    return printLegal();\n  }\n\n  if (dumpSDK != null) {\n    return await lumo.dumpSDK(dumpSDK);\n  }\n\n  v8.setFlagsFromString('--use_strict');\n\n  if (scripts.length === 0 && !mainNsName && !mainScript && args.length === 0) {\n    opts.repl = true;\n  }\n\n  if (cache || autoCache) {\n    const cachePath = cache || '.lumo_cache';\n    util.ensureDir(cachePath);\n    opts.cache = cachePath;\n  } // TODO: print classpath to stdout if `:verbose`\n\n\n  if (classpath.length !== 0) {\n    // if (verbose) {\n    //   console.log(`Classpath resolves to: `);\n    // }\n    const srcPaths = util.srcPathsFromClasspathStrings(classpath);\n    opts.classpath = srcPaths;\n    lumo.addSourcePaths(srcPaths);\n  }\n\n  if (dependencies.length !== 0) {\n    const mvnPaths = util.srcPathsFromMavenDependencies(dependencies, localRepo);\n    opts.classpath.push(...mvnPaths);\n    lumo.addSourcePaths(mvnPaths);\n  }\n\n  if (opts.repl && !quiet) {\n    await printBanner();\n  }\n\n  return await startClojureScriptEngine(opts);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 79,
      "endLine": 79,
      "before": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-vsqdfK']\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(true);\n  expect(parsedOpts['static-fns']).toBe(true);\n  expect(parsedOpts['fn-invoke-direct']).toBe(true);\n  expect(parsedOpts['dumb-terminal']).toBe(true);\n  expect(parsedOpts['auto-cache']).toBe(true);\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-vsqdfK']\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(true);\n  expect(parsedOpts['static-fns']).toBe(true);\n  expect(parsedOpts['fn-invoke-direct']).toBe(true);\n  expect(parsedOpts['dumb-terminal']).toBe(true);\n  expect(parsedOpts['auto-cache']).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 97,
      "endLine": 97,
      "before": "async () => {\n  const args = '-i foo.cljs -e :foo -e :bar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(false);\n  expect(parsedOpts.scripts.length).toEqual(3);\n}",
      "after": "async () => {\n  const args = '-i foo.cljs -e :foo -e :bar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(false);\n  expect(parsedOpts.scripts.length).toEqual(3);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 109,
      "endLine": 109,
      "before": "async () => {\n  const args = '-i foo.cljs -e :foo -i bar.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.scripts.length).toEqual(3);\n  expect(parsedOpts.scripts).toEqual([['path', 'foo.cljs'], ['text', ':foo'], ['path', 'bar.cljs']]);\n}",
      "after": "async () => {\n  const args = '-i foo.cljs -e :foo -i bar.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.scripts.length).toEqual(3);\n  expect(parsedOpts.scripts).toEqual([['path', 'foo.cljs'], ['text', ':foo'], ['path', 'bar.cljs']]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 127,
      "endLine": 127,
      "before": "async () => {\n  const args = `-c foo${delim}bar`;\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual(['foo', 'bar']);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith(['foo', 'bar']);\n}",
      "after": "async () => {\n  const args = `-c foo${delim}bar`;\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual(['foo', 'bar']);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith(['foo', 'bar']);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 140,
      "endLine": 140,
      "before": "async () => {\n  const args = '-r foo.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['foo.cljs']);\n  expect(parsedOpts.repl).toBe(true);\n}",
      "after": "async () => {\n  const args = '-r foo.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['foo.cljs']);\n  expect(parsedOpts.repl).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 153,
      "endLine": 153,
      "before": "async () => {\n  const args = '-r --verbose --socket-repl localhost:5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['--verbose', '--socket-repl', 'localhost:5555']);\n  expect(parsedOpts.repl).toBe(true);\n}",
      "after": "async () => {\n  const args = '-r --verbose --socket-repl localhost:5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['--verbose', '--socket-repl', 'localhost:5555']);\n  expect(parsedOpts.repl).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 170,
      "endLine": 170,
      "before": "async () => {\n  const args = 'foo.cljs -r';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['-r']);\n  expect(parsedOpts.repl).toBe(false);\n}",
      "after": "async () => {\n  const args = 'foo.cljs -r';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['-r']);\n  expect(parsedOpts.repl).toBe(false);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 183,
      "endLine": 183,
      "before": "async () => {\n  const args = '-k src';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.cache).toEqual('src');\n}",
      "after": "async () => {\n  const args = '-k src';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.cache).toEqual('src');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 196,
      "endLine": 196,
      "before": "async () => {\n  const args = '-k';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-k';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 208,
      "endLine": 208,
      "before": "async () => {\n  const args = '-m foo.core foo bar baz qux';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.mainNsName).toEqual('foo.core');\n  expect(parsedOpts.args).toEqual(['foo', 'bar', 'baz', 'qux']);\n}",
      "after": "async () => {\n  const args = '-m foo.core foo bar baz qux';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.mainNsName).toEqual('foo.core');\n  expect(parsedOpts.args).toEqual(['foo', 'bar', 'baz', 'qux']);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 223,
      "endLine": 223,
      "before": "async () => {\n  const args = '-a';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}",
      "after": "async () => {\n  const args = '-a';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 236,
      "endLine": 236,
      "before": "async () => {\n  const args = '--elide-asserts';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}",
      "after": "async () => {\n  const args = '--elide-asserts';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 251,
      "endLine": 251,
      "before": "async () => {\n  const args = '-A warn';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('warn');\n}",
      "after": "async () => {\n  const args = '-A warn';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('warn');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 264,
      "endLine": 264,
      "before": "async () => {\n  const args = '--checked-arrays error';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('error');\n}",
      "after": "async () => {\n  const args = '--checked-arrays error';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('error');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 288,
      "endLine": 288,
      "before": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0/react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}",
      "after": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0/react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 322,
      "endLine": 322,
      "before": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0 -L ~/some-location';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}",
      "after": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0 -L ~/some-location';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 376,
      "endLine": 376,
      "before": "async () => {\n  jest.resetModules();\n  jest.mock('../socketRepl');\n  socketRepl = require('../socketRepl');\n  startCLI = require('../cli').default;\n  const args = '-n 5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(socketRepl.open).toHaveBeenCalledTimes(1);\n  expect(socketRepl.open).toHaveBeenCalledWith({\n    host: undefined,\n    port: 5555\n  });\n}",
      "after": "async () => {\n  jest.resetModules();\n  jest.mock('../socketRepl');\n  socketRepl = require('../socketRepl');\n  startCLI = require('../cli').default;\n  const args = '-n 5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(socketRepl.open).toHaveBeenCalledTimes(1);\n  expect(socketRepl.open).toHaveBeenCalledWith({\n    host: undefined,\n    port: 5555\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 392,
      "endLine": 392,
      "before": "async () => {\n  const args = '-n';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect.assertions(2);\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect.assertions(2);\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 405,
      "endLine": 405,
      "before": "async () => {\n  const args = '-n {}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 417,
      "endLine": 417,
      "before": "async () => {\n  const args = '-n {port: 12345}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {port: 12345}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 429,
      "endLine": 429,
      "before": "async () => {\n  const args = '-n localhost';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n localhost';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 441,
      "endLine": 441,
      "before": "async () => {\n  const args = '-n {\"host\":\"localhost\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"host\":\"localhost\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 453,
      "endLine": 453,
      "before": "async () => {\n  const args = '-n foobar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n foobar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 465,
      "endLine": 465,
      "before": "async () => {\n  const args = '-n {\"port\":\"foobar\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":\"foobar\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 477,
      "endLine": 477,
      "before": "async () => {\n  const args = '-n {\"port\":0}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":0}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 489,
      "endLine": 489,
      "before": "async () => {\n  const args = '-n {\"port\":-1000}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":-1000}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 501,
      "endLine": 501,
      "before": "async () => {\n  const args = '-n {\"port\":7753888}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":7753888}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 531,
      "endLine": 531,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  await startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 540,
      "endLine": 540,
      "before": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-n', '5555']\n  });\n  await startCLI();\n  socketRepl.close();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-n', '5555']\n  });\n  await startCLI();\n  socketRepl.close();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 550,
      "endLine": 550,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-q']\n  });\n  startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-q']\n  });\n  await startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 559,
      "endLine": 559,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', 'foo.cljs']\n  });\n  startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', 'foo.cljs']\n  });\n  await startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 568,
      "endLine": 568,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-']\n  });\n  startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-']\n  });\n  await startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 579,
      "endLine": 579,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-h']\n  });\n  startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-h']\n  });\n  await startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 590,
      "endLine": 590,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-l']\n  });\n  startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-l']\n  });\n  await startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 607,
      "endLine": 607,
      "before": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  await startCLI();\n  expect(v8.setFlagsFromString).toHaveBeenCalledWith('--use_strict');\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  await startCLI();\n  expect(v8.setFlagsFromString).toHaveBeenCalledWith('--use_strict');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 49,
      "endLine": 52,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 59,
      "endLine": 63,
      "before": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}",
      "after": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 70,
      "endLine": 74,
      "before": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}",
      "after": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 81,
      "endLine": 85,
      "before": "async () => {\n  await startCLJS({\n    repl: false,\n    mainScript: 'foo.cljs',\n    scripts: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: false,\n    mainScript: 'foo.cljs',\n    scripts: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 91,
      "endLine": 96,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    // scripts will init the ClojureScript engine\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    // scripts will init the ClojureScript engine\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 103,
      "endLine": 107,
      "before": "async () => {\n  await startCLJS({\n    mainNsName: 'foo.core',\n    args: ['a', 'b', 'c'],\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(vm.ctx.cljs.core.seq).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    mainNsName: 'foo.core',\n    args: ['a', 'b', 'c'],\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(vm.ctx.cljs.core.seq).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 119,
      "endLine": 123,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(vm.createContext).toHaveBeenCalled();\n  expect(vm.createContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(vm.createContext).toHaveBeenCalled();\n  expect(vm.createContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 134,
      "endLine": 137,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 167,
      "endLine": 171,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    _: [],\n    scripts: []\n  });\n  jest.runAllTicks();\n  vm.ctx.$$LUMO_GLOBALS.eval('source');\n  expect(vm.runInContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    _: [],\n    scripts: []\n  });\n  jest.runAllTicks();\n  vm.ctx.$$LUMO_GLOBALS.eval('source');\n  expect(vm.runInContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 207,
      "endLine": 212,
      "before": "async () => {\n  expect.assertions(1);\n  await startClojureScriptEngine({\n    repl: true,\n    _: [],\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  global.$$LUMO_GLOBALS.eval('source', false);\n  expect(vm.runInThisContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  expect.assertions(1);\n  await startClojureScriptEngine({\n    repl: true,\n    _: [],\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  global.$$LUMO_GLOBALS.eval('source', false);\n  expect(vm.runInThisContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 109,
      "endLine": 109,
      "before": "() => {\n  startREPL({});\n  expect(replHistory).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(replHistory).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 115,
      "endLine": 115,
      "before": "() => {\n  startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalled();\n  expect(mockPrompt).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalled();\n  expect(mockPrompt).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 122,
      "endLine": 122,
      "before": "() => {\n  startREPL({});\n  const onCalls = on.mock.calls;\n  expect(on).toHaveBeenCalledTimes(4);\n  expect(onCalls[0][0]).toBe('line');\n  expect(onCalls[1][0]).toBe('SIGINT');\n  expect(onCalls[2][0]).toBe('close');\n  expect(onCalls[3][0]).toBe('SIGCONT');\n}",
      "after": "async () => {\n  await startREPL({});\n  const onCalls = on.mock.calls;\n  expect(on).toHaveBeenCalledTimes(4);\n  expect(onCalls[0][0]).toBe('line');\n  expect(onCalls[1][0]).toBe('SIGINT');\n  expect(onCalls[2][0]).toBe('close');\n  expect(onCalls[3][0]).toBe('SIGCONT');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 133,
      "endLine": 133,
      "before": "() => {\n  startREPL({});\n  const onCalls = process.stdin.on.mock.calls;\n  expect(process.stdin.on).toHaveBeenCalledTimes(1);\n  expect(onCalls[0][0]).toBe('keypress');\n}",
      "after": "async () => {\n  await startREPL({});\n  const onCalls = process.stdin.on.mock.calls;\n  expect(process.stdin.on).toHaveBeenCalledTimes(1);\n  expect(onCalls[0][0]).toBe('keypress');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 154,
      "endLine": 156,
      "before": "() => {\n  startREPL({\n    'dumb-terminal': false\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(true);\n}",
      "after": "async () => {\n  await startREPL({\n    'dumb-terminal': false\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 165,
      "endLine": 167,
      "before": "() => {\n  startREPL({\n    'dumb-terminal': true\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(false);\n}",
      "after": "async () => {\n  await startREPL({\n    'dumb-terminal': true\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(false);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 177,
      "endLine": 179,
      "before": "() => {\n  startREPL({\n    'dumb-terminal': true\n  });\n  expect(process.stdin.setRawMode).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startREPL({\n    'dumb-terminal': true\n  });\n  expect(process.stdin.setRawMode).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 187,
      "endLine": 189,
      "before": "() => {\n  util.isWindows = false;\n  startREPL({\n    'dumb-terminal': false\n  });\n  expect(process.stdin.setRawMode).toHaveBeenCalledWith(true);\n}",
      "after": "async () => {\n  util.isWindows = false;\n  await startREPL({\n    'dumb-terminal': false\n  });\n  expect(process.stdin.setRawMode).toHaveBeenCalledWith(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 212,
      "endLine": 212,
      "before": "() => {\n  mockReplHistory(':cljs/quit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory(':cljs/quit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 222,
      "endLine": 222,
      "before": "() => {\n  mockReplHistory('exit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory('exit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 232,
      "endLine": 232,
      "before": "() => {\n  mockReplHistory('  :cljs/quit  ', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory('  :cljs/quit  ', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 244,
      "endLine": 244,
      "before": "() => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  startREPL = require('../repl').default;\n\n  const {\n    close\n  } = require('../socketRepl');\n  /* eslint-enable global-require */\n\n\n  startREPL({});\n  expect(close).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  startREPL = require('../repl').default;\n\n  const {\n    close\n  } = require('../socketRepl');\n  /* eslint-enable global-require */\n\n\n  await startREPL({});\n  expect(close).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 273,
      "endLine": 273,
      "before": "() => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  const repl = require('../repl');\n\n  startREPL = repl.default;\n  /* eslint-enable global-require */\n\n  const originalObjectKeys = Object.keys;\n  let sessions;\n  Object.keys = jest.fn((x: {\n    [key: mixed]: mixed\n  }) => {\n    const result = originalObjectKeys(x);\n    const everyNumber = result.every((k: string) => {\n      try {\n        return !Number.isNaN(parseInt(k, 10));\n      } catch (_) {\n        return false;\n      }\n    });\n\n    if (everyNumber) {\n      sessions = x;\n    }\n\n    return result;\n  });\n  startREPL({});\n  expect(originalObjectKeys(sessions).length).toBe(0);\n  Object.keys = originalObjectKeys;\n}",
      "after": "async () => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  const repl = require('../repl');\n\n  startREPL = repl.default;\n  /* eslint-enable global-require */\n\n  const originalObjectKeys = Object.keys;\n  let sessions;\n  Object.keys = jest.fn((x: {\n    [key: mixed]: mixed\n  }) => {\n    const result = originalObjectKeys(x);\n    const everyNumber = result.every((k: string) => {\n      try {\n        return !Number.isNaN(parseInt(k, 10));\n      } catch (_) {\n        return false;\n      }\n    });\n\n    if (everyNumber) {\n      sessions = x;\n    }\n\n    return result;\n  });\n  await startREPL({});\n  expect(originalObjectKeys(sessions).length).toBe(0);\n  Object.keys = originalObjectKeys;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 325,
      "endLine": 325,
      "before": "() => {\n  const repl = require('../repl'); // eslint-disable-line global-require\n\n\n  const replCreateSession = repl.createSession;\n  repl.createSession = jest.fn((rl: readline$Interface) => ({\n    rl,\n    id: 0\n  }));\n  startREPL({});\n  handleConnection(socket);\n  handleConnection(socket);\n  expect(repl.createSession).toHaveBeenCalledTimes(2);\n  repl.createSession = replCreateSession;\n}",
      "after": "async () => {\n  const repl = require('../repl'); // eslint-disable-line global-require\n\n\n  const replCreateSession = repl.createSession;\n  repl.createSession = jest.fn((rl: readline$Interface) => ({\n    rl,\n    id: 0\n  }));\n  await startREPL({});\n  handleConnection(socket);\n  handleConnection(socket);\n  expect(repl.createSession).toHaveBeenCalledTimes(2);\n  repl.createSession = replCreateSession;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 336,
      "endLine": 336,
      "before": "() => {\n  startREPL({});\n  expect(handleConnection(socket)).toBe(1);\n  expect(handleConnection(socket)).toBe(2);\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(handleConnection(socket)).toBe(1);\n  expect(handleConnection(socket)).toBe(2);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 354,
      "endLine": 354,
      "before": "() => {\n  startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('cljs.user=> ');\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('cljs.user=> ');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 370,
      "endLine": 370,
      "before": "() => {\n  jest.resetModules();\n  jest.mock('../cljs', () => ({\n    isReadable: jest.fn((input: string) => null),\n    execute: jest.fn(),\n    getCurrentNamespace: jest.fn(() => 'cljs.user'),\n    indentSpaceCount: jest.fn((text: string) => 0)\n  })); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('       #_=> ');\n}",
      "after": "async () => {\n  jest.resetModules();\n  jest.mock('../cljs', () => ({\n    isReadable: jest.fn((input: string) => null),\n    execute: jest.fn(),\n    getCurrentNamespace: jest.fn(() => 'cljs.user'),\n    indentSpaceCount: jest.fn((text: string) => 0)\n  })); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('       #_=> ');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/index.js",
      "startLine": 5,
      "endLine": 5,
      "before": "startCLI()",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait startCLI()"
    }
  ],
  "24": [
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/bundle.js",
      "startLine": 126,
      "endLine": 126,
      "before": "function () {\n  var source = fs.readFileSync(bundlePath, 'utf8');\n  source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n  fs.writeFile(bundlePath, source, 'utf8', function (err) {\n    if (err) {\n      _log('error', 'failed to save source');\n\n      process.exit(1);\n    }\n\n    complete();\n  });\n}",
      "after": "async function () {\n  var source = await fs.promises.readFile(bundlePath, 'utf8');\n  source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n  fs.writeFile(bundlePath, source, 'utf8', function (err) {\n    if (err) {\n      _log('error', 'failed to save source');\n\n      process.exit(1);\n    }\n\n    complete();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 30,
      "endLine": 30,
      "before": "on(_: string, cb: (number) => void): void {\n  cb(42);\n}",
      "after": "async on(_: string, cb: (number) => void): void {\n  await cb(42);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 96,
      "endLine": 104,
      "before": "(resolve, reject) => {\n  let bytesRead = 0;\n  resp.body.on('error', reject).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}",
      "after": "async (resolve, reject) => {\n  let bytesRead = 0;\n  await resp.body.on('error', reject).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 96,
      "endLine": 97,
      "before": "(resolve, reject) => {\n  let bytesRead = 0;\n  resp.body.on('error', reject).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}",
      "after": "async (resolve, reject) => {\n  let bytesRead = 0;\n  await (await resp.body.on('error', reject)).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 108,
      "endLine": 109,
      "before": "(resolve, reject) => {\n  let bytesRead = 0;\n  resp.body.on('error', reject).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}",
      "after": "async (resolve, reject) => {\n  let bytesRead = 0;\n  await (await resp.body.on('error', reject)).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  await gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 113,
      "endLine": 118,
      "before": "(resolve, reject) => {\n  let bytesRead = 0;\n  resp.body.on('error', reject).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}",
      "after": "async (resolve, reject) => {\n  let bytesRead = 0;\n  await (await resp.body.on('error', reject)).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  await gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  await ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 113,
      "endLine": 114,
      "before": "(resolve, reject) => {\n  let bytesRead = 0;\n  resp.body.on('error', reject).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}",
      "after": "async (resolve, reject) => {\n  let bytesRead = 0;\n  await (await resp.body.on('error', reject)).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  await gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  await (await ws.on('error', reject)).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 42,
      "endLine": 42,
      "before": "function restoreSigintHandlers(handlers: sigintHandlerType[]): void {\n  handlers.forEach((listener: sigintHandlerType) => process.on('SIGINT', listener));\n}",
      "after": "async function restoreSigintHandlers(handlers: sigintHandlerType[]): void {\n  handlers.forEach(async (listener: sigintHandlerType) => await process.on('SIGINT', listener));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 118,
      "endLine": 118,
      "before": "function lumoEval(source: string, isForeign: boolean, execPath: ?string): mixed {\n  if (execPath != null) {\n    const filename = path.resolve(execPath);\n    const dirname = path.dirname(filename);\n    const module = new Module(filename);\n    module.filename = filename;\n    module.paths = Module._nodeModulePaths(dirname);\n\n    if (__DEV__) {\n      const compiledWrapper = vm.runInContext(Module.wrap(source), ClojureScriptContext, {\n        filename,\n        lineOffset: 0,\n        displayErrors: true\n      });\n      return compiledWrapper.call(module.exports, module.exports, require, module, filename, dirname);\n    }\n\n    return module._compile(source, filename);\n  } // $FlowIssue: this exists\n\n\n  const _module = ClojureScriptContext.module; // $FlowIssue: this also exists\n\n  const _exports = ClojureScriptContext.exports;\n  let ret;\n\n  if (isForeign) {\n    // this is a hack needed for foreign libraries to end up on global scope.\n    // Closure Library's goog.bootstrap.nodeJs does the same thing.\n    // $FlowIssue: this exists\n    ClojureScriptContext.module = undefined; // $FlowIssue: this exists\n\n    ClojureScriptContext.exports = undefined;\n  }\n\n  if (currentREPLInterface != null) {\n    const sigintHandlers = getAndRemoveSigintEventListeners();\n    contextifyBinding.startSigintWatchdog();\n\n    const previouslyInRawMode = currentREPLInterface._setRawMode(false);\n\n    try {\n      ret = __DEV__ ? vm.runInContext(source, ClojureScriptContext, interruptibleScriptOptions) : vm.runInThisContext(source, interruptibleScriptOptions);\n    } catch (e) {\n      if (e.message !== 'Script execution interrupted.') {\n        throw e;\n      }\n    } finally {\n      currentREPLInterface._setRawMode(previouslyInRawMode);\n\n      const hadPendingSignals = contextifyBinding.stopSigintWatchdog();\n      restoreSigintHandlers(sigintHandlers);\n\n      if (hadPendingSignals) {\n        currentREPLInterface.emit('SIGINT');\n      }\n    }\n  } else {\n    ret = __DEV__ ? vm.runInContext(source, ClojureScriptContext, scriptOptions) : vm.runInThisContext(source, scriptOptions);\n  }\n\n  if (isForeign) {\n    // $FlowIssue: this exists\n    ClojureScriptContext.module = _module; // $FlowIssue: this exists\n\n    ClojureScriptContext.exports = _exports;\n  }\n\n  return ret;\n}",
      "after": "async function lumoEval(source: string, isForeign: boolean, execPath: ?string): mixed {\n  if (execPath != null) {\n    const filename = path.resolve(execPath);\n    const dirname = path.dirname(filename);\n    const module = new Module(filename);\n    module.filename = filename;\n    module.paths = Module._nodeModulePaths(dirname);\n\n    if (__DEV__) {\n      const compiledWrapper = vm.runInContext(Module.wrap(source), ClojureScriptContext, {\n        filename,\n        lineOffset: 0,\n        displayErrors: true\n      });\n      return compiledWrapper.call(module.exports, module.exports, require, module, filename, dirname);\n    }\n\n    return module._compile(source, filename);\n  } // $FlowIssue: this exists\n\n\n  const _module = ClojureScriptContext.module; // $FlowIssue: this also exists\n\n  const _exports = ClojureScriptContext.exports;\n  let ret;\n\n  if (isForeign) {\n    // this is a hack needed for foreign libraries to end up on global scope.\n    // Closure Library's goog.bootstrap.nodeJs does the same thing.\n    // $FlowIssue: this exists\n    ClojureScriptContext.module = undefined; // $FlowIssue: this exists\n\n    ClojureScriptContext.exports = undefined;\n  }\n\n  if (currentREPLInterface != null) {\n    const sigintHandlers = getAndRemoveSigintEventListeners();\n    contextifyBinding.startSigintWatchdog();\n\n    const previouslyInRawMode = currentREPLInterface._setRawMode(false);\n\n    try {\n      ret = __DEV__ ? vm.runInContext(source, ClojureScriptContext, interruptibleScriptOptions) : vm.runInThisContext(source, interruptibleScriptOptions);\n    } catch (e) {\n      if (e.message !== 'Script execution interrupted.') {\n        throw e;\n      }\n    } finally {\n      currentREPLInterface._setRawMode(previouslyInRawMode);\n\n      const hadPendingSignals = contextifyBinding.stopSigintWatchdog();\n      await restoreSigintHandlers(sigintHandlers);\n\n      if (hadPendingSignals) {\n        currentREPLInterface.emit('SIGINT');\n      }\n    }\n  } else {\n    ret = __DEV__ ? vm.runInContext(source, ClojureScriptContext, scriptOptions) : vm.runInThisContext(source, scriptOptions);\n  }\n\n  if (isForeign) {\n    // $FlowIssue: this exists\n    ClojureScriptContext.module = _module; // $FlowIssue: this exists\n\n    ClojureScriptContext.exports = _exports;\n  }\n\n  return ret;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 174,
      "endLine": 174,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    _: [],\n    scripts: []\n  });\n  jest.runAllTicks();\n  vm.ctx.$$LUMO_GLOBALS.eval('source');\n  expect(vm.runInContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    _: [],\n    scripts: []\n  });\n  jest.runAllTicks();\n  await vm.ctx.$$LUMO_GLOBALS.eval('source');\n  expect(vm.runInContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 215,
      "endLine": 215,
      "before": "async () => {\n  expect.assertions(1);\n  await startClojureScriptEngine({\n    repl: true,\n    _: [],\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  global.$$LUMO_GLOBALS.eval('source', false);\n  expect(vm.runInThisContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  expect.assertions(1);\n  await startClojureScriptEngine({\n    repl: true,\n    _: [],\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  await global.$$LUMO_GLOBALS.eval('source', false);\n  expect(vm.runInThisContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 155,
      "endLine": 155,
      "before": "function doPrint(cb: (value: string) => void, arg: string): void {\n  if (currentREPLInterface != null) {\n    const sigintHandlers = getAndRemoveSigintEventListeners();\n    contextifyBinding.startSigintWatchdog();\n\n    const previouslyInRawMode = currentREPLInterface._setRawMode(false);\n\n    try {\n      cb(arg);\n    } catch (e) {\n      if (e !== interruptSentinel) {\n        throw e;\n      }\n    } finally {\n      currentREPLInterface._setRawMode(previouslyInRawMode);\n\n      const hadPendingSignals = contextifyBinding.stopSigintWatchdog();\n      restoreSigintHandlers(sigintHandlers);\n\n      if (hadPendingSignals) {\n        currentREPLInterface.emit('SIGINT');\n      }\n    }\n  } else {\n    cb(arg);\n  }\n}",
      "after": "async function doPrint(cb: (value: string) => void, arg: string): void {\n  if (currentREPLInterface != null) {\n    const sigintHandlers = getAndRemoveSigintEventListeners();\n    contextifyBinding.startSigintWatchdog();\n\n    const previouslyInRawMode = currentREPLInterface._setRawMode(false);\n\n    try {\n      cb(arg);\n    } catch (e) {\n      if (e !== interruptSentinel) {\n        throw e;\n      }\n    } finally {\n      currentREPLInterface._setRawMode(previouslyInRawMode);\n\n      const hadPendingSignals = contextifyBinding.stopSigintWatchdog();\n      await restoreSigintHandlers(sigintHandlers);\n\n      if (hadPendingSignals) {\n        currentREPLInterface.emit('SIGINT');\n      }\n    }\n  } else {\n    cb(arg);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 433,
      "endLine": 435,
      "before": "function processStdin(): void {\n  let code = '';\n  process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?",
      "after": "async function processStdin(): void {\n  let code = '';\n  await process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 535,
      "endLine": 535,
      "before": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    process.nextTick(() => {\n      initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}",
      "after": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    await initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    await initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      await processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    await initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    await process.nextTick(async () => {\n      await initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    await initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 79,
      "endLine": 79,
      "before": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-vsqdfK']\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(true);\n  expect(parsedOpts['static-fns']).toBe(true);\n  expect(parsedOpts['fn-invoke-direct']).toBe(true);\n  expect(parsedOpts['dumb-terminal']).toBe(true);\n  expect(parsedOpts['auto-cache']).toBe(true);\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-vsqdfK']\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(true);\n  expect(parsedOpts['static-fns']).toBe(true);\n  expect(parsedOpts['fn-invoke-direct']).toBe(true);\n  expect(parsedOpts['dumb-terminal']).toBe(true);\n  expect(parsedOpts['auto-cache']).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 97,
      "endLine": 97,
      "before": "async () => {\n  const args = '-i foo.cljs -e :foo -e :bar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(false);\n  expect(parsedOpts.scripts.length).toEqual(3);\n}",
      "after": "async () => {\n  const args = '-i foo.cljs -e :foo -e :bar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(false);\n  expect(parsedOpts.scripts.length).toEqual(3);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 109,
      "endLine": 109,
      "before": "async () => {\n  const args = '-i foo.cljs -e :foo -i bar.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.scripts.length).toEqual(3);\n  expect(parsedOpts.scripts).toEqual([['path', 'foo.cljs'], ['text', ':foo'], ['path', 'bar.cljs']]);\n}",
      "after": "async () => {\n  const args = '-i foo.cljs -e :foo -i bar.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.scripts.length).toEqual(3);\n  expect(parsedOpts.scripts).toEqual([['path', 'foo.cljs'], ['text', ':foo'], ['path', 'bar.cljs']]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 127,
      "endLine": 127,
      "before": "async () => {\n  const args = `-c foo${delim}bar`;\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual(['foo', 'bar']);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith(['foo', 'bar']);\n}",
      "after": "async () => {\n  const args = `-c foo${delim}bar`;\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual(['foo', 'bar']);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith(['foo', 'bar']);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 140,
      "endLine": 140,
      "before": "async () => {\n  const args = '-r foo.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['foo.cljs']);\n  expect(parsedOpts.repl).toBe(true);\n}",
      "after": "async () => {\n  const args = '-r foo.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['foo.cljs']);\n  expect(parsedOpts.repl).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 153,
      "endLine": 153,
      "before": "async () => {\n  const args = '-r --verbose --socket-repl localhost:5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['--verbose', '--socket-repl', 'localhost:5555']);\n  expect(parsedOpts.repl).toBe(true);\n}",
      "after": "async () => {\n  const args = '-r --verbose --socket-repl localhost:5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['--verbose', '--socket-repl', 'localhost:5555']);\n  expect(parsedOpts.repl).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 170,
      "endLine": 170,
      "before": "async () => {\n  const args = 'foo.cljs -r';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['-r']);\n  expect(parsedOpts.repl).toBe(false);\n}",
      "after": "async () => {\n  const args = 'foo.cljs -r';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['-r']);\n  expect(parsedOpts.repl).toBe(false);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 183,
      "endLine": 183,
      "before": "async () => {\n  const args = '-k src';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.cache).toEqual('src');\n}",
      "after": "async () => {\n  const args = '-k src';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.cache).toEqual('src');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 196,
      "endLine": 196,
      "before": "async () => {\n  const args = '-k';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-k';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 208,
      "endLine": 208,
      "before": "async () => {\n  const args = '-m foo.core foo bar baz qux';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.mainNsName).toEqual('foo.core');\n  expect(parsedOpts.args).toEqual(['foo', 'bar', 'baz', 'qux']);\n}",
      "after": "async () => {\n  const args = '-m foo.core foo bar baz qux';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.mainNsName).toEqual('foo.core');\n  expect(parsedOpts.args).toEqual(['foo', 'bar', 'baz', 'qux']);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 223,
      "endLine": 223,
      "before": "async () => {\n  const args = '-a';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}",
      "after": "async () => {\n  const args = '-a';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 236,
      "endLine": 236,
      "before": "async () => {\n  const args = '--elide-asserts';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}",
      "after": "async () => {\n  const args = '--elide-asserts';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 251,
      "endLine": 251,
      "before": "async () => {\n  const args = '-A warn';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('warn');\n}",
      "after": "async () => {\n  const args = '-A warn';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('warn');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 264,
      "endLine": 264,
      "before": "async () => {\n  const args = '--checked-arrays error';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('error');\n}",
      "after": "async () => {\n  const args = '--checked-arrays error';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('error');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 288,
      "endLine": 288,
      "before": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0/react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}",
      "after": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0/react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 322,
      "endLine": 322,
      "before": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0 -L ~/some-location';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}",
      "after": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0 -L ~/some-location';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 376,
      "endLine": 376,
      "before": "async () => {\n  jest.resetModules();\n  jest.mock('../socketRepl');\n  socketRepl = require('../socketRepl');\n  startCLI = require('../cli').default;\n  const args = '-n 5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(socketRepl.open).toHaveBeenCalledTimes(1);\n  expect(socketRepl.open).toHaveBeenCalledWith({\n    host: undefined,\n    port: 5555\n  });\n}",
      "after": "async () => {\n  jest.resetModules();\n  jest.mock('../socketRepl');\n  socketRepl = require('../socketRepl');\n  startCLI = require('../cli').default;\n  const args = '-n 5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(socketRepl.open).toHaveBeenCalledTimes(1);\n  expect(socketRepl.open).toHaveBeenCalledWith({\n    host: undefined,\n    port: 5555\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 392,
      "endLine": 392,
      "before": "async () => {\n  const args = '-n';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect.assertions(2);\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect.assertions(2);\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 405,
      "endLine": 405,
      "before": "async () => {\n  const args = '-n {}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 417,
      "endLine": 417,
      "before": "async () => {\n  const args = '-n {port: 12345}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {port: 12345}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 429,
      "endLine": 429,
      "before": "async () => {\n  const args = '-n localhost';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n localhost';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 441,
      "endLine": 441,
      "before": "async () => {\n  const args = '-n {\"host\":\"localhost\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"host\":\"localhost\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 453,
      "endLine": 453,
      "before": "async () => {\n  const args = '-n foobar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n foobar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 465,
      "endLine": 465,
      "before": "async () => {\n  const args = '-n {\"port\":\"foobar\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":\"foobar\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 477,
      "endLine": 477,
      "before": "async () => {\n  const args = '-n {\"port\":0}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":0}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 489,
      "endLine": 489,
      "before": "async () => {\n  const args = '-n {\"port\":-1000}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":-1000}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 501,
      "endLine": 501,
      "before": "async () => {\n  const args = '-n {\"port\":7753888}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":7753888}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 531,
      "endLine": 531,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  await startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 540,
      "endLine": 540,
      "before": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-n', '5555']\n  });\n  await startCLI();\n  socketRepl.close();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-n', '5555']\n  });\n  await startCLI();\n  socketRepl.close();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 550,
      "endLine": 550,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-q']\n  });\n  startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-q']\n  });\n  await startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 559,
      "endLine": 559,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', 'foo.cljs']\n  });\n  startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', 'foo.cljs']\n  });\n  await startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 568,
      "endLine": 568,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-']\n  });\n  startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-']\n  });\n  await startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 579,
      "endLine": 579,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-h']\n  });\n  startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-h']\n  });\n  await startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 590,
      "endLine": 590,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-l']\n  });\n  startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-l']\n  });\n  await startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 607,
      "endLine": 607,
      "before": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  await startCLI();\n  expect(v8.setFlagsFromString).toHaveBeenCalledWith('--use_strict');\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  await startCLI();\n  expect(v8.setFlagsFromString).toHaveBeenCalledWith('--use_strict');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 49,
      "endLine": 52,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 59,
      "endLine": 63,
      "before": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}",
      "after": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 70,
      "endLine": 74,
      "before": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}",
      "after": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 81,
      "endLine": 85,
      "before": "async () => {\n  await startCLJS({\n    repl: false,\n    mainScript: 'foo.cljs',\n    scripts: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: false,\n    mainScript: 'foo.cljs',\n    scripts: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 91,
      "endLine": 96,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    // scripts will init the ClojureScript engine\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    // scripts will init the ClojureScript engine\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 103,
      "endLine": 107,
      "before": "async () => {\n  await startCLJS({\n    mainNsName: 'foo.core',\n    args: ['a', 'b', 'c'],\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(vm.ctx.cljs.core.seq).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    mainNsName: 'foo.core',\n    args: ['a', 'b', 'c'],\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(vm.ctx.cljs.core.seq).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 119,
      "endLine": 123,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(vm.createContext).toHaveBeenCalled();\n  expect(vm.createContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(vm.createContext).toHaveBeenCalled();\n  expect(vm.createContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 134,
      "endLine": 137,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 167,
      "endLine": 171,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    _: [],\n    scripts: []\n  });\n  jest.runAllTicks();\n  vm.ctx.$$LUMO_GLOBALS.eval('source');\n  expect(vm.runInContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    _: [],\n    scripts: []\n  });\n  jest.runAllTicks();\n  await vm.ctx.$$LUMO_GLOBALS.eval('source');\n  expect(vm.runInContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 207,
      "endLine": 212,
      "before": "async () => {\n  expect.assertions(1);\n  await startClojureScriptEngine({\n    repl: true,\n    _: [],\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  global.$$LUMO_GLOBALS.eval('source', false);\n  expect(vm.runInThisContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  expect.assertions(1);\n  await startClojureScriptEngine({\n    repl: true,\n    _: [],\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  await global.$$LUMO_GLOBALS.eval('source', false);\n  expect(vm.runInThisContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 109,
      "endLine": 109,
      "before": "() => {\n  startREPL({});\n  expect(replHistory).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(replHistory).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 115,
      "endLine": 115,
      "before": "() => {\n  startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalled();\n  expect(mockPrompt).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalled();\n  expect(mockPrompt).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 122,
      "endLine": 122,
      "before": "() => {\n  startREPL({});\n  const onCalls = on.mock.calls;\n  expect(on).toHaveBeenCalledTimes(4);\n  expect(onCalls[0][0]).toBe('line');\n  expect(onCalls[1][0]).toBe('SIGINT');\n  expect(onCalls[2][0]).toBe('close');\n  expect(onCalls[3][0]).toBe('SIGCONT');\n}",
      "after": "async () => {\n  await startREPL({});\n  const onCalls = on.mock.calls;\n  expect(on).toHaveBeenCalledTimes(4);\n  expect(onCalls[0][0]).toBe('line');\n  expect(onCalls[1][0]).toBe('SIGINT');\n  expect(onCalls[2][0]).toBe('close');\n  expect(onCalls[3][0]).toBe('SIGCONT');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 133,
      "endLine": 133,
      "before": "() => {\n  startREPL({});\n  const onCalls = process.stdin.on.mock.calls;\n  expect(process.stdin.on).toHaveBeenCalledTimes(1);\n  expect(onCalls[0][0]).toBe('keypress');\n}",
      "after": "async () => {\n  await startREPL({});\n  const onCalls = process.stdin.on.mock.calls;\n  expect(process.stdin.on).toHaveBeenCalledTimes(1);\n  expect(onCalls[0][0]).toBe('keypress');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 154,
      "endLine": 156,
      "before": "() => {\n  startREPL({\n    'dumb-terminal': false\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(true);\n}",
      "after": "async () => {\n  await startREPL({\n    'dumb-terminal': false\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 165,
      "endLine": 167,
      "before": "() => {\n  startREPL({\n    'dumb-terminal': true\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(false);\n}",
      "after": "async () => {\n  await startREPL({\n    'dumb-terminal': true\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(false);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 177,
      "endLine": 179,
      "before": "() => {\n  startREPL({\n    'dumb-terminal': true\n  });\n  expect(process.stdin.setRawMode).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startREPL({\n    'dumb-terminal': true\n  });\n  expect(process.stdin.setRawMode).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 187,
      "endLine": 189,
      "before": "() => {\n  util.isWindows = false;\n  startREPL({\n    'dumb-terminal': false\n  });\n  expect(process.stdin.setRawMode).toHaveBeenCalledWith(true);\n}",
      "after": "async () => {\n  util.isWindows = false;\n  await startREPL({\n    'dumb-terminal': false\n  });\n  expect(process.stdin.setRawMode).toHaveBeenCalledWith(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 212,
      "endLine": 212,
      "before": "() => {\n  mockReplHistory(':cljs/quit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory(':cljs/quit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 222,
      "endLine": 222,
      "before": "() => {\n  mockReplHistory('exit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory('exit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 232,
      "endLine": 232,
      "before": "() => {\n  mockReplHistory('  :cljs/quit  ', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory('  :cljs/quit  ', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 244,
      "endLine": 244,
      "before": "() => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  startREPL = require('../repl').default;\n\n  const {\n    close\n  } = require('../socketRepl');\n  /* eslint-enable global-require */\n\n\n  startREPL({});\n  expect(close).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  startREPL = require('../repl').default;\n\n  const {\n    close\n  } = require('../socketRepl');\n  /* eslint-enable global-require */\n\n\n  await startREPL({});\n  expect(close).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 273,
      "endLine": 273,
      "before": "() => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  const repl = require('../repl');\n\n  startREPL = repl.default;\n  /* eslint-enable global-require */\n\n  const originalObjectKeys = Object.keys;\n  let sessions;\n  Object.keys = jest.fn((x: {\n    [key: mixed]: mixed\n  }) => {\n    const result = originalObjectKeys(x);\n    const everyNumber = result.every((k: string) => {\n      try {\n        return !Number.isNaN(parseInt(k, 10));\n      } catch (_) {\n        return false;\n      }\n    });\n\n    if (everyNumber) {\n      sessions = x;\n    }\n\n    return result;\n  });\n  startREPL({});\n  expect(originalObjectKeys(sessions).length).toBe(0);\n  Object.keys = originalObjectKeys;\n}",
      "after": "async () => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  const repl = require('../repl');\n\n  startREPL = repl.default;\n  /* eslint-enable global-require */\n\n  const originalObjectKeys = Object.keys;\n  let sessions;\n  Object.keys = jest.fn((x: {\n    [key: mixed]: mixed\n  }) => {\n    const result = originalObjectKeys(x);\n    const everyNumber = result.every((k: string) => {\n      try {\n        return !Number.isNaN(parseInt(k, 10));\n      } catch (_) {\n        return false;\n      }\n    });\n\n    if (everyNumber) {\n      sessions = x;\n    }\n\n    return result;\n  });\n  await startREPL({});\n  expect(originalObjectKeys(sessions).length).toBe(0);\n  Object.keys = originalObjectKeys;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 325,
      "endLine": 325,
      "before": "() => {\n  const repl = require('../repl'); // eslint-disable-line global-require\n\n\n  const replCreateSession = repl.createSession;\n  repl.createSession = jest.fn((rl: readline$Interface) => ({\n    rl,\n    id: 0\n  }));\n  startREPL({});\n  handleConnection(socket);\n  handleConnection(socket);\n  expect(repl.createSession).toHaveBeenCalledTimes(2);\n  repl.createSession = replCreateSession;\n}",
      "after": "async () => {\n  const repl = require('../repl'); // eslint-disable-line global-require\n\n\n  const replCreateSession = repl.createSession;\n  repl.createSession = jest.fn((rl: readline$Interface) => ({\n    rl,\n    id: 0\n  }));\n  await startREPL({});\n  handleConnection(socket);\n  handleConnection(socket);\n  expect(repl.createSession).toHaveBeenCalledTimes(2);\n  repl.createSession = replCreateSession;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 336,
      "endLine": 336,
      "before": "() => {\n  startREPL({});\n  expect(handleConnection(socket)).toBe(1);\n  expect(handleConnection(socket)).toBe(2);\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(handleConnection(socket)).toBe(1);\n  expect(handleConnection(socket)).toBe(2);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 354,
      "endLine": 354,
      "before": "() => {\n  startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('cljs.user=> ');\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('cljs.user=> ');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 370,
      "endLine": 370,
      "before": "() => {\n  jest.resetModules();\n  jest.mock('../cljs', () => ({\n    isReadable: jest.fn((input: string) => null),\n    execute: jest.fn(),\n    getCurrentNamespace: jest.fn(() => 'cljs.user'),\n    indentSpaceCount: jest.fn((text: string) => 0)\n  })); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('       #_=> ');\n}",
      "after": "async () => {\n  jest.resetModules();\n  jest.mock('../cljs', () => ({\n    isReadable: jest.fn((input: string) => null),\n    execute: jest.fn(),\n    getCurrentNamespace: jest.fn(() => 'cljs.user'),\n    indentSpaceCount: jest.fn((text: string) => 0)\n  })); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('       #_=> ');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cli.js",
      "startLine": 339,
      "endLine": 339,
      "before": "function startCLI(): mixed {\n  const opts = getCLIOpts();\n  const {\n    args,\n    cache,\n    classpath,\n    dependencies,\n    unrecognized,\n    help,\n    legal,\n    mainNsName,\n    mainScript,\n    quiet,\n    scripts,\n    version\n  } = opts;\n  const autoCache = opts['auto-cache'];\n  const localRepo = opts['local-repo'];\n  const dumpSDK = opts['dump-sdk']; // if help, print help and bail\n\n  if (help) {\n    printHelp();\n    return process.exit(unrecognized ? 1 : 0);\n  }\n\n  if (version) {\n    return printVersion();\n  }\n\n  if (legal) {\n    return printLegal();\n  }\n\n  if (dumpSDK != null) {\n    return lumo.dumpSDK(dumpSDK);\n  }\n\n  v8.setFlagsFromString('--use_strict');\n\n  if (scripts.length === 0 && !mainNsName && !mainScript && args.length === 0) {\n    opts.repl = true;\n  }\n\n  if (cache || autoCache) {\n    const cachePath = cache || '.lumo_cache';\n    util.ensureDir(cachePath);\n    opts.cache = cachePath;\n  } // TODO: print classpath to stdout if `:verbose`\n\n\n  if (classpath.length !== 0) {\n    // if (verbose) {\n    //   console.log(`Classpath resolves to: `);\n    // }\n    const srcPaths = util.srcPathsFromClasspathStrings(classpath);\n    opts.classpath = srcPaths;\n    lumo.addSourcePaths(srcPaths);\n  }\n\n  if (dependencies.length !== 0) {\n    const mvnPaths = util.srcPathsFromMavenDependencies(dependencies, localRepo);\n    opts.classpath.push(...mvnPaths);\n    lumo.addSourcePaths(mvnPaths);\n  }\n\n  if (opts.repl && !quiet) {\n    printBanner();\n  }\n\n  return startClojureScriptEngine(opts);\n}",
      "after": "async function startCLI(): mixed {\n  const opts = getCLIOpts();\n  const {\n    args,\n    cache,\n    classpath,\n    dependencies,\n    unrecognized,\n    help,\n    legal,\n    mainNsName,\n    mainScript,\n    quiet,\n    scripts,\n    version\n  } = opts;\n  const autoCache = opts['auto-cache'];\n  const localRepo = opts['local-repo'];\n  const dumpSDK = opts['dump-sdk']; // if help, print help and bail\n\n  if (help) {\n    printHelp();\n    return process.exit(unrecognized ? 1 : 0);\n  }\n\n  if (version) {\n    return printVersion();\n  }\n\n  if (legal) {\n    return printLegal();\n  }\n\n  if (dumpSDK != null) {\n    return await lumo.dumpSDK(dumpSDK);\n  }\n\n  v8.setFlagsFromString('--use_strict');\n\n  if (scripts.length === 0 && !mainNsName && !mainScript && args.length === 0) {\n    opts.repl = true;\n  }\n\n  if (cache || autoCache) {\n    const cachePath = cache || '.lumo_cache';\n    util.ensureDir(cachePath);\n    opts.cache = cachePath;\n  } // TODO: print classpath to stdout if `:verbose`\n\n\n  if (classpath.length !== 0) {\n    // if (verbose) {\n    //   console.log(`Classpath resolves to: `);\n    // }\n    const srcPaths = util.srcPathsFromClasspathStrings(classpath);\n    opts.classpath = srcPaths;\n    lumo.addSourcePaths(srcPaths);\n  }\n\n  if (dependencies.length !== 0) {\n    const mvnPaths = util.srcPathsFromMavenDependencies(dependencies, localRepo);\n    opts.classpath.push(...mvnPaths);\n    lumo.addSourcePaths(mvnPaths);\n  }\n\n  if (opts.repl && !quiet) {\n    await printBanner();\n  }\n\n  return await startClojureScriptEngine(opts);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/index.js",
      "startLine": 5,
      "endLine": 5,
      "before": "startCLI()",
      "after": "*Note*: File will be wrapped in an IIFE \n\nawait startCLI()"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 436,
      "endLine": 439,
      "before": "function processStdin(): void {\n  let code = '';\n  process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?",
      "after": "async function processStdin(): void {\n  let code = '';\n  await process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  await process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 440,
      "endLine": 442,
      "before": "function processStdin(): void {\n  let code = '';\n  process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?",
      "after": "async function processStdin(): void {\n  let code = '';\n  await process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  await process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  await process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 438,
      "endLine": 438,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 567,
      "endLine": 567,
      "before": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    process.nextTick(() => {\n      initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}",
      "after": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    await initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    await initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      await processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    await initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    await process.nextTick(async () => {\n      await initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    await startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    await initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 439,
      "endLine": 439,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 440,
      "endLine": 440,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 441,
      "endLine": 441,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 443,
      "endLine": 445,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 37,
      "endLine": 40,
      "before": "function onLoad(path: string, fd: number, maxLength: number, offset: number, cb: (ret: string[]) => void): void {\n  const rs = fs.createReadStream(path, {\n    encoding: 'utf-8',\n    fd,\n    start: Math.max(offset, 0),\n    autoClose: false\n  });\n  let tail = '';\n  rs.on('data', (chunk: string) => {\n    // $FlowIssue: slice can return a string\n    tail += chunk;\n  });\n  rs.on('end', () => {\n    tail = tail.slice(0, -1); // history file always ends in newline\n    // $FlowIssue: slice can return a string\n\n    tail = tail.split('\\n');\n\n    if (offset > 0 && tail.length < maxLength) {\n      // eslint-disable-next-line no-mixed-operators\n      onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n    } else {\n      tail = tail.slice(-maxLength);\n      tail.reverse();\n      cb(tail);\n    }\n  });\n}",
      "after": "async function onLoad(path: string, fd: number, maxLength: number, offset: number, cb: (ret: string[]) => void): void {\n  const rs = fs.createReadStream(path, {\n    encoding: 'utf-8',\n    fd,\n    start: Math.max(offset, 0),\n    autoClose: false\n  });\n  let tail = '';\n  await rs.on('data', (chunk: string) => {\n    // $FlowIssue: slice can return a string\n    tail += chunk;\n  });\n  rs.on('end', () => {\n    tail = tail.slice(0, -1); // history file always ends in newline\n    // $FlowIssue: slice can return a string\n\n    tail = tail.split('\\n');\n\n    if (offset > 0 && tail.length < maxLength) {\n      // eslint-disable-next-line no-mixed-operators\n      onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n    } else {\n      tail = tail.slice(-maxLength);\n      tail.reverse();\n      cb(tail);\n    }\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 49,
      "endLine": 49,
      "before": "() => {\n  tail = tail.slice(0, -1); // history file always ends in newline\n  // $FlowIssue: slice can return a string\n\n  tail = tail.split('\\n');\n\n  if (offset > 0 && tail.length < maxLength) {\n    // eslint-disable-next-line no-mixed-operators\n    onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n  } else {\n    tail = tail.slice(-maxLength);\n    tail.reverse();\n    cb(tail);\n  }\n}",
      "after": "async () => {\n  tail = tail.slice(0, -1); // history file always ends in newline\n  // $FlowIssue: slice can return a string\n\n  tail = tail.split('\\n');\n\n  if (offset > 0 && tail.length < maxLength) {\n    // eslint-disable-next-line no-mixed-operators\n    await onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n  } else {\n    tail = tail.slice(-maxLength);\n    tail.reverse();\n    cb(tail);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 96,
      "endLine": 104,
      "before": "(resolve, reject) => {\n  let bytesRead = 0;\n  resp.body.on('error', reject).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}",
      "after": "async (resolve, reject) => {\n  let bytesRead = 0;\n  await (await resp.body.on('error', reject)).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  await gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  await (await ws.on('error', reject)).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 96,
      "endLine": 97,
      "before": "(resolve, reject) => {\n  let bytesRead = 0;\n  resp.body.on('error', reject).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}",
      "after": "async (resolve, reject) => {\n  let bytesRead = 0;\n  await (await resp.body.on('error', reject)).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  await gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  await (await ws.on('error', reject)).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 108,
      "endLine": 109,
      "before": "(resolve, reject) => {\n  let bytesRead = 0;\n  resp.body.on('error', reject).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}",
      "after": "async (resolve, reject) => {\n  let bytesRead = 0;\n  await (await resp.body.on('error', reject)).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  await gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  await (await ws.on('error', reject)).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 113,
      "endLine": 118,
      "before": "(resolve, reject) => {\n  let bytesRead = 0;\n  resp.body.on('error', reject).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}",
      "after": "async (resolve, reject) => {\n  let bytesRead = 0;\n  await (await resp.body.on('error', reject)).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  await gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  await (await ws.on('error', reject)).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 433,
      "endLine": 435,
      "before": "function processStdin(): void {\n  let code = '';\n  process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?",
      "after": "async function processStdin(): void {\n  let code = '';\n  await process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  await process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  await process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 436,
      "endLine": 439,
      "before": "function processStdin(): void {\n  let code = '';\n  process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?",
      "after": "async function processStdin(): void {\n  let code = '';\n  await process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  await process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  await process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 438,
      "endLine": 438,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 439,
      "endLine": 439,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 440,
      "endLine": 440,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 441,
      "endLine": 441,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 37,
      "endLine": 40,
      "before": "function onLoad(path: string, fd: number, maxLength: number, offset: number, cb: (ret: string[]) => void): void {\n  const rs = fs.createReadStream(path, {\n    encoding: 'utf-8',\n    fd,\n    start: Math.max(offset, 0),\n    autoClose: false\n  });\n  let tail = '';\n  rs.on('data', (chunk: string) => {\n    // $FlowIssue: slice can return a string\n    tail += chunk;\n  });\n  rs.on('end', () => {\n    tail = tail.slice(0, -1); // history file always ends in newline\n    // $FlowIssue: slice can return a string\n\n    tail = tail.split('\\n');\n\n    if (offset > 0 && tail.length < maxLength) {\n      // eslint-disable-next-line no-mixed-operators\n      onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n    } else {\n      tail = tail.slice(-maxLength);\n      tail.reverse();\n      cb(tail);\n    }\n  });\n}",
      "after": "async function onLoad(path: string, fd: number, maxLength: number, offset: number, cb: (ret: string[]) => void): void {\n  const rs = fs.createReadStream(path, {\n    encoding: 'utf-8',\n    fd,\n    start: Math.max(offset, 0),\n    autoClose: false\n  });\n  let tail = '';\n  await rs.on('data', (chunk: string) => {\n    // $FlowIssue: slice can return a string\n    tail += chunk;\n  });\n  rs.on('end', async () => {\n    tail = tail.slice(0, -1); // history file always ends in newline\n    // $FlowIssue: slice can return a string\n\n    tail = tail.split('\\n');\n\n    if (offset > 0 && tail.length < maxLength) {\n      // eslint-disable-next-line no-mixed-operators\n      await onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n    } else {\n      tail = tail.slice(-maxLength);\n      tail.reverse();\n      cb(tail);\n    }\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 42,
      "endLine": 55,
      "before": "function onLoad(path: string, fd: number, maxLength: number, offset: number, cb: (ret: string[]) => void): void {\n  const rs = fs.createReadStream(path, {\n    encoding: 'utf-8',\n    fd,\n    start: Math.max(offset, 0),\n    autoClose: false\n  });\n  let tail = '';\n  rs.on('data', (chunk: string) => {\n    // $FlowIssue: slice can return a string\n    tail += chunk;\n  });\n  rs.on('end', () => {\n    tail = tail.slice(0, -1); // history file always ends in newline\n    // $FlowIssue: slice can return a string\n\n    tail = tail.split('\\n');\n\n    if (offset > 0 && tail.length < maxLength) {\n      // eslint-disable-next-line no-mixed-operators\n      onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n    } else {\n      tail = tail.slice(-maxLength);\n      tail.reverse();\n      cb(tail);\n    }\n  });\n}",
      "after": "async function onLoad(path: string, fd: number, maxLength: number, offset: number, cb: (ret: string[]) => void): void {\n  const rs = fs.createReadStream(path, {\n    encoding: 'utf-8',\n    fd,\n    start: Math.max(offset, 0),\n    autoClose: false\n  });\n  let tail = '';\n  await rs.on('data', (chunk: string) => {\n    // $FlowIssue: slice can return a string\n    tail += chunk;\n  });\n  await rs.on('end', async () => {\n    tail = tail.slice(0, -1); // history file always ends in newline\n    // $FlowIssue: slice can return a string\n\n    tail = tail.split('\\n');\n\n    if (offset > 0 && tail.length < maxLength) {\n      // eslint-disable-next-line no-mixed-operators\n      await onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n    } else {\n      tail = tail.slice(-maxLength);\n      tail.reverse();\n      cb(tail);\n    }\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 89,
      "endLine": 89,
      "before": "(err: ?Error, stat: fs.Stats) => {\n  const totalSize = stat.size;\n\n  if (totalSize > maxDiskSize) {\n    const rename = function rename(): void {\n      fs.rename(path, `${path}.old`, () => {\n        // $FlowIssue: mode is optional\n        fs.open(path, 'a+', (e: ?ErrnoError, ffd: number) => {\n          loadHistory(path, ffd, maxLength, cb);\n        });\n      });\n    };\n\n    if (fd != null) {\n      fs.close(fd, () => {\n        const oldPath = `${path}.old`;\n        fs.exists(oldPath, (exists: boolean) => {\n          if (exists) {\n            fs.unlink(oldPath, rename);\n          } else {\n            rename();\n          }\n        });\n      });\n    }\n  } else {\n    onLoad(path, fd, maxLength, totalSize, cb);\n  }\n}",
      "after": "async (err: ?Error, stat: fs.Stats) => {\n  const totalSize = stat.size;\n\n  if (totalSize > maxDiskSize) {\n    const rename = function rename(): void {\n      fs.rename(path, `${path}.old`, () => {\n        // $FlowIssue: mode is optional\n        fs.open(path, 'a+', (e: ?ErrnoError, ffd: number) => {\n          loadHistory(path, ffd, maxLength, cb);\n        });\n      });\n    };\n\n    if (fd != null) {\n      fs.close(fd, () => {\n        const oldPath = `${path}.old`;\n        fs.exists(oldPath, (exists: boolean) => {\n          if (exists) {\n            fs.unlink(oldPath, rename);\n          } else {\n            rename();\n          }\n        });\n      });\n    }\n  } else {\n    await onLoad(path, fd, maxLength, totalSize, cb);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 64,
      "endLine": 91,
      "before": "function loadHistory(path: string, fd: number, maxLength: number, cb: (ret: string[]) => void): void {\n  fs.stat(path, (err: ?Error, stat: fs.Stats) => {\n    const totalSize = stat.size;\n\n    if (totalSize > maxDiskSize) {\n      const rename = function rename(): void {\n        fs.rename(path, `${path}.old`, () => {\n          // $FlowIssue: mode is optional\n          fs.open(path, 'a+', (e: ?ErrnoError, ffd: number) => {\n            loadHistory(path, ffd, maxLength, cb);\n          });\n        });\n      };\n\n      if (fd != null) {\n        fs.close(fd, () => {\n          const oldPath = `${path}.old`;\n          fs.exists(oldPath, (exists: boolean) => {\n            if (exists) {\n              fs.unlink(oldPath, rename);\n            } else {\n              rename();\n            }\n          });\n        });\n      }\n    } else {\n      onLoad(path, fd, maxLength, totalSize, cb);\n    }\n  });\n}",
      "after": "async function loadHistory(path: string, fd: number, maxLength: number, cb: (ret: string[]) => void): void {\n  await fs.stat(path, async (err: ?Error, stat: fs.Stats) => {\n    const totalSize = stat.size;\n\n    if (totalSize > maxDiskSize) {\n      const rename = function rename(): void {\n        fs.rename(path, `${path}.old`, () => {\n          // $FlowIssue: mode is optional\n          fs.open(path, 'a+', (e: ?ErrnoError, ffd: number) => {\n            loadHistory(path, ffd, maxLength, cb);\n          });\n        });\n      };\n\n      if (fd != null) {\n        fs.close(fd, () => {\n          const oldPath = `${path}.old`;\n          fs.exists(oldPath, (exists: boolean) => {\n            if (exists) {\n              fs.unlink(oldPath, rename);\n            } else {\n              rename();\n            }\n          });\n        });\n      }\n    } else {\n      await onLoad(path, fd, maxLength, totalSize, cb);\n    }\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 71,
      "endLine": 71,
      "before": "(e: ?ErrnoError, ffd: number) => {\n  loadHistory(path, ffd, maxLength, cb);\n}",
      "after": "async (e: ?ErrnoError, ffd: number) => {\n  await loadHistory(path, ffd, maxLength, cb);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 68,
      "endLine": 73,
      "before": "function rename(): void {\n  fs.rename(path, `${path}.old`, () => {\n    // $FlowIssue: mode is optional\n    fs.open(path, 'a+', (e: ?ErrnoError, ffd: number) => {\n      loadHistory(path, ffd, maxLength, cb);\n    });\n  });\n}",
      "after": "async function rename(): void {\n  await fs.rename(path, `${path}.old`, () => {\n    // $FlowIssue: mode is optional\n    fs.open(path, 'a+', async (e: ?ErrnoError, ffd: number) => {\n      await loadHistory(path, ffd, maxLength, cb);\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 123,
      "endLine": 125,
      "before": "(fd: number) => {\n  loadHistory(path, fd, historySize, (history: string[]) => {\n    rl.history.push(...history);\n  });\n}",
      "after": "async (fd: number) => {\n  await loadHistory(path, fd, historySize, (history: string[]) => {\n    rl.history.push(...history);\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 65,
      "endLine": 65,
      "before": "() => {\n  replHistory({\n    terminal: true\n  });\n  expect(readline.createInterface).toHaveBeenCalled();\n  expect(fs.createWriteStream).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await replHistory({\n    terminal: true\n  });\n  expect(readline.createInterface).toHaveBeenCalled();\n  expect(fs.createWriteStream).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 72,
      "endLine": 72,
      "before": "() => {\n  replHistory({});\n  expect(fs.createWriteStream).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  await replHistory({});\n  expect(fs.createWriteStream).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 78,
      "endLine": 82,
      "before": "() => {\n  const rl = replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n  expect(rl.history.length).toBeGreaterThan(0);\n}",
      "after": "async () => {\n  const rl = await replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n  expect(rl.history.length).toBeGreaterThan(0);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 89,
      "endLine": 92,
      "before": "() => {\n  const rl = replHistory({\n    terminal: true,\n    historySize: 10\n  });\n  expect(fs.stat).not.toHaveBeenCalled();\n  expect(rl.history).toEqual([]);\n}",
      "after": "async () => {\n  const rl = await replHistory({\n    terminal: true,\n    historySize: 10\n  });\n  expect(fs.stat).not.toHaveBeenCalled();\n  expect(rl.history).toEqual([]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 99,
      "endLine": 103,
      "before": "() => {\n  const rl = replHistory({\n    terminal: true,\n    historySize: 10,\n    path: 'nonExistent'\n  });\n  expect(rl.history).toEqual(['']);\n}",
      "after": "async () => {\n  const rl = await replHistory({\n    terminal: true,\n    historySize: 10,\n    path: 'nonExistent'\n  });\n  expect(rl.history).toEqual(['']);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 109,
      "endLine": 112,
      "before": "() => {\n  const rl = replHistory({\n    terminal: true,\n    path: 'foo'\n  });\n  expect(fs.stat).not.toHaveBeenCalled();\n  expect(rl.history).toEqual([]);\n}",
      "after": "async () => {\n  const rl = await replHistory({\n    terminal: true,\n    path: 'foo'\n  });\n  expect(fs.stat).not.toHaveBeenCalled();\n  expect(rl.history).toEqual([]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 121,
      "endLine": 125,
      "before": "() => {\n  const rl = replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n\n  rl._addHistory();\n\n  expect(streamWrite).toHaveBeenCalledTimes(1);\n  expect(streamWrite).toHaveBeenCalledWith('qux\\n', 'utf8');\n}",
      "after": "async () => {\n  const rl = await replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n\n  rl._addHistory();\n\n  expect(streamWrite).toHaveBeenCalledTimes(1);\n  expect(streamWrite).toHaveBeenCalledWith('qux\\n', 'utf8');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 154,
      "endLine": 158,
      "before": "() => {\n  fs.exists = jest.fn((_: string, cb: ((ret: boolean) => void)) => cb(false));\n  replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n  expect(fs.rename).toHaveBeenCalled();\n  expect(fs.unlink).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  fs.exists = jest.fn((_: string, cb: ((ret: boolean) => void)) => cb(false));\n  await replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n  expect(fs.rename).toHaveBeenCalled();\n  expect(fs.unlink).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 167,
      "endLine": 171,
      "before": "() => {\n  fs.exists = jest.fn((_: string, cb: ((ret: boolean) => void)) => cb(true));\n  replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n  expect(fs.unlink).toHaveBeenCalled();\n  expect(fs.rename).toHaveBeenCalled();\n}",
      "after": "async () => {\n  fs.exists = jest.fn((_: string, cb: ((ret: boolean) => void)) => cb(true));\n  await replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n  expect(fs.unlink).toHaveBeenCalled();\n  expect(fs.rename).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 419,
      "endLine": 426,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = await replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 122,
      "endLine": 126,
      "before": "function createInterface(options: replHistory$Opts): readline$Interface {\n  const {\n    path,\n    historySize,\n    terminal\n  } = options;\n  const rl = readline.createInterface(options);\n\n  if (terminal) {\n    const stream = fs.createWriteStream(path, {\n      flags: 'a+',\n      defaultEncoding: 'utf8'\n    }); // $FlowIssue: private property\n\n    const oldAddHistory = rl._addHistory; // $FlowIssue: private property\n\n    rl._addHistory = function _addHistory(): string {\n      const [last] = rl.history;\n      const line = oldAddHistory.call(rl);\n\n      if (line.length > 0 && line !== last) {\n        stream.write(`${line}\\n`, 'utf8');\n      }\n\n      return line;\n    };\n\n    if (path != null && historySize != null) {\n      stream.on('open', (fd: number) => {\n        loadHistory(path, fd, historySize, (history: string[]) => {\n          rl.history.push(...history);\n        });\n      });\n    }\n  }\n\n  return rl;\n}",
      "after": "async function createInterface(options: replHistory$Opts): readline$Interface {\n  const {\n    path,\n    historySize,\n    terminal\n  } = options;\n  const rl = readline.createInterface(options);\n\n  if (terminal) {\n    const stream = fs.createWriteStream(path, {\n      flags: 'a+',\n      defaultEncoding: 'utf8'\n    }); // $FlowIssue: private property\n\n    const oldAddHistory = rl._addHistory; // $FlowIssue: private property\n\n    rl._addHistory = function _addHistory(): string {\n      const [last] = rl.history;\n      const line = oldAddHistory.call(rl);\n\n      if (line.length > 0 && line !== last) {\n        stream.write(`${line}\\n`, 'utf8');\n      }\n\n      return line;\n    };\n\n    if (path != null && historySize != null) {\n      await stream.on('open', async (fd: number) => {\n        await loadHistory(path, fd, historySize, (history: string[]) => {\n          rl.history.push(...history);\n        });\n      });\n    }\n  }\n\n  return rl;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 24,
      "endLine": 26,
      "before": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nfunction openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  socket.on('close', () => {\n    deleteSession(session);\n  });\n  socket.on('error', () => {});\n  rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle",
      "after": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nasync function openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  await socket.on('close', () => {\n    deleteSession(session);\n  });\n  socket.on('error', () => {});\n  rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(await createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 52,
      "endLine": 52,
      "before": "// Calls the `accept` function on the socket and handles the socket lifecycle\nfunction handleConnection(socket: net$Socket, accept: AcceptFn, args: Array<mixed> = []): number {\n  if (typeof accept === 'string') {\n    runAcceptFN(accept, socket, args);\n  } else {\n    accept(socket);\n  } // The index needs to be unique for the socket server, but not for anyone else.\n  // For that reason we're using a module global `sessionCount` variable\n\n\n  socket.on('close', () => {\n    delete sockets[sessionCount];\n  });\n  sockets[sessionCount] = socket;\n  sessionCount += 1;\n  return sessionCount;\n}",
      "after": "// Calls the `accept` function on the socket and handles the socket lifecycle\nasync function handleConnection(socket: net$Socket, accept: AcceptFn, args: Array<mixed> = []): number {\n  if (typeof accept === 'string') {\n    runAcceptFN(accept, socket, args);\n  } else {\n    await accept(socket);\n  } // The index needs to be unique for the socket server, but not for anyone else.\n  // For that reason we're using a module global `sessionCount` variable\n\n\n  socket.on('close', () => {\n    delete sockets[sessionCount];\n  });\n  sockets[sessionCount] = socket;\n  sessionCount += 1;\n  return sessionCount;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 93,
      "endLine": 93,
      "before": "(resolve: ((mixed) => void), reject: ((Error) => void)) => {\n  socketServer = net.createServer((socket: net$Socket) => handleConnection(socket, accept, args)); // $FlowIssue - wrong type definitions for `listen`\n\n  socketServer.listen(port, host, () => {\n    resolve();\n    process.on('SIGTERM', close);\n    process.on('SIGHUP', close);\n  }).on('error', reject);\n}",
      "after": "async (resolve: ((mixed) => void), reject: ((Error) => void)) => {\n  socketServer = net.createServer(async (socket: net$Socket) => await handleConnection(socket, accept, args)); // $FlowIssue - wrong type definitions for `listen`\n\n  socketServer.listen(port, host, () => {\n    resolve();\n    process.on('SIGTERM', close);\n    process.on('SIGHUP', close);\n  }).on('error', reject);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 28,
      "endLine": 28,
      "before": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nfunction openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  socket.on('close', () => {\n    deleteSession(session);\n  });\n  socket.on('error', () => {});\n  rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle",
      "after": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nasync function openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  await socket.on('close', () => {\n    deleteSession(session);\n  });\n  await socket.on('error', () => {});\n  rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(await createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 30,
      "endLine": 35,
      "before": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nfunction openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  socket.on('close', () => {\n    deleteSession(session);\n  });\n  socket.on('error', () => {});\n  rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle",
      "after": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nasync function openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  await socket.on('close', () => {\n    deleteSession(session);\n  });\n  await socket.on('error', () => {});\n  await rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(await createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 37,
      "endLine": 37,
      "before": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nfunction openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  socket.on('close', () => {\n    deleteSession(session);\n  });\n  socket.on('error', () => {});\n  rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle",
      "after": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nasync function openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  await socket.on('close', () => {\n    deleteSession(session);\n  });\n  await socket.on('error', () => {});\n  await rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  await rl.on('close', () => socket.destroy());\n  rl.output.write(await createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 57,
      "endLine": 59,
      "before": "// Calls the `accept` function on the socket and handles the socket lifecycle\nfunction handleConnection(socket: net$Socket, accept: AcceptFn, args: Array<mixed> = []): number {\n  if (typeof accept === 'string') {\n    runAcceptFN(accept, socket, args);\n  } else {\n    accept(socket);\n  } // The index needs to be unique for the socket server, but not for anyone else.\n  // For that reason we're using a module global `sessionCount` variable\n\n\n  socket.on('close', () => {\n    delete sockets[sessionCount];\n  });\n  sockets[sessionCount] = socket;\n  sessionCount += 1;\n  return sessionCount;\n}",
      "after": "// Calls the `accept` function on the socket and handles the socket lifecycle\nasync function handleConnection(socket: net$Socket, accept: AcceptFn, args: Array<mixed> = []): number {\n  if (typeof accept === 'string') {\n    runAcceptFN(accept, socket, args);\n  } else {\n    await accept(socket);\n  } // The index needs to be unique for the socket server, but not for anyone else.\n  // For that reason we're using a module global `sessionCount` variable\n\n\n  await socket.on('close', () => {\n    delete sockets[sessionCount];\n  });\n  sockets[sessionCount] = socket;\n  sessionCount += 1;\n  return sessionCount;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 97,
      "endLine": 103,
      "before": "(resolve: ((mixed) => void), reject: ((Error) => void)) => {\n  socketServer = net.createServer((socket: net$Socket) => handleConnection(socket, accept, args)); // $FlowIssue - wrong type definitions for `listen`\n\n  socketServer.listen(port, host, () => {\n    resolve();\n    process.on('SIGTERM', close);\n    process.on('SIGHUP', close);\n  }).on('error', reject);\n}",
      "after": "async (resolve: ((mixed) => void), reject: ((Error) => void)) => {\n  socketServer = net.createServer(async (socket: net$Socket) => await handleConnection(socket, accept, args)); // $FlowIssue - wrong type definitions for `listen`\n\n  await socketServer.listen(port, host, () => {\n    resolve();\n    process.on('SIGTERM', close);\n    process.on('SIGHUP', close);\n  }).on('error', reject);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 100,
      "endLine": 100,
      "before": "() => {\n  resolve();\n  process.on('SIGTERM', close);\n  process.on('SIGHUP', close);\n}",
      "after": "async () => {\n  resolve();\n  await process.on('SIGTERM', close);\n  process.on('SIGHUP', close);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 101,
      "endLine": 101,
      "before": "() => {\n  resolve();\n  process.on('SIGTERM', close);\n  process.on('SIGHUP', close);\n}",
      "after": "async () => {\n  resolve();\n  await process.on('SIGTERM', close);\n  await process.on('SIGHUP', close);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/bundle.js",
      "startLine": 115,
      "endLine": 117,
      "before": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nfunction bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  ws.on('close', function () {\n    var source = fs.readFileSync(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}",
      "after": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nasync function bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  await bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  ws.on('close', async function () {\n    var source = await fs.promises.readFile(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 199,
      "endLine": 199,
      "before": "/**\n * Bundle the application into one script\n **/\nfunction combineProject(next) {\n  if (options.noBundle) {\n    _log('using provided bundle %s since noBundle is true', options.input);\n\n    const source = fs.readFileSync(options.input, 'utf8');\n    const thirdPartyMain = `\nif (!process.send) {\n  process.argv.splice(1, 0, 'nexe.js');\n}\n\nconst Module = require('module');\nconst initModule = new Module(process.execPath, null);\ninitModule.paths = Module._nodeModulePaths(process.cwd());\nreturn initModule._compile(${JSON.stringify(source)}, process.execPath);\n        `;\n    fs.writeFileSync(path.join(nodeCompiler.dir, 'lib', '_third_party_main.js'), thirdPartyMain);\n    next();\n  } else {\n    _log('bundle %s', options.input);\n\n    bundle(options.input, nodeCompiler.dir, options, next);\n  }\n}",
      "after": "/**\n * Bundle the application into one script\n **/\nasync function combineProject(next) {\n  if (options.noBundle) {\n    _log('using provided bundle %s since noBundle is true', options.input);\n\n    const source = fs.readFileSync(options.input, 'utf8');\n    const thirdPartyMain = `\nif (!process.send) {\n  process.argv.splice(1, 0, 'nexe.js');\n}\n\nconst Module = require('module');\nconst initModule = new Module(process.execPath, null);\ninitModule.paths = Module._nodeModulePaths(process.cwd());\nreturn initModule._compile(${JSON.stringify(source)}, process.execPath);\n        `;\n    fs.writeFileSync(path.join(nodeCompiler.dir, 'lib', '_third_party_main.js'), thirdPartyMain);\n    next();\n  } else {\n    _log('bundle %s', options.input);\n\n    await bundle(options.input, nodeCompiler.dir, options, next);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/bundle.js",
      "startLine": 119,
      "endLine": 123,
      "before": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nfunction bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  ws.on('close', function () {\n    var source = fs.readFileSync(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}",
      "after": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nasync function bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  await bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  await ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  ws.on('close', async function () {\n    var source = await fs.promises.readFile(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/bundle.js",
      "startLine": 125,
      "endLine": 138,
      "before": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nfunction bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  ws.on('close', function () {\n    var source = fs.readFileSync(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}",
      "after": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nasync function bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  await bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  await ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  await ws.on('close', async function () {\n    var source = await fs.promises.readFile(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 110,
      "endLine": 122,
      "before": "/**\n *check relevant options\n */\nfunction checkOpts(next) {\n  /* failsafe */\n  if (options === undefined) {\n    _log('error', 'no options given to .compile()');\n\n    process.exit();\n  }\n  /**\n   * Have we been given a custom flag for python executable?\n   **/\n\n\n  if (options.python !== 'python' && options.python !== '' && options.python !== undefined) {\n    if (isWin) {\n      isPy = options.python.replace(/\\//gm, '\\\\'); // use windows file paths, batch is sensitive.\n    } else {\n      isPy = options.python;\n    }\n\n    _log('set python as ' + isPy);\n  } else {\n    isPy = 'python';\n  } // remove dots\n\n\n  options.framework = options.framework.replace(/\\./g, ''); // set outter-scope framework variable.\n\n  framework = options.framework;\n\n  _log('framework => ' + framework);\n\n  version = options.nodeVersion; // better framework vc\n  // check iojs version\n\n  if (framework === 'iojs' && version === 'latest') {\n    _log('fetching iojs versions');\n\n    mkdirp(options.nodeTempDir); // make temp dir, probably repetive.\n    // create write stream so we have control over events\n\n    var output = fs.createWriteStream(path.join(options.nodeTempDir, 'iojs-versions.json'));\n    request.get('https://iojs.org/dist/index.json').pipe(output);\n    output.on('close', function () {\n      _log('done');\n\n      var f = fs.readFileSync(path.join(options.nodeTempDir, 'iojs-versions.json'));\n      f = JSON.parse(f);\n      version = f[0].version.replace('v', '');\n\n      _log('iojs latest => ' + version); // continue down along the async road\n\n\n      next();\n    });\n  } else {\n    next();\n  }\n}",
      "after": "/**\n *check relevant options\n */\nasync function checkOpts(next) {\n  /* failsafe */\n  if (options === undefined) {\n    _log('error', 'no options given to .compile()');\n\n    process.exit();\n  }\n  /**\n   * Have we been given a custom flag for python executable?\n   **/\n\n\n  if (options.python !== 'python' && options.python !== '' && options.python !== undefined) {\n    if (isWin) {\n      isPy = options.python.replace(/\\//gm, '\\\\'); // use windows file paths, batch is sensitive.\n    } else {\n      isPy = options.python;\n    }\n\n    _log('set python as ' + isPy);\n  } else {\n    isPy = 'python';\n  } // remove dots\n\n\n  options.framework = options.framework.replace(/\\./g, ''); // set outter-scope framework variable.\n\n  framework = options.framework;\n\n  _log('framework => ' + framework);\n\n  version = options.nodeVersion; // better framework vc\n  // check iojs version\n\n  if (framework === 'iojs' && version === 'latest') {\n    _log('fetching iojs versions');\n\n    mkdirp(options.nodeTempDir); // make temp dir, probably repetive.\n    // create write stream so we have control over events\n\n    var output = fs.createWriteStream(path.join(options.nodeTempDir, 'iojs-versions.json'));\n    request.get('https://iojs.org/dist/index.json').pipe(output);\n    await output.on('close', function () {\n      _log('done');\n\n      var f = fs.readFileSync(path.join(options.nodeTempDir, 'iojs-versions.json'));\n      f = JSON.parse(f);\n      version = f[0].version.replace('v', '');\n\n      _log('iojs latest => ' + version); // continue down along the async road\n\n\n      next();\n    });\n  } else {\n    next();\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 416,
      "endLine": 418,
      "before": "/**\n * download node into the target directory\n */\nfunction downloadNode(next) {\n  if (fs.existsSync(nodeFilePath)) return next();\n  var uri = framework;\n\n  if (framework === 'node') {\n    uri = 'nodejs'; // if node, use nodejs uri\n  } else if (framework === 'nodejs') {\n    framework = 'node'; // support nodejs, and node, as framework.\n  }\n\n  var type = global.type;\n  var url,\n      prefix = 'https://' + uri + '.org/dist';\n\n  if (version === 'latest') {\n    url = prefix + '/' + framework + '-' + version + '.tar.gz';\n  } else {\n    url = prefix + '/v' + version + '/' + framework + '-v' + version + '.tar.gz';\n  }\n\n  _log('downloading %s', url);\n\n  var output = fs.createWriteStream(nodeFilePath, {\n    flags: 'w+'\n  }); // need to set user-agent to bypass some corporate firewalls\n\n  var requestOptions = {\n    url: url,\n    headers: {\n      'User-Agent': 'Node.js'\n    }\n  };\n\n  _logProgress(request(requestOptions)).pipe(output);\n\n  output.on('close', function () {\n    next();\n  });\n}",
      "after": "/**\n * download node into the target directory\n */\nasync function downloadNode(next) {\n  if (fs.existsSync(nodeFilePath)) return next();\n  var uri = framework;\n\n  if (framework === 'node') {\n    uri = 'nodejs'; // if node, use nodejs uri\n  } else if (framework === 'nodejs') {\n    framework = 'node'; // support nodejs, and node, as framework.\n  }\n\n  var type = global.type;\n  var url,\n      prefix = 'https://' + uri + '.org/dist';\n\n  if (version === 'latest') {\n    url = prefix + '/' + framework + '-' + version + '.tar.gz';\n  } else {\n    url = prefix + '/v' + version + '/' + framework + '-v' + version + '.tar.gz';\n  }\n\n  _log('downloading %s', url);\n\n  var output = fs.createWriteStream(nodeFilePath, {\n    flags: 'w+'\n  }); // need to set user-agent to bypass some corporate firewalls\n\n  var requestOptions = {\n    url: url,\n    headers: {\n      'User-Agent': 'Node.js'\n    }\n  };\n\n  _logProgress(request(requestOptions)).pipe(output);\n\n  await output.on('close', function () {\n    next();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 438,
      "endLine": 438,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = await replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 439,
      "endLine": 439,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = await replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 440,
      "endLine": 440,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = await replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 441,
      "endLine": 441,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = await replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 443,
      "endLine": 445,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = await replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 37,
      "endLine": 40,
      "before": "function onLoad(path: string, fd: number, maxLength: number, offset: number, cb: (ret: string[]) => void): void {\n  const rs = fs.createReadStream(path, {\n    encoding: 'utf-8',\n    fd,\n    start: Math.max(offset, 0),\n    autoClose: false\n  });\n  let tail = '';\n  rs.on('data', (chunk: string) => {\n    // $FlowIssue: slice can return a string\n    tail += chunk;\n  });\n  rs.on('end', () => {\n    tail = tail.slice(0, -1); // history file always ends in newline\n    // $FlowIssue: slice can return a string\n\n    tail = tail.split('\\n');\n\n    if (offset > 0 && tail.length < maxLength) {\n      // eslint-disable-next-line no-mixed-operators\n      onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n    } else {\n      tail = tail.slice(-maxLength);\n      tail.reverse();\n      cb(tail);\n    }\n  });\n}",
      "after": "async function onLoad(path: string, fd: number, maxLength: number, offset: number, cb: (ret: string[]) => void): void {\n  const rs = fs.createReadStream(path, {\n    encoding: 'utf-8',\n    fd,\n    start: Math.max(offset, 0),\n    autoClose: false\n  });\n  let tail = '';\n  await rs.on('data', (chunk: string) => {\n    // $FlowIssue: slice can return a string\n    tail += chunk;\n  });\n  await rs.on('end', async () => {\n    tail = tail.slice(0, -1); // history file always ends in newline\n    // $FlowIssue: slice can return a string\n\n    tail = tail.split('\\n');\n\n    if (offset > 0 && tail.length < maxLength) {\n      // eslint-disable-next-line no-mixed-operators\n      await onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n    } else {\n      tail = tail.slice(-maxLength);\n      tail.reverse();\n      cb(tail);\n    }\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 24,
      "endLine": 26,
      "before": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nfunction openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  socket.on('close', () => {\n    deleteSession(session);\n  });\n  socket.on('error', () => {});\n  rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle",
      "after": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nasync function openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  await socket.on('close', () => {\n    deleteSession(session);\n  });\n  await socket.on('error', () => {});\n  await rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  await rl.on('close', () => socket.destroy());\n  rl.output.write(await createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 28,
      "endLine": 28,
      "before": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nfunction openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  socket.on('close', () => {\n    deleteSession(session);\n  });\n  socket.on('error', () => {});\n  rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle",
      "after": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nasync function openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  await socket.on('close', () => {\n    deleteSession(session);\n  });\n  await socket.on('error', () => {});\n  await rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  await rl.on('close', () => socket.destroy());\n  rl.output.write(await createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 30,
      "endLine": 35,
      "before": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nfunction openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  socket.on('close', () => {\n    deleteSession(session);\n  });\n  socket.on('error', () => {});\n  rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle",
      "after": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nasync function openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  await socket.on('close', () => {\n    deleteSession(session);\n  });\n  await socket.on('error', () => {});\n  await rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  await rl.on('close', () => socket.destroy());\n  rl.output.write(await createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 97,
      "endLine": 103,
      "before": "(resolve: ((mixed) => void), reject: ((Error) => void)) => {\n  socketServer = net.createServer((socket: net$Socket) => handleConnection(socket, accept, args)); // $FlowIssue - wrong type definitions for `listen`\n\n  socketServer.listen(port, host, () => {\n    resolve();\n    process.on('SIGTERM', close);\n    process.on('SIGHUP', close);\n  }).on('error', reject);\n}",
      "after": "async (resolve: ((mixed) => void), reject: ((Error) => void)) => {\n  socketServer = net.createServer(async (socket: net$Socket) => await handleConnection(socket, accept, args)); // $FlowIssue - wrong type definitions for `listen`\n\n  await socketServer.listen(port, host, async () => {\n    resolve();\n    await process.on('SIGTERM', close);\n    await process.on('SIGHUP', close);\n  }).on('error', reject);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 100,
      "endLine": 100,
      "before": "() => {\n  resolve();\n  process.on('SIGTERM', close);\n  process.on('SIGHUP', close);\n}",
      "after": "async () => {\n  resolve();\n  await process.on('SIGTERM', close);\n  await process.on('SIGHUP', close);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/bundle.js",
      "startLine": 115,
      "endLine": 117,
      "before": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nfunction bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  ws.on('close', function () {\n    var source = fs.readFileSync(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}",
      "after": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nasync function bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  await bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  await ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  await ws.on('close', async function () {\n    var source = await fs.promises.readFile(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/bundle.js",
      "startLine": 119,
      "endLine": 123,
      "before": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nfunction bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  ws.on('close', function () {\n    var source = fs.readFileSync(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}",
      "after": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nasync function bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  await bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  await ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  await ws.on('close', async function () {\n    var source = await fs.promises.readFile(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 444,
      "endLine": 481,
      "before": "/**\n * unzip in the same directory\n */\nfunction unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    extract.on('entry', function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      write.on('close', function () {\n        return callback();\n      });\n      stream.on('error', function (err) {\n        return onError(err);\n      });\n      write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}",
      "after": "/**\n * unzip in the same directory\n */\nasync function unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    await extract.on('entry', function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      write.on('close', function () {\n        return callback();\n      });\n      stream.on('error', function (err) {\n        return onError(err);\n      });\n      write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 132,
      "endLine": 139,
      "before": "/**\n * first download node\n */\nfunction downloadNode(next) {\n  _downloadNode(version, options.nodeTempDir, options.nodeConfigureArgs, options.nodeMakeArgs, options.nodeVCBuildArgs, next);\n}",
      "after": "/**\n * first download node\n */\nasync function downloadNode(next) {\n  await _downloadNode(version, options.nodeTempDir, options.nodeConfigureArgs, options.nodeMakeArgs, options.nodeVCBuildArgs, next);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 468,
      "endLine": 470,
      "before": "function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  write.on('close', function () {\n    return callback();\n  });\n  stream.on('error', function (err) {\n    return onError(err);\n  });\n  write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}",
      "after": "async function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  await write.on('close', function () {\n    return callback();\n  });\n  stream.on('error', function (err) {\n    return onError(err);\n  });\n  write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 444,
      "endLine": 481,
      "before": "/**\n * unzip in the same directory\n */\nfunction unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    extract.on('entry', function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      write.on('close', function () {\n        return callback();\n      });\n      stream.on('error', function (err) {\n        return onError(err);\n      });\n      write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}",
      "after": "/**\n * unzip in the same directory\n */\nasync function unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    await extract.on('entry', async function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      await write.on('close', function () {\n        return callback();\n      });\n      stream.on('error', function (err) {\n        return onError(err);\n      });\n      write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 472,
      "endLine": 474,
      "before": "function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  write.on('close', function () {\n    return callback();\n  });\n  stream.on('error', function (err) {\n    return onError(err);\n  });\n  write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}",
      "after": "async function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  await write.on('close', function () {\n    return callback();\n  });\n  await stream.on('error', function (err) {\n    return onError(err);\n  });\n  write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 476,
      "endLine": 478,
      "before": "function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  write.on('close', function () {\n    return callback();\n  });\n  stream.on('error', function (err) {\n    return onError(err);\n  });\n  write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}",
      "after": "async function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  await write.on('close', function () {\n    return callback();\n  });\n  await stream.on('error', function (err) {\n    return onError(err);\n  });\n  await write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 483,
      "endLine": 486,
      "before": "/**\n * unzip in the same directory\n */\nfunction unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    extract.on('entry', function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      write.on('close', function () {\n        return callback();\n      });\n      stream.on('error', function (err) {\n        return onError(err);\n      });\n      write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}",
      "after": "/**\n * unzip in the same directory\n */\nasync function unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    await extract.on('entry', async function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      await write.on('close', function () {\n        return callback();\n      });\n      await stream.on('error', function (err) {\n        return onError(err);\n      });\n      await write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    await extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 499,
      "endLine": 501,
      "before": "/**\n * unzip in the same directory\n */\nfunction unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    extract.on('entry', function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      write.on('close', function () {\n        return callback();\n      });\n      stream.on('error', function (err) {\n        return onError(err);\n      });\n      write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}",
      "after": "/**\n * unzip in the same directory\n */\nasync function unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    await extract.on('entry', async function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      await write.on('close', function () {\n        return callback();\n      });\n      await stream.on('error', function (err) {\n        return onError(err);\n      });\n      await write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    await extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    await tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 502,
      "endLine": 502,
      "before": "/**\n * unzip in the same directory\n */\nfunction unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    extract.on('entry', function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      write.on('close', function () {\n        return callback();\n      });\n      stream.on('error', function (err) {\n        return onError(err);\n      });\n      write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}",
      "after": "/**\n * unzip in the same directory\n */\nasync function unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    await extract.on('entry', async function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      await write.on('close', function () {\n        return callback();\n      });\n      await stream.on('error', function (err) {\n        return onError(err);\n      });\n      await write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    await extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    await tar.on('close', function () {\n      return next();\n    });\n    await tar.on('error', onError);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 576,
      "endLine": 578,
      "before": "function (next) {\n  // create a new env with minimal impact on old one\n  var newEnv = process.env;\n\n  if (isPy !== 'python') {\n    // add the dir of the suposed python exe to path\n    newEnv.path = process.env.PATH + ';' + path.dirname(isPy);\n  }\n\n  if (!nodeVCBuildArgs || !nodeVCBuildArgs.length) {\n    nodeVCBuildArgs = ['nosign']; // \"release\" is already the default config value in VCBuild.bat\n  } // spawn a vcbuild process with our custom enviroment.\n\n\n  var vcbuild = spawn('vcbuild.bat', nodeVCBuildArgs, {\n    cwd: dir,\n    env: newEnv\n  });\n  vcbuild.stdout.pipe(process.stdout);\n  vcbuild.stderr.pipe(process.stderr);\n  vcbuild.on('close', function () {\n    next();\n  });\n}",
      "after": "async function (next) {\n  // create a new env with minimal impact on old one\n  var newEnv = process.env;\n\n  if (isPy !== 'python') {\n    // add the dir of the suposed python exe to path\n    newEnv.path = process.env.PATH + ';' + path.dirname(isPy);\n  }\n\n  if (!nodeVCBuildArgs || !nodeVCBuildArgs.length) {\n    nodeVCBuildArgs = ['nosign']; // \"release\" is already the default config value in VCBuild.bat\n  } // spawn a vcbuild process with our custom enviroment.\n\n\n  var vcbuild = spawn('vcbuild.bat', nodeVCBuildArgs, {\n    cwd: dir,\n    env: newEnv\n  });\n  vcbuild.stdout.pipe(process.stdout);\n  vcbuild.stderr.pipe(process.stderr);\n  await vcbuild.on('close', function () {\n    next();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 268,
      "endLine": 268,
      "before": "/**\n * compile the node application\n */\nfunction makeExecutable(next) {\n  if (isWin) {\n    _log('vcbuild [make stage]');\n  } else {\n    _log('make');\n  }\n\n  nodeCompiler.make(next);\n}",
      "after": "/**\n * compile the node application\n */\nasync function makeExecutable(next) {\n  if (isWin) {\n    _log('vcbuild [make stage]');\n  } else {\n    _log('make');\n  }\n\n  await nodeCompiler.make(next);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 637,
      "endLine": 661,
      "before": "function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  configure.on('close', function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    make.on('close', function () {\n      next();\n    });\n  });\n}",
      "after": "async function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  await configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  configure.on('close', function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    make.on('close', function () {\n      next();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 664,
      "endLine": 699,
      "before": "function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  configure.on('close', function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    make.on('close', function () {\n      next();\n    });\n  });\n}",
      "after": "async function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  await configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  await configure.on('close', function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    make.on('close', function () {\n      next();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 691,
      "endLine": 695,
      "before": "function () {\n  if (isPy !== 'python') {\n    /**\n     * Originally I thought this only applied to io.js,\n     * however I soon found out this affects node.js,\n     * so it is now mainstream.\n     */\n    _log('preparing python'); // loop over depends\n\n\n    _loop(dir);\n  }\n\n  if (nodeMakeArgs === undefined) {\n    nodeMakeArgs = [];\n  }\n\n  var platformMake = 'make';\n\n  if (os.platform().match(/bsd$/) != null) {\n    platformMake = 'gmake';\n  }\n\n  var make = spawn(platformMake, nodeMakeArgs, {\n    cwd: dir\n  });\n  make.stdout.pipe(process.stdout);\n  make.stderr.pipe(process.stderr);\n  make.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to run make.');\n\n    process.exit(1);\n  });\n  make.on('close', function () {\n    next();\n  });\n}",
      "after": "async function () {\n  if (isPy !== 'python') {\n    /**\n     * Originally I thought this only applied to io.js,\n     * however I soon found out this affects node.js,\n     * so it is now mainstream.\n     */\n    _log('preparing python'); // loop over depends\n\n\n    _loop(dir);\n  }\n\n  if (nodeMakeArgs === undefined) {\n    nodeMakeArgs = [];\n  }\n\n  var platformMake = 'make';\n\n  if (os.platform().match(/bsd$/) != null) {\n    platformMake = 'gmake';\n  }\n\n  var make = spawn(platformMake, nodeMakeArgs, {\n    cwd: dir\n  });\n  make.stdout.pipe(process.stdout);\n  make.stderr.pipe(process.stderr);\n  await make.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to run make.');\n\n    process.exit(1);\n  });\n  make.on('close', function () {\n    next();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 444,
      "endLine": 481,
      "before": "/**\n * unzip in the same directory\n */\nfunction unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    extract.on('entry', function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      write.on('close', function () {\n        return callback();\n      });\n      stream.on('error', function (err) {\n        return onError(err);\n      });\n      write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}",
      "after": "/**\n * unzip in the same directory\n */\nasync function unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    await extract.on('entry', async function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      await write.on('close', function () {\n        return callback();\n      });\n      await stream.on('error', function (err) {\n        return onError(err);\n      });\n      await write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    await extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    await tar.on('close', function () {\n      return next();\n    });\n    await tar.on('error', onError);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 468,
      "endLine": 470,
      "before": "function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  write.on('close', function () {\n    return callback();\n  });\n  stream.on('error', function (err) {\n    return onError(err);\n  });\n  write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}",
      "after": "async function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  await write.on('close', function () {\n    return callback();\n  });\n  await stream.on('error', function (err) {\n    return onError(err);\n  });\n  await write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 472,
      "endLine": 474,
      "before": "function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  write.on('close', function () {\n    return callback();\n  });\n  stream.on('error', function (err) {\n    return onError(err);\n  });\n  write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}",
      "after": "async function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  await write.on('close', function () {\n    return callback();\n  });\n  await stream.on('error', function (err) {\n    return onError(err);\n  });\n  await write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 483,
      "endLine": 486,
      "before": "/**\n * unzip in the same directory\n */\nfunction unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    extract.on('entry', function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      write.on('close', function () {\n        return callback();\n      });\n      stream.on('error', function (err) {\n        return onError(err);\n      });\n      write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}",
      "after": "/**\n * unzip in the same directory\n */\nasync function unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    await extract.on('entry', async function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      await write.on('close', function () {\n        return callback();\n      });\n      await stream.on('error', function (err) {\n        return onError(err);\n      });\n      await write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    await extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    await tar.on('close', function () {\n      return next();\n    });\n    await tar.on('error', onError);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 499,
      "endLine": 501,
      "before": "/**\n * unzip in the same directory\n */\nfunction unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    extract.on('entry', function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      write.on('close', function () {\n        return callback();\n      });\n      stream.on('error', function (err) {\n        return onError(err);\n      });\n      write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}",
      "after": "/**\n * unzip in the same directory\n */\nasync function unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    await extract.on('entry', async function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      await write.on('close', function () {\n        return callback();\n      });\n      await stream.on('error', function (err) {\n        return onError(err);\n      });\n      await write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    await extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    await tar.on('close', function () {\n      return next();\n    });\n    await tar.on('error', onError);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 637,
      "endLine": 661,
      "before": "function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  configure.on('close', function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    make.on('close', function () {\n      next();\n    });\n  });\n}",
      "after": "async function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  await configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  await configure.on('close', async function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    await make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    make.on('close', function () {\n      next();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 664,
      "endLine": 699,
      "before": "function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  configure.on('close', function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    make.on('close', function () {\n      next();\n    });\n  });\n}",
      "after": "async function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  await configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  await configure.on('close', async function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    await make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    make.on('close', function () {\n      next();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 696,
      "endLine": 698,
      "before": "function () {\n  if (isPy !== 'python') {\n    /**\n     * Originally I thought this only applied to io.js,\n     * however I soon found out this affects node.js,\n     * so it is now mainstream.\n     */\n    _log('preparing python'); // loop over depends\n\n\n    _loop(dir);\n  }\n\n  if (nodeMakeArgs === undefined) {\n    nodeMakeArgs = [];\n  }\n\n  var platformMake = 'make';\n\n  if (os.platform().match(/bsd$/) != null) {\n    platformMake = 'gmake';\n  }\n\n  var make = spawn(platformMake, nodeMakeArgs, {\n    cwd: dir\n  });\n  make.stdout.pipe(process.stdout);\n  make.stderr.pipe(process.stderr);\n  make.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to run make.');\n\n    process.exit(1);\n  });\n  make.on('close', function () {\n    next();\n  });\n}",
      "after": "async function () {\n  if (isPy !== 'python') {\n    /**\n     * Originally I thought this only applied to io.js,\n     * however I soon found out this affects node.js,\n     * so it is now mainstream.\n     */\n    _log('preparing python'); // loop over depends\n\n\n    _loop(dir);\n  }\n\n  if (nodeMakeArgs === undefined) {\n    nodeMakeArgs = [];\n  }\n\n  var platformMake = 'make';\n\n  if (os.platform().match(/bsd$/) != null) {\n    platformMake = 'gmake';\n  }\n\n  var make = spawn(platformMake, nodeMakeArgs, {\n    cwd: dir\n  });\n  make.stdout.pipe(process.stdout);\n  make.stderr.pipe(process.stderr);\n  await make.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to run make.');\n\n    process.exit(1);\n  });\n  await make.on('close', function () {\n    next();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 1093,
      "endLine": 1105,
      "before": "/**\n * Log the progress of a request object.\n */\nfunction _logProgress(req) {\n  req.on('response', function (resp) {\n    var len = parseInt(resp.headers['content-length'], 10),\n        bar = new ProgressBar('[:bar]', {\n      complete: '=',\n      incomplete: ' ',\n      total: len,\n      width: 100 // just use 100\n\n    });\n    req.on('data', function (chunk) {\n      bar.tick(chunk.length);\n    });\n  });\n  req.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to download node sources,');\n\n    process.exit(1);\n  });\n  return req;\n}\n/**\n * Attempt to parse the package.json for nexe information.\n *\n * @param {string} path - path to package.json\n * @param {object} options - fallback options\n *\n * @todo implement options overriding package defaults.\n * @todo make this much less hackily implemented....\n *\n * @return {object} nexe.compile - options object\n **/",
      "after": "/**\n * Log the progress of a request object.\n */\nasync function _logProgress(req) {\n  await req.on('response', function (resp) {\n    var len = parseInt(resp.headers['content-length'], 10),\n        bar = new ProgressBar('[:bar]', {\n      complete: '=',\n      incomplete: ' ',\n      total: len,\n      width: 100 // just use 100\n\n    });\n    req.on('data', function (chunk) {\n      bar.tick(chunk.length);\n    });\n  });\n  req.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to download node sources,');\n\n    process.exit(1);\n  });\n  return req;\n}\n/**\n * Attempt to parse the package.json for nexe information.\n *\n * @param {string} path - path to package.json\n * @param {object} options - fallback options\n *\n * @todo implement options overriding package defaults.\n * @todo make this much less hackily implemented....\n *\n * @return {object} nexe.compile - options object\n **/"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 414,
      "endLine": 414,
      "before": "/**\n * download node into the target directory\n */\nfunction downloadNode(next) {\n  if (fs.existsSync(nodeFilePath)) return next();\n  var uri = framework;\n\n  if (framework === 'node') {\n    uri = 'nodejs'; // if node, use nodejs uri\n  } else if (framework === 'nodejs') {\n    framework = 'node'; // support nodejs, and node, as framework.\n  }\n\n  var type = global.type;\n  var url,\n      prefix = 'https://' + uri + '.org/dist';\n\n  if (version === 'latest') {\n    url = prefix + '/' + framework + '-' + version + '.tar.gz';\n  } else {\n    url = prefix + '/v' + version + '/' + framework + '-v' + version + '.tar.gz';\n  }\n\n  _log('downloading %s', url);\n\n  var output = fs.createWriteStream(nodeFilePath, {\n    flags: 'w+'\n  }); // need to set user-agent to bypass some corporate firewalls\n\n  var requestOptions = {\n    url: url,\n    headers: {\n      'User-Agent': 'Node.js'\n    }\n  };\n\n  _logProgress(request(requestOptions)).pipe(output);\n\n  output.on('close', function () {\n    next();\n  });\n}",
      "after": "/**\n * download node into the target directory\n */\nasync function downloadNode(next) {\n  if (fs.existsSync(nodeFilePath)) return next();\n  var uri = framework;\n\n  if (framework === 'node') {\n    uri = 'nodejs'; // if node, use nodejs uri\n  } else if (framework === 'nodejs') {\n    framework = 'node'; // support nodejs, and node, as framework.\n  }\n\n  var type = global.type;\n  var url,\n      prefix = 'https://' + uri + '.org/dist';\n\n  if (version === 'latest') {\n    url = prefix + '/' + framework + '-' + version + '.tar.gz';\n  } else {\n    url = prefix + '/v' + version + '/' + framework + '-v' + version + '.tar.gz';\n  }\n\n  _log('downloading %s', url);\n\n  var output = fs.createWriteStream(nodeFilePath, {\n    flags: 'w+'\n  }); // need to set user-agent to bypass some corporate firewalls\n\n  var requestOptions = {\n    url: url,\n    headers: {\n      'User-Agent': 'Node.js'\n    }\n  };\n  (await _logProgress(request(requestOptions))).pipe(output);\n  await output.on('close', function () {\n    next();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 1102,
      "endLine": 1104,
      "before": "function (resp) {\n  var len = parseInt(resp.headers['content-length'], 10),\n      bar = new ProgressBar('[:bar]', {\n    complete: '=',\n    incomplete: ' ',\n    total: len,\n    width: 100 // just use 100\n\n  });\n  req.on('data', function (chunk) {\n    bar.tick(chunk.length);\n  });\n}",
      "after": "async function (resp) {\n  var len = parseInt(resp.headers['content-length'], 10),\n      bar = new ProgressBar('[:bar]', {\n    complete: '=',\n    incomplete: ' ',\n    total: len,\n    width: 100 // just use 100\n\n  });\n  await req.on('data', function (chunk) {\n    bar.tick(chunk.length);\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 416,
      "endLine": 418,
      "before": "/**\n * download node into the target directory\n */\nfunction downloadNode(next) {\n  if (fs.existsSync(nodeFilePath)) return next();\n  var uri = framework;\n\n  if (framework === 'node') {\n    uri = 'nodejs'; // if node, use nodejs uri\n  } else if (framework === 'nodejs') {\n    framework = 'node'; // support nodejs, and node, as framework.\n  }\n\n  var type = global.type;\n  var url,\n      prefix = 'https://' + uri + '.org/dist';\n\n  if (version === 'latest') {\n    url = prefix + '/' + framework + '-' + version + '.tar.gz';\n  } else {\n    url = prefix + '/v' + version + '/' + framework + '-v' + version + '.tar.gz';\n  }\n\n  _log('downloading %s', url);\n\n  var output = fs.createWriteStream(nodeFilePath, {\n    flags: 'w+'\n  }); // need to set user-agent to bypass some corporate firewalls\n\n  var requestOptions = {\n    url: url,\n    headers: {\n      'User-Agent': 'Node.js'\n    }\n  };\n\n  _logProgress(request(requestOptions)).pipe(output);\n\n  output.on('close', function () {\n    next();\n  });\n}",
      "after": "/**\n * download node into the target directory\n */\nasync function downloadNode(next) {\n  if (fs.existsSync(nodeFilePath)) return next();\n  var uri = framework;\n\n  if (framework === 'node') {\n    uri = 'nodejs'; // if node, use nodejs uri\n  } else if (framework === 'nodejs') {\n    framework = 'node'; // support nodejs, and node, as framework.\n  }\n\n  var type = global.type;\n  var url,\n      prefix = 'https://' + uri + '.org/dist';\n\n  if (version === 'latest') {\n    url = prefix + '/' + framework + '-' + version + '.tar.gz';\n  } else {\n    url = prefix + '/v' + version + '/' + framework + '-v' + version + '.tar.gz';\n  }\n\n  _log('downloading %s', url);\n\n  var output = fs.createWriteStream(nodeFilePath, {\n    flags: 'w+'\n  }); // need to set user-agent to bypass some corporate firewalls\n\n  var requestOptions = {\n    url: url,\n    headers: {\n      'User-Agent': 'Node.js'\n    }\n  };\n  (await _logProgress(request(requestOptions))).pipe(output);\n  await output.on('close', function () {\n    next();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 637,
      "endLine": 661,
      "before": "function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  configure.on('close', function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    make.on('close', function () {\n      next();\n    });\n  });\n}",
      "after": "async function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  await configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  await configure.on('close', async function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    await make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    await make.on('close', function () {\n      next();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 664,
      "endLine": 699,
      "before": "function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  configure.on('close', function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    make.on('close', function () {\n      next();\n    });\n  });\n}",
      "after": "async function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  await configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  await configure.on('close', async function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    await make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    await make.on('close', function () {\n      next();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 691,
      "endLine": 695,
      "before": "function () {\n  if (isPy !== 'python') {\n    /**\n     * Originally I thought this only applied to io.js,\n     * however I soon found out this affects node.js,\n     * so it is now mainstream.\n     */\n    _log('preparing python'); // loop over depends\n\n\n    _loop(dir);\n  }\n\n  if (nodeMakeArgs === undefined) {\n    nodeMakeArgs = [];\n  }\n\n  var platformMake = 'make';\n\n  if (os.platform().match(/bsd$/) != null) {\n    platformMake = 'gmake';\n  }\n\n  var make = spawn(platformMake, nodeMakeArgs, {\n    cwd: dir\n  });\n  make.stdout.pipe(process.stdout);\n  make.stderr.pipe(process.stderr);\n  make.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to run make.');\n\n    process.exit(1);\n  });\n  make.on('close', function () {\n    next();\n  });\n}",
      "after": "async function () {\n  if (isPy !== 'python') {\n    /**\n     * Originally I thought this only applied to io.js,\n     * however I soon found out this affects node.js,\n     * so it is now mainstream.\n     */\n    _log('preparing python'); // loop over depends\n\n\n    _loop(dir);\n  }\n\n  if (nodeMakeArgs === undefined) {\n    nodeMakeArgs = [];\n  }\n\n  var platformMake = 'make';\n\n  if (os.platform().match(/bsd$/) != null) {\n    platformMake = 'gmake';\n  }\n\n  var make = spawn(platformMake, nodeMakeArgs, {\n    cwd: dir\n  });\n  make.stdout.pipe(process.stdout);\n  make.stderr.pipe(process.stderr);\n  await make.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to run make.');\n\n    process.exit(1);\n  });\n  await make.on('close', function () {\n    next();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 1093,
      "endLine": 1105,
      "before": "/**\n * Log the progress of a request object.\n */\nfunction _logProgress(req) {\n  req.on('response', function (resp) {\n    var len = parseInt(resp.headers['content-length'], 10),\n        bar = new ProgressBar('[:bar]', {\n      complete: '=',\n      incomplete: ' ',\n      total: len,\n      width: 100 // just use 100\n\n    });\n    req.on('data', function (chunk) {\n      bar.tick(chunk.length);\n    });\n  });\n  req.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to download node sources,');\n\n    process.exit(1);\n  });\n  return req;\n}\n/**\n * Attempt to parse the package.json for nexe information.\n *\n * @param {string} path - path to package.json\n * @param {object} options - fallback options\n *\n * @todo implement options overriding package defaults.\n * @todo make this much less hackily implemented....\n *\n * @return {object} nexe.compile - options object\n **/",
      "after": "/**\n * Log the progress of a request object.\n */\nasync function _logProgress(req) {\n  await req.on('response', async function (resp) {\n    var len = parseInt(resp.headers['content-length'], 10),\n        bar = new ProgressBar('[:bar]', {\n      complete: '=',\n      incomplete: ' ',\n      total: len,\n      width: 100 // just use 100\n\n    });\n    await req.on('data', function (chunk) {\n      bar.tick(chunk.length);\n    });\n  });\n  req.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to download node sources,');\n\n    process.exit(1);\n  });\n  return req;\n}\n/**\n * Attempt to parse the package.json for nexe information.\n *\n * @param {string} path - path to package.json\n * @param {object} options - fallback options\n *\n * @todo implement options overriding package defaults.\n * @todo make this much less hackily implemented....\n *\n * @return {object} nexe.compile - options object\n **/"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 1107,
      "endLine": 1111,
      "before": "/**\n * Log the progress of a request object.\n */\nfunction _logProgress(req) {\n  req.on('response', function (resp) {\n    var len = parseInt(resp.headers['content-length'], 10),\n        bar = new ProgressBar('[:bar]', {\n      complete: '=',\n      incomplete: ' ',\n      total: len,\n      width: 100 // just use 100\n\n    });\n    req.on('data', function (chunk) {\n      bar.tick(chunk.length);\n    });\n  });\n  req.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to download node sources,');\n\n    process.exit(1);\n  });\n  return req;\n}\n/**\n * Attempt to parse the package.json for nexe information.\n *\n * @param {string} path - path to package.json\n * @param {object} options - fallback options\n *\n * @todo implement options overriding package defaults.\n * @todo make this much less hackily implemented....\n *\n * @return {object} nexe.compile - options object\n **/",
      "after": "/**\n * Log the progress of a request object.\n */\nasync function _logProgress(req) {\n  await req.on('response', async function (resp) {\n    var len = parseInt(resp.headers['content-length'], 10),\n        bar = new ProgressBar('[:bar]', {\n      complete: '=',\n      incomplete: ' ',\n      total: len,\n      width: 100 // just use 100\n\n    });\n    await req.on('data', function (chunk) {\n      bar.tick(chunk.length);\n    });\n  });\n  await req.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to download node sources,');\n\n    process.exit(1);\n  });\n  return req;\n}\n/**\n * Attempt to parse the package.json for nexe information.\n *\n * @param {string} path - path to package.json\n * @param {object} options - fallback options\n *\n * @todo implement options overriding package defaults.\n * @todo make this much less hackily implemented....\n *\n * @return {object} nexe.compile - options object\n **/"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 1093,
      "endLine": 1105,
      "before": "/**\n * Log the progress of a request object.\n */\nfunction _logProgress(req) {\n  req.on('response', function (resp) {\n    var len = parseInt(resp.headers['content-length'], 10),\n        bar = new ProgressBar('[:bar]', {\n      complete: '=',\n      incomplete: ' ',\n      total: len,\n      width: 100 // just use 100\n\n    });\n    req.on('data', function (chunk) {\n      bar.tick(chunk.length);\n    });\n  });\n  req.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to download node sources,');\n\n    process.exit(1);\n  });\n  return req;\n}\n/**\n * Attempt to parse the package.json for nexe information.\n *\n * @param {string} path - path to package.json\n * @param {object} options - fallback options\n *\n * @todo implement options overriding package defaults.\n * @todo make this much less hackily implemented....\n *\n * @return {object} nexe.compile - options object\n **/",
      "after": "/**\n * Log the progress of a request object.\n */\nasync function _logProgress(req) {\n  await req.on('response', async function (resp) {\n    var len = parseInt(resp.headers['content-length'], 10),\n        bar = new ProgressBar('[:bar]', {\n      complete: '=',\n      incomplete: ' ',\n      total: len,\n      width: 100 // just use 100\n\n    });\n    await req.on('data', function (chunk) {\n      bar.tick(chunk.length);\n    });\n  });\n  await req.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to download node sources,');\n\n    process.exit(1);\n  });\n  return req;\n}\n/**\n * Attempt to parse the package.json for nexe information.\n *\n * @param {string} path - path to package.json\n * @param {object} options - fallback options\n *\n * @todo implement options overriding package defaults.\n * @todo make this much less hackily implemented....\n *\n * @return {object} nexe.compile - options object\n **/"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 89,
      "endLine": 89,
      "before": "(err: ?Error, stat: fs.Stats) => {\n  const totalSize = stat.size;\n\n  if (totalSize > maxDiskSize) {\n    const rename = function rename(): void {\n      fs.rename(path, `${path}.old`, () => {\n        // $FlowIssue: mode is optional\n        fs.open(path, 'a+', (e: ?ErrnoError, ffd: number) => {\n          loadHistory(path, ffd, maxLength, cb);\n        });\n      });\n    };\n\n    if (fd != null) {\n      fs.close(fd, () => {\n        const oldPath = `${path}.old`;\n        fs.exists(oldPath, (exists: boolean) => {\n          if (exists) {\n            fs.unlink(oldPath, rename);\n          } else {\n            rename();\n          }\n        });\n      });\n    }\n  } else {\n    onLoad(path, fd, maxLength, totalSize, cb);\n  }\n}",
      "after": "async (err: ?Error, stat: fs.Stats) => {\n  const totalSize = stat.size;\n\n  if (totalSize > maxDiskSize) {\n    const rename = async function rename(): void {\n      await fs.rename(path, `${path}.old`, () => {\n        // $FlowIssue: mode is optional\n        fs.open(path, 'a+', async (e: ?ErrnoError, ffd: number) => {\n          await loadHistory(path, ffd, maxLength, cb);\n        });\n      });\n    };\n\n    if (fd != null) {\n      fs.close(fd, () => {\n        const oldPath = `${path}.old`;\n        fs.exists(oldPath, (exists: boolean) => {\n          if (exists) {\n            fs.unlink(oldPath, rename);\n          } else {\n            rename();\n          }\n        });\n      });\n    }\n  } else {\n    await onLoad(path, fd, maxLength, totalSize, cb);\n  }\n}"
    }
  ],
  "25": [
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/embed.js",
      "startLine": 44,
      "endLine": 44,
      "before": "function (filePath) {\n  return fs.readFileSync(filePath).toString('base64');\n}",
      "after": "async function (filePath) {\n  return (await fs.promises.readFile(filePath)).toString('base64');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/embed.js",
      "startLine": 60,
      "endLine": 60,
      "before": "/**\n * Embed files.\n *\n * @param {array} resourceFiles - array of files to embed.\n * @param {string} resourceRoot - root of resources.\n * @param {function} compelte   - callback\n **/\nfunction embed(resourceFiles, resourceRoot) {\n  if (resourceFiles.length > 0) {\n    let buffer = 'var embeddedFiles = {\\n';\n\n    for (let i = 0; i < resourceFiles.length; ++i) {\n      buffer += JSON.stringify(path.relative(resourceRoot, resourceFiles[i])) + ': \"';\n      buffer += encode(resourceFiles[i]) + '\",\\n';\n    }\n\n    buffer += '\\n};\\n\\nmodule.exports.keys = function () { return Object.keys(embeddedFiles); }\\n\\nmodule.exports.get = ';\n    buffer += accessor.toString();\n    return buffer;\n  }\n}",
      "after": "/**\n * Embed files.\n *\n * @param {array} resourceFiles - array of files to embed.\n * @param {string} resourceRoot - root of resources.\n * @param {function} compelte   - callback\n **/\nasync function embed(resourceFiles, resourceRoot) {\n  if (resourceFiles.length > 0) {\n    let buffer = 'var embeddedFiles = {\\n';\n\n    for (let i = 0; i < resourceFiles.length; ++i) {\n      buffer += JSON.stringify(path.relative(resourceRoot, resourceFiles[i])) + ': \"';\n      buffer += (await encode(resourceFiles[i])) + '\",\\n';\n    }\n\n    buffer += '\\n};\\n\\nmodule.exports.keys = function () { return Object.keys(embeddedFiles); }\\n\\nmodule.exports.get = ';\n    buffer += accessor.toString();\n    return buffer;\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 155,
      "endLine": 158,
      "before": "/**\n * Embed Resources into a base64 encoded array.\n **/\nfunction embedResources(nc, next) {\n  nodeCompiler = nc;\n  options.resourceFiles = options.resourceFiles || [];\n  options.resourceRoot = options.resourceRoot || '';\n\n  if (!Array.isArray(options.resourceFiles)) {\n    throw new Error('Bad Argument: resourceFiles is not an array');\n  }\n\n  const resourcesBuffer = embed(options.resourceFiles, options.resourceRoot);\n\n  if (resourcesBuffer != null) {\n    const resourcePath = path.join(nodeCompiler.dir, 'lib', 'nexeres.js'); // write nexeres.js\n\n    _log('embedResources %s', options.resourceFiles);\n\n    _log('resource -> %s', resourcePath);\n\n    fs.writeFile(resourcePath, resourcesBuffer, next);\n  } else {\n    next();\n  }\n}",
      "after": "/**\n * Embed Resources into a base64 encoded array.\n **/\nasync function embedResources(nc, next) {\n  nodeCompiler = nc;\n  options.resourceFiles = options.resourceFiles || [];\n  options.resourceRoot = options.resourceRoot || '';\n\n  if (!Array.isArray(options.resourceFiles)) {\n    throw new Error('Bad Argument: resourceFiles is not an array');\n  }\n\n  const resourcesBuffer = await embed(options.resourceFiles, options.resourceRoot);\n\n  if (resourcesBuffer != null) {\n    const resourcePath = path.join(nodeCompiler.dir, 'lib', 'nexeres.js'); // write nexeres.js\n\n    _log('embedResources %s', options.resourceFiles);\n\n    _log('resource -> %s', resourcePath);\n\n    fs.writeFile(resourcePath, resourcesBuffer, next);\n  } else {\n    next();\n  }\n}"
    }
  ],
  "26": [
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 112,
      "endLine": 114,
      "before": "function () {\n  _log('done');\n\n  var f = fs.readFileSync(path.join(options.nodeTempDir, 'iojs-versions.json'));\n  f = JSON.parse(f);\n  version = f[0].version.replace('v', '');\n\n  _log('iojs latest => ' + version); // continue down along the async road\n\n\n  next();\n}",
      "after": "async function () {\n  _log('done');\n\n  var f = await fs.promises.readFile(path.join(options.nodeTempDir, 'iojs-versions.json'));\n  f = JSON.parse(f);\n  version = f[0].version.replace('v', '');\n\n  _log('iojs latest => ' + version); // continue down along the async road\n\n\n  next();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 30,
      "endLine": 30,
      "before": "on(_: string, cb: (number) => void): void {\n  cb(42);\n}",
      "after": "async on(_: string, cb: (number) => void): void {\n  await cb(42);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 96,
      "endLine": 104,
      "before": "(resolve, reject) => {\n  let bytesRead = 0;\n  resp.body.on('error', reject).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}",
      "after": "async (resolve, reject) => {\n  let bytesRead = 0;\n  await (await resp.body.on('error', reject)).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  await gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  await (await ws.on('error', reject)).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 96,
      "endLine": 97,
      "before": "(resolve, reject) => {\n  let bytesRead = 0;\n  resp.body.on('error', reject).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}",
      "after": "async (resolve, reject) => {\n  let bytesRead = 0;\n  await (await resp.body.on('error', reject)).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  await gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  await (await ws.on('error', reject)).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 108,
      "endLine": 109,
      "before": "(resolve, reject) => {\n  let bytesRead = 0;\n  resp.body.on('error', reject).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}",
      "after": "async (resolve, reject) => {\n  let bytesRead = 0;\n  await (await resp.body.on('error', reject)).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  await gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  await (await ws.on('error', reject)).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 113,
      "endLine": 118,
      "before": "(resolve, reject) => {\n  let bytesRead = 0;\n  resp.body.on('error', reject).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}",
      "after": "async (resolve, reject) => {\n  let bytesRead = 0;\n  await (await resp.body.on('error', reject)).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  await gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  await (await ws.on('error', reject)).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/download/src/index.js",
      "startLine": 113,
      "endLine": 114,
      "before": "(resolve, reject) => {\n  let bytesRead = 0;\n  resp.body.on('error', reject).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  ws.on('error', reject).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}",
      "after": "async (resolve, reject) => {\n  let bytesRead = 0;\n  await (await resp.body.on('error', reject)).on('data', chunk => {\n    bytesRead += chunk.length;\n\n    if (size) {\n      showProgress(100 * bytesRead / size);\n    }\n  });\n  const gunzip = zlib.createGunzip();\n  await gunzip.on('error', reject);\n  resp.body.pipe(gunzip).pipe(ws);\n  await (await ws.on('error', reject)).on('close', () => {\n    showProgress(100);\n    resolve();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 42,
      "endLine": 42,
      "before": "function restoreSigintHandlers(handlers: sigintHandlerType[]): void {\n  handlers.forEach((listener: sigintHandlerType) => process.on('SIGINT', listener));\n}",
      "after": "async function restoreSigintHandlers(handlers: sigintHandlerType[]): void {\n  handlers.forEach(async (listener: sigintHandlerType) => await process.on('SIGINT', listener));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 118,
      "endLine": 118,
      "before": "function lumoEval(source: string, isForeign: boolean, execPath: ?string): mixed {\n  if (execPath != null) {\n    const filename = path.resolve(execPath);\n    const dirname = path.dirname(filename);\n    const module = new Module(filename);\n    module.filename = filename;\n    module.paths = Module._nodeModulePaths(dirname);\n\n    if (__DEV__) {\n      const compiledWrapper = vm.runInContext(Module.wrap(source), ClojureScriptContext, {\n        filename,\n        lineOffset: 0,\n        displayErrors: true\n      });\n      return compiledWrapper.call(module.exports, module.exports, require, module, filename, dirname);\n    }\n\n    return module._compile(source, filename);\n  } // $FlowIssue: this exists\n\n\n  const _module = ClojureScriptContext.module; // $FlowIssue: this also exists\n\n  const _exports = ClojureScriptContext.exports;\n  let ret;\n\n  if (isForeign) {\n    // this is a hack needed for foreign libraries to end up on global scope.\n    // Closure Library's goog.bootstrap.nodeJs does the same thing.\n    // $FlowIssue: this exists\n    ClojureScriptContext.module = undefined; // $FlowIssue: this exists\n\n    ClojureScriptContext.exports = undefined;\n  }\n\n  if (currentREPLInterface != null) {\n    const sigintHandlers = getAndRemoveSigintEventListeners();\n    contextifyBinding.startSigintWatchdog();\n\n    const previouslyInRawMode = currentREPLInterface._setRawMode(false);\n\n    try {\n      ret = __DEV__ ? vm.runInContext(source, ClojureScriptContext, interruptibleScriptOptions) : vm.runInThisContext(source, interruptibleScriptOptions);\n    } catch (e) {\n      if (e.message !== 'Script execution interrupted.') {\n        throw e;\n      }\n    } finally {\n      currentREPLInterface._setRawMode(previouslyInRawMode);\n\n      const hadPendingSignals = contextifyBinding.stopSigintWatchdog();\n      restoreSigintHandlers(sigintHandlers);\n\n      if (hadPendingSignals) {\n        currentREPLInterface.emit('SIGINT');\n      }\n    }\n  } else {\n    ret = __DEV__ ? vm.runInContext(source, ClojureScriptContext, scriptOptions) : vm.runInThisContext(source, scriptOptions);\n  }\n\n  if (isForeign) {\n    // $FlowIssue: this exists\n    ClojureScriptContext.module = _module; // $FlowIssue: this exists\n\n    ClojureScriptContext.exports = _exports;\n  }\n\n  return ret;\n}",
      "after": "async function lumoEval(source: string, isForeign: boolean, execPath: ?string): mixed {\n  if (execPath != null) {\n    const filename = path.resolve(execPath);\n    const dirname = path.dirname(filename);\n    const module = new Module(filename);\n    module.filename = filename;\n    module.paths = Module._nodeModulePaths(dirname);\n\n    if (__DEV__) {\n      const compiledWrapper = vm.runInContext(Module.wrap(source), ClojureScriptContext, {\n        filename,\n        lineOffset: 0,\n        displayErrors: true\n      });\n      return compiledWrapper.call(module.exports, module.exports, require, module, filename, dirname);\n    }\n\n    return module._compile(source, filename);\n  } // $FlowIssue: this exists\n\n\n  const _module = ClojureScriptContext.module; // $FlowIssue: this also exists\n\n  const _exports = ClojureScriptContext.exports;\n  let ret;\n\n  if (isForeign) {\n    // this is a hack needed for foreign libraries to end up on global scope.\n    // Closure Library's goog.bootstrap.nodeJs does the same thing.\n    // $FlowIssue: this exists\n    ClojureScriptContext.module = undefined; // $FlowIssue: this exists\n\n    ClojureScriptContext.exports = undefined;\n  }\n\n  if (currentREPLInterface != null) {\n    const sigintHandlers = getAndRemoveSigintEventListeners();\n    contextifyBinding.startSigintWatchdog();\n\n    const previouslyInRawMode = currentREPLInterface._setRawMode(false);\n\n    try {\n      ret = __DEV__ ? vm.runInContext(source, ClojureScriptContext, interruptibleScriptOptions) : vm.runInThisContext(source, interruptibleScriptOptions);\n    } catch (e) {\n      if (e.message !== 'Script execution interrupted.') {\n        throw e;\n      }\n    } finally {\n      currentREPLInterface._setRawMode(previouslyInRawMode);\n\n      const hadPendingSignals = contextifyBinding.stopSigintWatchdog();\n      await restoreSigintHandlers(sigintHandlers);\n\n      if (hadPendingSignals) {\n        currentREPLInterface.emit('SIGINT');\n      }\n    }\n  } else {\n    ret = __DEV__ ? vm.runInContext(source, ClojureScriptContext, scriptOptions) : vm.runInThisContext(source, scriptOptions);\n  }\n\n  if (isForeign) {\n    // $FlowIssue: this exists\n    ClojureScriptContext.module = _module; // $FlowIssue: this exists\n\n    ClojureScriptContext.exports = _exports;\n  }\n\n  return ret;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 174,
      "endLine": 174,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    _: [],\n    scripts: []\n  });\n  jest.runAllTicks();\n  vm.ctx.$$LUMO_GLOBALS.eval('source');\n  expect(vm.runInContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    _: [],\n    scripts: []\n  });\n  jest.runAllTicks();\n  await vm.ctx.$$LUMO_GLOBALS.eval('source');\n  expect(vm.runInContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 215,
      "endLine": 215,
      "before": "async () => {\n  expect.assertions(1);\n  await startClojureScriptEngine({\n    repl: true,\n    _: [],\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  global.$$LUMO_GLOBALS.eval('source', false);\n  expect(vm.runInThisContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  expect.assertions(1);\n  await startClojureScriptEngine({\n    repl: true,\n    _: [],\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  await global.$$LUMO_GLOBALS.eval('source', false);\n  expect(vm.runInThisContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 155,
      "endLine": 155,
      "before": "function doPrint(cb: (value: string) => void, arg: string): void {\n  if (currentREPLInterface != null) {\n    const sigintHandlers = getAndRemoveSigintEventListeners();\n    contextifyBinding.startSigintWatchdog();\n\n    const previouslyInRawMode = currentREPLInterface._setRawMode(false);\n\n    try {\n      cb(arg);\n    } catch (e) {\n      if (e !== interruptSentinel) {\n        throw e;\n      }\n    } finally {\n      currentREPLInterface._setRawMode(previouslyInRawMode);\n\n      const hadPendingSignals = contextifyBinding.stopSigintWatchdog();\n      restoreSigintHandlers(sigintHandlers);\n\n      if (hadPendingSignals) {\n        currentREPLInterface.emit('SIGINT');\n      }\n    }\n  } else {\n    cb(arg);\n  }\n}",
      "after": "async function doPrint(cb: (value: string) => void, arg: string): void {\n  if (currentREPLInterface != null) {\n    const sigintHandlers = getAndRemoveSigintEventListeners();\n    contextifyBinding.startSigintWatchdog();\n\n    const previouslyInRawMode = currentREPLInterface._setRawMode(false);\n\n    try {\n      cb(arg);\n    } catch (e) {\n      if (e !== interruptSentinel) {\n        throw e;\n      }\n    } finally {\n      currentREPLInterface._setRawMode(previouslyInRawMode);\n\n      const hadPendingSignals = contextifyBinding.stopSigintWatchdog();\n      await restoreSigintHandlers(sigintHandlers);\n\n      if (hadPendingSignals) {\n        currentREPLInterface.emit('SIGINT');\n      }\n    }\n  } else {\n    cb(arg);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 433,
      "endLine": 435,
      "before": "function processStdin(): void {\n  let code = '';\n  process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?",
      "after": "async function processStdin(): void {\n  let code = '';\n  await process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  await process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  await process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 535,
      "endLine": 535,
      "before": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    process.nextTick(() => {\n      initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}",
      "after": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    await initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    await initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      await processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    await initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    await process.nextTick(async () => {\n      await initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    await startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    await initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 79,
      "endLine": 79,
      "before": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-vsqdfK']\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(true);\n  expect(parsedOpts['static-fns']).toBe(true);\n  expect(parsedOpts['fn-invoke-direct']).toBe(true);\n  expect(parsedOpts['dumb-terminal']).toBe(true);\n  expect(parsedOpts['auto-cache']).toBe(true);\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-vsqdfK']\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(true);\n  expect(parsedOpts['static-fns']).toBe(true);\n  expect(parsedOpts['fn-invoke-direct']).toBe(true);\n  expect(parsedOpts['dumb-terminal']).toBe(true);\n  expect(parsedOpts['auto-cache']).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 97,
      "endLine": 97,
      "before": "async () => {\n  const args = '-i foo.cljs -e :foo -e :bar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(false);\n  expect(parsedOpts.scripts.length).toEqual(3);\n}",
      "after": "async () => {\n  const args = '-i foo.cljs -e :foo -e :bar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.verbose).toBe(false);\n  expect(parsedOpts.scripts.length).toEqual(3);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 109,
      "endLine": 109,
      "before": "async () => {\n  const args = '-i foo.cljs -e :foo -i bar.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.scripts.length).toEqual(3);\n  expect(parsedOpts.scripts).toEqual([['path', 'foo.cljs'], ['text', ':foo'], ['path', 'bar.cljs']]);\n}",
      "after": "async () => {\n  const args = '-i foo.cljs -e :foo -i bar.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.scripts.length).toEqual(3);\n  expect(parsedOpts.scripts).toEqual([['path', 'foo.cljs'], ['text', ':foo'], ['path', 'bar.cljs']]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 127,
      "endLine": 127,
      "before": "async () => {\n  const args = `-c foo${delim}bar`;\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual(['foo', 'bar']);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith(['foo', 'bar']);\n}",
      "after": "async () => {\n  const args = `-c foo${delim}bar`;\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual(['foo', 'bar']);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith(['foo', 'bar']);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 140,
      "endLine": 140,
      "before": "async () => {\n  const args = '-r foo.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['foo.cljs']);\n  expect(parsedOpts.repl).toBe(true);\n}",
      "after": "async () => {\n  const args = '-r foo.cljs';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['foo.cljs']);\n  expect(parsedOpts.repl).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 153,
      "endLine": 153,
      "before": "async () => {\n  const args = '-r --verbose --socket-repl localhost:5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['--verbose', '--socket-repl', 'localhost:5555']);\n  expect(parsedOpts.repl).toBe(true);\n}",
      "after": "async () => {\n  const args = '-r --verbose --socket-repl localhost:5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['--verbose', '--socket-repl', 'localhost:5555']);\n  expect(parsedOpts.repl).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 170,
      "endLine": 170,
      "before": "async () => {\n  const args = 'foo.cljs -r';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['-r']);\n  expect(parsedOpts.repl).toBe(false);\n}",
      "after": "async () => {\n  const args = 'foo.cljs -r';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.args).toEqual(['-r']);\n  expect(parsedOpts.repl).toBe(false);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 183,
      "endLine": 183,
      "before": "async () => {\n  const args = '-k src';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.cache).toEqual('src');\n}",
      "after": "async () => {\n  const args = '-k src';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.cache).toEqual('src');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 196,
      "endLine": 196,
      "before": "async () => {\n  const args = '-k';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-k';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 208,
      "endLine": 208,
      "before": "async () => {\n  const args = '-m foo.core foo bar baz qux';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.mainNsName).toEqual('foo.core');\n  expect(parsedOpts.args).toEqual(['foo', 'bar', 'baz', 'qux']);\n}",
      "after": "async () => {\n  const args = '-m foo.core foo bar baz qux';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.mainNsName).toEqual('foo.core');\n  expect(parsedOpts.args).toEqual(['foo', 'bar', 'baz', 'qux']);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 223,
      "endLine": 223,
      "before": "async () => {\n  const args = '-a';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}",
      "after": "async () => {\n  const args = '-a';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 236,
      "endLine": 236,
      "before": "async () => {\n  const args = '--elide-asserts';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}",
      "after": "async () => {\n  const args = '--elide-asserts';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['elide-asserts']).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 251,
      "endLine": 251,
      "before": "async () => {\n  const args = '-A warn';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('warn');\n}",
      "after": "async () => {\n  const args = '-A warn';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('warn');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 264,
      "endLine": 264,
      "before": "async () => {\n  const args = '--checked-arrays error';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('error');\n}",
      "after": "async () => {\n  const args = '--checked-arrays error';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts['checked-arrays']).toBe('error');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 288,
      "endLine": 288,
      "before": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0/react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}",
      "after": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0/react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', '.m2', 'repository', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 322,
      "endLine": 322,
      "before": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0 -L ~/some-location';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}",
      "after": "async () => {\n  const args = '-D cljsjs/react:15.5.0-0 -L ~/some-location';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  const [[parsedOpts]] = cljs.mock.calls;\n  expect(parsedOpts.classpath).toEqual([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n  expect(lumo.addSourcePaths).toHaveBeenCalledWith([path.join.apply(null, ['/Users', 'foo', 'some-location', 'cljsjs', 'react', '15.5.0-0', 'react-15.5.0-0.jar'])]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 376,
      "endLine": 376,
      "before": "async () => {\n  jest.resetModules();\n  jest.mock('../socketRepl');\n  socketRepl = require('../socketRepl');\n  startCLI = require('../cli').default;\n  const args = '-n 5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(socketRepl.open).toHaveBeenCalledTimes(1);\n  expect(socketRepl.open).toHaveBeenCalledWith({\n    host: undefined,\n    port: 5555\n  });\n}",
      "after": "async () => {\n  jest.resetModules();\n  jest.mock('../socketRepl');\n  socketRepl = require('../socketRepl');\n  startCLI = require('../cli').default;\n  const args = '-n 5555';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(socketRepl.open).toHaveBeenCalledTimes(1);\n  expect(socketRepl.open).toHaveBeenCalledWith({\n    host: undefined,\n    port: 5555\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 392,
      "endLine": 392,
      "before": "async () => {\n  const args = '-n';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect.assertions(2);\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect.assertions(2);\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 405,
      "endLine": 405,
      "before": "async () => {\n  const args = '-n {}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 417,
      "endLine": 417,
      "before": "async () => {\n  const args = '-n {port: 12345}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {port: 12345}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 429,
      "endLine": 429,
      "before": "async () => {\n  const args = '-n localhost';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n localhost';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 441,
      "endLine": 441,
      "before": "async () => {\n  const args = '-n {\"host\":\"localhost\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"host\":\"localhost\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 453,
      "endLine": 453,
      "before": "async () => {\n  const args = '-n foobar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n foobar';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 465,
      "endLine": 465,
      "before": "async () => {\n  const args = '-n {\"port\":\"foobar\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":\"foobar\"}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 477,
      "endLine": 477,
      "before": "async () => {\n  const args = '-n {\"port\":0}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":0}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 489,
      "endLine": 489,
      "before": "async () => {\n  const args = '-n {\"port\":-1000}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":-1000}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 501,
      "endLine": 501,
      "before": "async () => {\n  const args = '-n {\"port\":7753888}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  const args = '-n {\"port\":7753888}';\n  Object.defineProperty(process, 'argv', {\n    value: ['', ''].concat(args.split(' '))\n  });\n  await startCLI();\n  expect(process.stderr.write).toHaveBeenCalled();\n  expect(process.stderr.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 531,
      "endLine": 531,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  await startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 540,
      "endLine": 540,
      "before": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-n', '5555']\n  });\n  await startCLI();\n  socketRepl.close();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-n', '5555']\n  });\n  await startCLI();\n  socketRepl.close();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 550,
      "endLine": 550,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-q']\n  });\n  startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-q']\n  });\n  await startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 559,
      "endLine": 559,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', 'foo.cljs']\n  });\n  startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', 'foo.cljs']\n  });\n  await startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 568,
      "endLine": 568,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-']\n  });\n  startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-']\n  });\n  await startCLI();\n  expect(process.stdout.write).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 579,
      "endLine": 579,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-h']\n  });\n  startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-h']\n  });\n  await startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 590,
      "endLine": 590,
      "before": "() => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-l']\n  });\n  startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '', '-l']\n  });\n  await startCLI();\n  expect(process.stdout.write.mock.calls).toMatchSnapshot();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cli-test.js",
      "startLine": 607,
      "endLine": 607,
      "before": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  await startCLI();\n  expect(v8.setFlagsFromString).toHaveBeenCalledWith('--use_strict');\n}",
      "after": "async () => {\n  Object.defineProperty(process, 'argv', {\n    value: ['', '']\n  });\n  await startCLI();\n  expect(v8.setFlagsFromString).toHaveBeenCalledWith('--use_strict');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 49,
      "endLine": 52,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 59,
      "endLine": 63,
      "before": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}",
      "after": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 70,
      "endLine": 74,
      "before": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}",
      "after": "async () => {\n  const ret = await startCLJS({\n    repl: false,\n    scripts: [],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret).toBeUndefined();\n  startREPL.mockClear();\n  const ret2 = await startCLJS({\n    repl: false,\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n  expect(ret2).toBeUndefined();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 81,
      "endLine": 85,
      "before": "async () => {\n  await startCLJS({\n    repl: false,\n    mainScript: 'foo.cljs',\n    scripts: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: false,\n    mainScript: 'foo.cljs',\n    scripts: []\n  });\n  expect(startREPL).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 91,
      "endLine": 96,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    // scripts will init the ClojureScript engine\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    // scripts will init the ClojureScript engine\n    scripts: [['text', ':foo'], ['path', 'foo.cljs']],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(startREPL).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 103,
      "endLine": 107,
      "before": "async () => {\n  await startCLJS({\n    mainNsName: 'foo.core',\n    args: ['a', 'b', 'c'],\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(vm.ctx.cljs.core.seq).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startCLJS({\n    mainNsName: 'foo.core',\n    args: ['a', 'b', 'c'],\n    scripts: []\n  });\n  jest.runAllTicks();\n  expect(vm.ctx.cljs.core.seq).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 119,
      "endLine": 123,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(vm.createContext).toHaveBeenCalled();\n  expect(vm.createContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  expect(vm.createContext).toHaveBeenCalled();\n  expect(vm.createContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 134,
      "endLine": 137,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    scripts: []\n  });\n  jest.runAllTicks();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 167,
      "endLine": 171,
      "before": "async () => {\n  await startCLJS({\n    repl: true,\n    _: [],\n    scripts: []\n  });\n  jest.runAllTicks();\n  vm.ctx.$$LUMO_GLOBALS.eval('source');\n  expect(vm.runInContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  await startCLJS({\n    repl: true,\n    _: [],\n    scripts: []\n  });\n  jest.runAllTicks();\n  await vm.ctx.$$LUMO_GLOBALS.eval('source');\n  expect(vm.runInContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/cljs-test.js",
      "startLine": 207,
      "endLine": 212,
      "before": "async () => {\n  expect.assertions(1);\n  await startClojureScriptEngine({\n    repl: true,\n    _: [],\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  global.$$LUMO_GLOBALS.eval('source', false);\n  expect(vm.runInThisContext).toHaveBeenCalledTimes(1);\n}",
      "after": "async () => {\n  expect.assertions(1);\n  await startClojureScriptEngine({\n    repl: true,\n    _: [],\n    scripts: [],\n    args: []\n  });\n  jest.runAllTicks();\n  await global.$$LUMO_GLOBALS.eval('source', false);\n  expect(vm.runInThisContext).toHaveBeenCalledTimes(1);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 109,
      "endLine": 109,
      "before": "() => {\n  startREPL({});\n  expect(replHistory).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(replHistory).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 115,
      "endLine": 115,
      "before": "() => {\n  startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalled();\n  expect(mockPrompt).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalled();\n  expect(mockPrompt).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 122,
      "endLine": 122,
      "before": "() => {\n  startREPL({});\n  const onCalls = on.mock.calls;\n  expect(on).toHaveBeenCalledTimes(4);\n  expect(onCalls[0][0]).toBe('line');\n  expect(onCalls[1][0]).toBe('SIGINT');\n  expect(onCalls[2][0]).toBe('close');\n  expect(onCalls[3][0]).toBe('SIGCONT');\n}",
      "after": "async () => {\n  await startREPL({});\n  const onCalls = on.mock.calls;\n  expect(on).toHaveBeenCalledTimes(4);\n  expect(onCalls[0][0]).toBe('line');\n  expect(onCalls[1][0]).toBe('SIGINT');\n  expect(onCalls[2][0]).toBe('close');\n  expect(onCalls[3][0]).toBe('SIGCONT');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 133,
      "endLine": 133,
      "before": "() => {\n  startREPL({});\n  const onCalls = process.stdin.on.mock.calls;\n  expect(process.stdin.on).toHaveBeenCalledTimes(1);\n  expect(onCalls[0][0]).toBe('keypress');\n}",
      "after": "async () => {\n  await startREPL({});\n  const onCalls = process.stdin.on.mock.calls;\n  expect(process.stdin.on).toHaveBeenCalledTimes(1);\n  expect(onCalls[0][0]).toBe('keypress');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 154,
      "endLine": 156,
      "before": "() => {\n  startREPL({\n    'dumb-terminal': false\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(true);\n}",
      "after": "async () => {\n  await startREPL({\n    'dumb-terminal': false\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 165,
      "endLine": 167,
      "before": "() => {\n  startREPL({\n    'dumb-terminal': true\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(false);\n}",
      "after": "async () => {\n  await startREPL({\n    'dumb-terminal': true\n  });\n  const replHistoryCalls = replHistory.mock.calls;\n  expect(replHistory).toHaveBeenCalledTimes(1);\n  expect(replHistoryCalls[0][0].terminal).toBe(false);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 177,
      "endLine": 179,
      "before": "() => {\n  startREPL({\n    'dumb-terminal': true\n  });\n  expect(process.stdin.setRawMode).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  await startREPL({\n    'dumb-terminal': true\n  });\n  expect(process.stdin.setRawMode).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 187,
      "endLine": 189,
      "before": "() => {\n  util.isWindows = false;\n  startREPL({\n    'dumb-terminal': false\n  });\n  expect(process.stdin.setRawMode).toHaveBeenCalledWith(true);\n}",
      "after": "async () => {\n  util.isWindows = false;\n  await startREPL({\n    'dumb-terminal': false\n  });\n  expect(process.stdin.setRawMode).toHaveBeenCalledWith(true);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 212,
      "endLine": 212,
      "before": "() => {\n  mockReplHistory(':cljs/quit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory(':cljs/quit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 222,
      "endLine": 222,
      "before": "() => {\n  mockReplHistory('exit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory('exit', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 232,
      "endLine": 232,
      "before": "() => {\n  mockReplHistory('  :cljs/quit  ', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory('  :cljs/quit  ', process.stdout); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(process.exit).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 244,
      "endLine": 244,
      "before": "() => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  startREPL = require('../repl').default;\n\n  const {\n    close\n  } = require('../socketRepl');\n  /* eslint-enable global-require */\n\n\n  startREPL({});\n  expect(close).toHaveBeenCalled();\n}",
      "after": "async () => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  startREPL = require('../repl').default;\n\n  const {\n    close\n  } = require('../socketRepl');\n  /* eslint-enable global-require */\n\n\n  await startREPL({});\n  expect(close).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 273,
      "endLine": 273,
      "before": "() => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  const repl = require('../repl');\n\n  startREPL = repl.default;\n  /* eslint-enable global-require */\n\n  const originalObjectKeys = Object.keys;\n  let sessions;\n  Object.keys = jest.fn((x: {\n    [key: mixed]: mixed\n  }) => {\n    const result = originalObjectKeys(x);\n    const everyNumber = result.every((k: string) => {\n      try {\n        return !Number.isNaN(parseInt(k, 10));\n      } catch (_) {\n        return false;\n      }\n    });\n\n    if (everyNumber) {\n      sessions = x;\n    }\n\n    return result;\n  });\n  startREPL({});\n  expect(originalObjectKeys(sessions).length).toBe(0);\n  Object.keys = originalObjectKeys;\n}",
      "after": "async () => {\n  mockReplHistory('exit', process.stdout);\n  /* eslint-disable global-require */\n\n  const repl = require('../repl');\n\n  startREPL = repl.default;\n  /* eslint-enable global-require */\n\n  const originalObjectKeys = Object.keys;\n  let sessions;\n  Object.keys = jest.fn((x: {\n    [key: mixed]: mixed\n  }) => {\n    const result = originalObjectKeys(x);\n    const everyNumber = result.every((k: string) => {\n      try {\n        return !Number.isNaN(parseInt(k, 10));\n      } catch (_) {\n        return false;\n      }\n    });\n\n    if (everyNumber) {\n      sessions = x;\n    }\n\n    return result;\n  });\n  await startREPL({});\n  expect(originalObjectKeys(sessions).length).toBe(0);\n  Object.keys = originalObjectKeys;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 325,
      "endLine": 325,
      "before": "() => {\n  const repl = require('../repl'); // eslint-disable-line global-require\n\n\n  const replCreateSession = repl.createSession;\n  repl.createSession = jest.fn((rl: readline$Interface) => ({\n    rl,\n    id: 0\n  }));\n  startREPL({});\n  handleConnection(socket);\n  handleConnection(socket);\n  expect(repl.createSession).toHaveBeenCalledTimes(2);\n  repl.createSession = replCreateSession;\n}",
      "after": "async () => {\n  const repl = require('../repl'); // eslint-disable-line global-require\n\n\n  const replCreateSession = repl.createSession;\n  repl.createSession = jest.fn((rl: readline$Interface) => ({\n    rl,\n    id: 0\n  }));\n  await startREPL({});\n  handleConnection(socket);\n  handleConnection(socket);\n  expect(repl.createSession).toHaveBeenCalledTimes(2);\n  repl.createSession = replCreateSession;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 336,
      "endLine": 336,
      "before": "() => {\n  startREPL({});\n  expect(handleConnection(socket)).toBe(1);\n  expect(handleConnection(socket)).toBe(2);\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(handleConnection(socket)).toBe(1);\n  expect(handleConnection(socket)).toBe(2);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 354,
      "endLine": 354,
      "before": "() => {\n  startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('cljs.user=> ');\n}",
      "after": "async () => {\n  await startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('cljs.user=> ');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/repl-test.js",
      "startLine": 370,
      "endLine": 370,
      "before": "() => {\n  jest.resetModules();\n  jest.mock('../cljs', () => ({\n    isReadable: jest.fn((input: string) => null),\n    execute: jest.fn(),\n    getCurrentNamespace: jest.fn(() => 'cljs.user'),\n    indentSpaceCount: jest.fn((text: string) => 0)\n  })); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('       #_=> ');\n}",
      "after": "async () => {\n  jest.resetModules();\n  jest.mock('../cljs', () => ({\n    isReadable: jest.fn((input: string) => null),\n    execute: jest.fn(),\n    getCurrentNamespace: jest.fn(() => 'cljs.user'),\n    indentSpaceCount: jest.fn((text: string) => 0)\n  })); // eslint-disable-next-line global-require\n\n  startREPL = require('../repl').default;\n  await startREPL({});\n  expect(mockSetPrompt).toHaveBeenCalledWith('       #_=> ');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cli.js",
      "startLine": 339,
      "endLine": 339,
      "before": "function startCLI(): mixed {\n  const opts = getCLIOpts();\n  const {\n    args,\n    cache,\n    classpath,\n    dependencies,\n    unrecognized,\n    help,\n    legal,\n    mainNsName,\n    mainScript,\n    quiet,\n    scripts,\n    version\n  } = opts;\n  const autoCache = opts['auto-cache'];\n  const localRepo = opts['local-repo'];\n  const dumpSDK = opts['dump-sdk']; // if help, print help and bail\n\n  if (help) {\n    printHelp();\n    return process.exit(unrecognized ? 1 : 0);\n  }\n\n  if (version) {\n    return printVersion();\n  }\n\n  if (legal) {\n    return printLegal();\n  }\n\n  if (dumpSDK != null) {\n    return lumo.dumpSDK(dumpSDK);\n  }\n\n  v8.setFlagsFromString('--use_strict');\n\n  if (scripts.length === 0 && !mainNsName && !mainScript && args.length === 0) {\n    opts.repl = true;\n  }\n\n  if (cache || autoCache) {\n    const cachePath = cache || '.lumo_cache';\n    util.ensureDir(cachePath);\n    opts.cache = cachePath;\n  } // TODO: print classpath to stdout if `:verbose`\n\n\n  if (classpath.length !== 0) {\n    // if (verbose) {\n    //   console.log(`Classpath resolves to: `);\n    // }\n    const srcPaths = util.srcPathsFromClasspathStrings(classpath);\n    opts.classpath = srcPaths;\n    lumo.addSourcePaths(srcPaths);\n  }\n\n  if (dependencies.length !== 0) {\n    const mvnPaths = util.srcPathsFromMavenDependencies(dependencies, localRepo);\n    opts.classpath.push(...mvnPaths);\n    lumo.addSourcePaths(mvnPaths);\n  }\n\n  if (opts.repl && !quiet) {\n    printBanner();\n  }\n\n  return startClojureScriptEngine(opts);\n}",
      "after": "async function startCLI(): mixed {\n  const opts = getCLIOpts();\n  const {\n    args,\n    cache,\n    classpath,\n    dependencies,\n    unrecognized,\n    help,\n    legal,\n    mainNsName,\n    mainScript,\n    quiet,\n    scripts,\n    version\n  } = opts;\n  const autoCache = opts['auto-cache'];\n  const localRepo = opts['local-repo'];\n  const dumpSDK = opts['dump-sdk']; // if help, print help and bail\n\n  if (help) {\n    printHelp();\n    return process.exit(unrecognized ? 1 : 0);\n  }\n\n  if (version) {\n    return printVersion();\n  }\n\n  if (legal) {\n    return printLegal();\n  }\n\n  if (dumpSDK != null) {\n    return await lumo.dumpSDK(dumpSDK);\n  }\n\n  v8.setFlagsFromString('--use_strict');\n\n  if (scripts.length === 0 && !mainNsName && !mainScript && args.length === 0) {\n    opts.repl = true;\n  }\n\n  if (cache || autoCache) {\n    const cachePath = cache || '.lumo_cache';\n    util.ensureDir(cachePath);\n    opts.cache = cachePath;\n  } // TODO: print classpath to stdout if `:verbose`\n\n\n  if (classpath.length !== 0) {\n    // if (verbose) {\n    //   console.log(`Classpath resolves to: `);\n    // }\n    const srcPaths = util.srcPathsFromClasspathStrings(classpath);\n    opts.classpath = srcPaths;\n    lumo.addSourcePaths(srcPaths);\n  }\n\n  if (dependencies.length !== 0) {\n    const mvnPaths = util.srcPathsFromMavenDependencies(dependencies, localRepo);\n    opts.classpath.push(...mvnPaths);\n    lumo.addSourcePaths(mvnPaths);\n  }\n\n  if (opts.repl && !quiet) {\n    await printBanner();\n  }\n\n  return await startClojureScriptEngine(opts);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 436,
      "endLine": 439,
      "before": "function processStdin(): void {\n  let code = '';\n  process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?",
      "after": "async function processStdin(): void {\n  let code = '';\n  await process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  await process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  await process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 440,
      "endLine": 442,
      "before": "function processStdin(): void {\n  let code = '';\n  process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?",
      "after": "async function processStdin(): void {\n  let code = '';\n  await process.stdin.on('data', (chunk: string) => {\n    code += chunk;\n  });\n  await process.stdin.on('error', () => {\n    process.stderr.write('Error processing stdin.\\n');\n    process.exit(1);\n  });\n  await process.stdin.on('end', () => {\n    executeScript(code, 'text', false);\n  });\n} // Runs the namespaced cljs function passed into it, which should accept a\n// socket as its only argument\n// TODO: Is this really the best generalization? Should it be?"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 438,
      "endLine": 438,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = await replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/cljs.js",
      "startLine": 567,
      "endLine": 567,
      "before": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    process.nextTick(() => {\n      initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}",
      "after": "async function startClojureScriptEngine(opts: CLIOptsType): Promise<void> {\n  const {\n    args,\n    mainNsName,\n    mainScript,\n    repl,\n    scripts,\n    quiet\n  } = opts;\n  const socketReplArgs = opts['socket-repl'];\n\n  if (socketReplArgs != null) {\n    await initSocketRepl(socketReplArgs, quiet);\n  }\n\n  if (scripts.length > 0) {\n    await initClojureScriptEngine(opts);\n    executeScripts(scripts);\n  }\n\n  if (mainScript) {\n    await initClojureScriptEngine(opts);\n\n    if (mainScript === '-') {\n      await processStdin();\n    } else {\n      executeScript(mainScript, 'path');\n    }\n  }\n\n  if (mainNsName) {\n    await initClojureScriptEngine(opts);\n    runMain(mainNsName, args);\n  }\n\n  if (repl) {\n    await process.nextTick(async () => {\n      await initClojureScriptEngine(opts);\n\n      if (!__DEV__) {\n        setPrintFns(new DiscardingSender());\n      }\n\n      execute(`(require '[lumo.repl\n                    :refer [apropos find-doc all-ns ns-aliases ns-refers ns-map]\n                    :refer-macros [dir doc source]])`, 'text', true, false, 0, 'cljs.user');\n      setPrintFns();\n    });\n    await startREPL(opts);\n  }\n\n  if (!mainNsName && !repl) {\n    await initClojureScriptEngine(opts);\n    runMainCliFn();\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 439,
      "endLine": 439,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = await replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 440,
      "endLine": 440,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = await replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 441,
      "endLine": 441,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = await replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 443,
      "endLine": 445,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = await replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 37,
      "endLine": 40,
      "before": "function onLoad(path: string, fd: number, maxLength: number, offset: number, cb: (ret: string[]) => void): void {\n  const rs = fs.createReadStream(path, {\n    encoding: 'utf-8',\n    fd,\n    start: Math.max(offset, 0),\n    autoClose: false\n  });\n  let tail = '';\n  rs.on('data', (chunk: string) => {\n    // $FlowIssue: slice can return a string\n    tail += chunk;\n  });\n  rs.on('end', () => {\n    tail = tail.slice(0, -1); // history file always ends in newline\n    // $FlowIssue: slice can return a string\n\n    tail = tail.split('\\n');\n\n    if (offset > 0 && tail.length < maxLength) {\n      // eslint-disable-next-line no-mixed-operators\n      onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n    } else {\n      tail = tail.slice(-maxLength);\n      tail.reverse();\n      cb(tail);\n    }\n  });\n}",
      "after": "async function onLoad(path: string, fd: number, maxLength: number, offset: number, cb: (ret: string[]) => void): void {\n  const rs = fs.createReadStream(path, {\n    encoding: 'utf-8',\n    fd,\n    start: Math.max(offset, 0),\n    autoClose: false\n  });\n  let tail = '';\n  await rs.on('data', (chunk: string) => {\n    // $FlowIssue: slice can return a string\n    tail += chunk;\n  });\n  await rs.on('end', async () => {\n    tail = tail.slice(0, -1); // history file always ends in newline\n    // $FlowIssue: slice can return a string\n\n    tail = tail.split('\\n');\n\n    if (offset > 0 && tail.length < maxLength) {\n      // eslint-disable-next-line no-mixed-operators\n      await onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n    } else {\n      tail = tail.slice(-maxLength);\n      tail.reverse();\n      cb(tail);\n    }\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 49,
      "endLine": 49,
      "before": "() => {\n  tail = tail.slice(0, -1); // history file always ends in newline\n  // $FlowIssue: slice can return a string\n\n  tail = tail.split('\\n');\n\n  if (offset > 0 && tail.length < maxLength) {\n    // eslint-disable-next-line no-mixed-operators\n    onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n  } else {\n    tail = tail.slice(-maxLength);\n    tail.reverse();\n    cb(tail);\n  }\n}",
      "after": "async () => {\n  tail = tail.slice(0, -1); // history file always ends in newline\n  // $FlowIssue: slice can return a string\n\n  tail = tail.split('\\n');\n\n  if (offset > 0 && tail.length < maxLength) {\n    // eslint-disable-next-line no-mixed-operators\n    await onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n  } else {\n    tail = tail.slice(-maxLength);\n    tail.reverse();\n    cb(tail);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 42,
      "endLine": 55,
      "before": "function onLoad(path: string, fd: number, maxLength: number, offset: number, cb: (ret: string[]) => void): void {\n  const rs = fs.createReadStream(path, {\n    encoding: 'utf-8',\n    fd,\n    start: Math.max(offset, 0),\n    autoClose: false\n  });\n  let tail = '';\n  rs.on('data', (chunk: string) => {\n    // $FlowIssue: slice can return a string\n    tail += chunk;\n  });\n  rs.on('end', () => {\n    tail = tail.slice(0, -1); // history file always ends in newline\n    // $FlowIssue: slice can return a string\n\n    tail = tail.split('\\n');\n\n    if (offset > 0 && tail.length < maxLength) {\n      // eslint-disable-next-line no-mixed-operators\n      onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n    } else {\n      tail = tail.slice(-maxLength);\n      tail.reverse();\n      cb(tail);\n    }\n  });\n}",
      "after": "async function onLoad(path: string, fd: number, maxLength: number, offset: number, cb: (ret: string[]) => void): void {\n  const rs = fs.createReadStream(path, {\n    encoding: 'utf-8',\n    fd,\n    start: Math.max(offset, 0),\n    autoClose: false\n  });\n  let tail = '';\n  await rs.on('data', (chunk: string) => {\n    // $FlowIssue: slice can return a string\n    tail += chunk;\n  });\n  await rs.on('end', async () => {\n    tail = tail.slice(0, -1); // history file always ends in newline\n    // $FlowIssue: slice can return a string\n\n    tail = tail.split('\\n');\n\n    if (offset > 0 && tail.length < maxLength) {\n      // eslint-disable-next-line no-mixed-operators\n      await onLoad(path, fd, maxLength, offset - 0x100 * maxLength, cb);\n    } else {\n      tail = tail.slice(-maxLength);\n      tail.reverse();\n      cb(tail);\n    }\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 89,
      "endLine": 89,
      "before": "(err: ?Error, stat: fs.Stats) => {\n  const totalSize = stat.size;\n\n  if (totalSize > maxDiskSize) {\n    const rename = function rename(): void {\n      fs.rename(path, `${path}.old`, () => {\n        // $FlowIssue: mode is optional\n        fs.open(path, 'a+', (e: ?ErrnoError, ffd: number) => {\n          loadHistory(path, ffd, maxLength, cb);\n        });\n      });\n    };\n\n    if (fd != null) {\n      fs.close(fd, () => {\n        const oldPath = `${path}.old`;\n        fs.exists(oldPath, (exists: boolean) => {\n          if (exists) {\n            fs.unlink(oldPath, rename);\n          } else {\n            rename();\n          }\n        });\n      });\n    }\n  } else {\n    onLoad(path, fd, maxLength, totalSize, cb);\n  }\n}",
      "after": "async (err: ?Error, stat: fs.Stats) => {\n  const totalSize = stat.size;\n\n  if (totalSize > maxDiskSize) {\n    const rename = async function rename(): void {\n      await fs.rename(path, `${path}.old`, () => {\n        // $FlowIssue: mode is optional\n        fs.open(path, 'a+', async (e: ?ErrnoError, ffd: number) => {\n          await loadHistory(path, ffd, maxLength, cb);\n        });\n      });\n    };\n\n    if (fd != null) {\n      fs.close(fd, () => {\n        const oldPath = `${path}.old`;\n        fs.exists(oldPath, (exists: boolean) => {\n          if (exists) {\n            fs.unlink(oldPath, rename);\n          } else {\n            rename();\n          }\n        });\n      });\n    }\n  } else {\n    await onLoad(path, fd, maxLength, totalSize, cb);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 64,
      "endLine": 91,
      "before": "function loadHistory(path: string, fd: number, maxLength: number, cb: (ret: string[]) => void): void {\n  fs.stat(path, (err: ?Error, stat: fs.Stats) => {\n    const totalSize = stat.size;\n\n    if (totalSize > maxDiskSize) {\n      const rename = function rename(): void {\n        fs.rename(path, `${path}.old`, () => {\n          // $FlowIssue: mode is optional\n          fs.open(path, 'a+', (e: ?ErrnoError, ffd: number) => {\n            loadHistory(path, ffd, maxLength, cb);\n          });\n        });\n      };\n\n      if (fd != null) {\n        fs.close(fd, () => {\n          const oldPath = `${path}.old`;\n          fs.exists(oldPath, (exists: boolean) => {\n            if (exists) {\n              fs.unlink(oldPath, rename);\n            } else {\n              rename();\n            }\n          });\n        });\n      }\n    } else {\n      onLoad(path, fd, maxLength, totalSize, cb);\n    }\n  });\n}",
      "after": "async function loadHistory(path: string, fd: number, maxLength: number, cb: (ret: string[]) => void): void {\n  await fs.stat(path, async (err: ?Error, stat: fs.Stats) => {\n    const totalSize = stat.size;\n\n    if (totalSize > maxDiskSize) {\n      const rename = async function rename(): void {\n        await fs.rename(path, `${path}.old`, () => {\n          // $FlowIssue: mode is optional\n          fs.open(path, 'a+', async (e: ?ErrnoError, ffd: number) => {\n            await loadHistory(path, ffd, maxLength, cb);\n          });\n        });\n      };\n\n      if (fd != null) {\n        fs.close(fd, () => {\n          const oldPath = `${path}.old`;\n          fs.exists(oldPath, (exists: boolean) => {\n            if (exists) {\n              fs.unlink(oldPath, rename);\n            } else {\n              rename();\n            }\n          });\n        });\n      }\n    } else {\n      await onLoad(path, fd, maxLength, totalSize, cb);\n    }\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 71,
      "endLine": 71,
      "before": "(e: ?ErrnoError, ffd: number) => {\n  loadHistory(path, ffd, maxLength, cb);\n}",
      "after": "async (e: ?ErrnoError, ffd: number) => {\n  await loadHistory(path, ffd, maxLength, cb);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 123,
      "endLine": 125,
      "before": "(fd: number) => {\n  loadHistory(path, fd, historySize, (history: string[]) => {\n    rl.history.push(...history);\n  });\n}",
      "after": "async (fd: number) => {\n  await loadHistory(path, fd, historySize, (history: string[]) => {\n    rl.history.push(...history);\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 65,
      "endLine": 65,
      "before": "() => {\n  replHistory({\n    terminal: true\n  });\n  expect(readline.createInterface).toHaveBeenCalled();\n  expect(fs.createWriteStream).toHaveBeenCalled();\n}",
      "after": "async () => {\n  await replHistory({\n    terminal: true\n  });\n  expect(readline.createInterface).toHaveBeenCalled();\n  expect(fs.createWriteStream).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 72,
      "endLine": 72,
      "before": "() => {\n  replHistory({});\n  expect(fs.createWriteStream).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  await replHistory({});\n  expect(fs.createWriteStream).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 78,
      "endLine": 82,
      "before": "() => {\n  const rl = replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n  expect(rl.history.length).toBeGreaterThan(0);\n}",
      "after": "async () => {\n  const rl = await replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n  expect(rl.history.length).toBeGreaterThan(0);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 89,
      "endLine": 92,
      "before": "() => {\n  const rl = replHistory({\n    terminal: true,\n    historySize: 10\n  });\n  expect(fs.stat).not.toHaveBeenCalled();\n  expect(rl.history).toEqual([]);\n}",
      "after": "async () => {\n  const rl = await replHistory({\n    terminal: true,\n    historySize: 10\n  });\n  expect(fs.stat).not.toHaveBeenCalled();\n  expect(rl.history).toEqual([]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 99,
      "endLine": 103,
      "before": "() => {\n  const rl = replHistory({\n    terminal: true,\n    historySize: 10,\n    path: 'nonExistent'\n  });\n  expect(rl.history).toEqual(['']);\n}",
      "after": "async () => {\n  const rl = await replHistory({\n    terminal: true,\n    historySize: 10,\n    path: 'nonExistent'\n  });\n  expect(rl.history).toEqual(['']);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 109,
      "endLine": 112,
      "before": "() => {\n  const rl = replHistory({\n    terminal: true,\n    path: 'foo'\n  });\n  expect(fs.stat).not.toHaveBeenCalled();\n  expect(rl.history).toEqual([]);\n}",
      "after": "async () => {\n  const rl = await replHistory({\n    terminal: true,\n    path: 'foo'\n  });\n  expect(fs.stat).not.toHaveBeenCalled();\n  expect(rl.history).toEqual([]);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 121,
      "endLine": 125,
      "before": "() => {\n  const rl = replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n\n  rl._addHistory();\n\n  expect(streamWrite).toHaveBeenCalledTimes(1);\n  expect(streamWrite).toHaveBeenCalledWith('qux\\n', 'utf8');\n}",
      "after": "async () => {\n  const rl = await replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n\n  rl._addHistory();\n\n  expect(streamWrite).toHaveBeenCalledTimes(1);\n  expect(streamWrite).toHaveBeenCalledWith('qux\\n', 'utf8');\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 154,
      "endLine": 158,
      "before": "() => {\n  fs.exists = jest.fn((_: string, cb: ((ret: boolean) => void)) => cb(false));\n  replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n  expect(fs.rename).toHaveBeenCalled();\n  expect(fs.unlink).not.toHaveBeenCalled();\n}",
      "after": "async () => {\n  fs.exists = jest.fn((_: string, cb: ((ret: boolean) => void)) => cb(false));\n  await replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n  expect(fs.rename).toHaveBeenCalled();\n  expect(fs.unlink).not.toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/__tests__/replHistory-test.js",
      "startLine": 167,
      "endLine": 171,
      "before": "() => {\n  fs.exists = jest.fn((_: string, cb: ((ret: boolean) => void)) => cb(true));\n  replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n  expect(fs.unlink).toHaveBeenCalled();\n  expect(fs.rename).toHaveBeenCalled();\n}",
      "after": "async () => {\n  fs.exists = jest.fn((_: string, cb: ((ret: boolean) => void)) => cb(true));\n  await replHistory({\n    historySize: 10,\n    path: '~/.history',\n    terminal: true\n  });\n  expect(fs.unlink).toHaveBeenCalled();\n  expect(fs.rename).toHaveBeenCalled();\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/repl.js",
      "startLine": 419,
      "endLine": 426,
      "before": "function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  rl.on('line', (line: string) => processLine(session, line));\n  rl.on('SIGINT', () => handleSIGINT(session));\n  rl.on('close', () => stopREPL());\n  rl.on('SIGCONT', () => rl.prompt());\n  process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}",
      "after": "async function startREPL(opts: CLIOptsType): void {\n  const dumbTerminal = opts['dumb-terminal'];\n  const rl = await replHistory({\n    path: getHistoryFilePath(),\n    historySize: 200,\n    input: process.stdin,\n    output: process.stdout,\n    terminal: !dumbTerminal,\n    completer\n  });\n  const session = createSession(rl, true);\n  readline.emitKeypressEvents(process.stdin, rl);\n\n  if (process.stdin.isTTY && !dumbTerminal) {\n    // $FlowIssue\n    process.stdin.setRawMode(true);\n  }\n\n  prompt(session, false, 'cljs.user');\n  await rl.on('line', (line: string) => processLine(session, line));\n  await rl.on('SIGINT', () => handleSIGINT(session));\n  await rl.on('close', () => stopREPL());\n  await rl.on('SIGCONT', () => rl.prompt());\n  await process.stdin.on('keypress', (c: string, key: KeyType) => handleKeyPress(session, c, key));\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/replHistory.js",
      "startLine": 122,
      "endLine": 126,
      "before": "function createInterface(options: replHistory$Opts): readline$Interface {\n  const {\n    path,\n    historySize,\n    terminal\n  } = options;\n  const rl = readline.createInterface(options);\n\n  if (terminal) {\n    const stream = fs.createWriteStream(path, {\n      flags: 'a+',\n      defaultEncoding: 'utf8'\n    }); // $FlowIssue: private property\n\n    const oldAddHistory = rl._addHistory; // $FlowIssue: private property\n\n    rl._addHistory = function _addHistory(): string {\n      const [last] = rl.history;\n      const line = oldAddHistory.call(rl);\n\n      if (line.length > 0 && line !== last) {\n        stream.write(`${line}\\n`, 'utf8');\n      }\n\n      return line;\n    };\n\n    if (path != null && historySize != null) {\n      stream.on('open', (fd: number) => {\n        loadHistory(path, fd, historySize, (history: string[]) => {\n          rl.history.push(...history);\n        });\n      });\n    }\n  }\n\n  return rl;\n}",
      "after": "async function createInterface(options: replHistory$Opts): readline$Interface {\n  const {\n    path,\n    historySize,\n    terminal\n  } = options;\n  const rl = readline.createInterface(options);\n\n  if (terminal) {\n    const stream = fs.createWriteStream(path, {\n      flags: 'a+',\n      defaultEncoding: 'utf8'\n    }); // $FlowIssue: private property\n\n    const oldAddHistory = rl._addHistory; // $FlowIssue: private property\n\n    rl._addHistory = function _addHistory(): string {\n      const [last] = rl.history;\n      const line = oldAddHistory.call(rl);\n\n      if (line.length > 0 && line !== last) {\n        stream.write(`${line}\\n`, 'utf8');\n      }\n\n      return line;\n    };\n\n    if (path != null && historySize != null) {\n      await stream.on('open', async (fd: number) => {\n        await loadHistory(path, fd, historySize, (history: string[]) => {\n          rl.history.push(...history);\n        });\n      });\n    }\n  }\n\n  return rl;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 24,
      "endLine": 26,
      "before": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nfunction openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  socket.on('close', () => {\n    deleteSession(session);\n  });\n  socket.on('error', () => {});\n  rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle",
      "after": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nasync function openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  await socket.on('close', () => {\n    deleteSession(session);\n  });\n  await socket.on('error', () => {});\n  await rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  await rl.on('close', () => socket.destroy());\n  rl.output.write(await createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 52,
      "endLine": 52,
      "before": "// Calls the `accept` function on the socket and handles the socket lifecycle\nfunction handleConnection(socket: net$Socket, accept: AcceptFn, args: Array<mixed> = []): number {\n  if (typeof accept === 'string') {\n    runAcceptFN(accept, socket, args);\n  } else {\n    accept(socket);\n  } // The index needs to be unique for the socket server, but not for anyone else.\n  // For that reason we're using a module global `sessionCount` variable\n\n\n  socket.on('close', () => {\n    delete sockets[sessionCount];\n  });\n  sockets[sessionCount] = socket;\n  sessionCount += 1;\n  return sessionCount;\n}",
      "after": "// Calls the `accept` function on the socket and handles the socket lifecycle\nasync function handleConnection(socket: net$Socket, accept: AcceptFn, args: Array<mixed> = []): number {\n  if (typeof accept === 'string') {\n    runAcceptFN(accept, socket, args);\n  } else {\n    await accept(socket);\n  } // The index needs to be unique for the socket server, but not for anyone else.\n  // For that reason we're using a module global `sessionCount` variable\n\n\n  await socket.on('close', () => {\n    delete sockets[sessionCount];\n  });\n  sockets[sessionCount] = socket;\n  sessionCount += 1;\n  return sessionCount;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 93,
      "endLine": 93,
      "before": "(resolve: ((mixed) => void), reject: ((Error) => void)) => {\n  socketServer = net.createServer((socket: net$Socket) => handleConnection(socket, accept, args)); // $FlowIssue - wrong type definitions for `listen`\n\n  socketServer.listen(port, host, () => {\n    resolve();\n    process.on('SIGTERM', close);\n    process.on('SIGHUP', close);\n  }).on('error', reject);\n}",
      "after": "async (resolve: ((mixed) => void), reject: ((Error) => void)) => {\n  socketServer = net.createServer(async (socket: net$Socket) => await handleConnection(socket, accept, args)); // $FlowIssue - wrong type definitions for `listen`\n\n  await socketServer.listen(port, host, async () => {\n    resolve();\n    await process.on('SIGTERM', close);\n    await process.on('SIGHUP', close);\n  }).on('error', reject);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 28,
      "endLine": 28,
      "before": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nfunction openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  socket.on('close', () => {\n    deleteSession(session);\n  });\n  socket.on('error', () => {});\n  rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle",
      "after": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nasync function openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  await socket.on('close', () => {\n    deleteSession(session);\n  });\n  await socket.on('error', () => {});\n  await rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  await rl.on('close', () => socket.destroy());\n  rl.output.write(await createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 30,
      "endLine": 35,
      "before": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nfunction openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  socket.on('close', () => {\n    deleteSession(session);\n  });\n  socket.on('error', () => {});\n  rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle",
      "after": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nasync function openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  await socket.on('close', () => {\n    deleteSession(session);\n  });\n  await socket.on('error', () => {});\n  await rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  await rl.on('close', () => socket.destroy());\n  rl.output.write(await createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 37,
      "endLine": 37,
      "before": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nfunction openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  socket.on('close', () => {\n    deleteSession(session);\n  });\n  socket.on('error', () => {});\n  rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  rl.on('close', () => socket.destroy());\n  rl.output.write(createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle",
      "after": "// Default socket accept function. This opens a repl and handles the readline and repl lifecycle\nasync function openRepl(socket: net$Socket): void {\n  const rl = readline.createInterface({\n    input: socket,\n    output: socket\n  });\n  const session = createSession(rl, false);\n  await socket.on('close', () => {\n    deleteSession(session);\n  });\n  await socket.on('error', () => {});\n  await rl.on('line', (line: string) => {\n    // $FlowIssue: it's there\n    if (!socket.destroyed) {\n      processLine(session, line);\n    }\n  });\n  await rl.on('close', () => socket.destroy());\n  rl.output.write(await createBanner());\n  prompt(session, false, 'cljs.user');\n} // Calls the `accept` function on the socket and handles the socket lifecycle"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 57,
      "endLine": 59,
      "before": "// Calls the `accept` function on the socket and handles the socket lifecycle\nfunction handleConnection(socket: net$Socket, accept: AcceptFn, args: Array<mixed> = []): number {\n  if (typeof accept === 'string') {\n    runAcceptFN(accept, socket, args);\n  } else {\n    accept(socket);\n  } // The index needs to be unique for the socket server, but not for anyone else.\n  // For that reason we're using a module global `sessionCount` variable\n\n\n  socket.on('close', () => {\n    delete sockets[sessionCount];\n  });\n  sockets[sessionCount] = socket;\n  sessionCount += 1;\n  return sessionCount;\n}",
      "after": "// Calls the `accept` function on the socket and handles the socket lifecycle\nasync function handleConnection(socket: net$Socket, accept: AcceptFn, args: Array<mixed> = []): number {\n  if (typeof accept === 'string') {\n    runAcceptFN(accept, socket, args);\n  } else {\n    await accept(socket);\n  } // The index needs to be unique for the socket server, but not for anyone else.\n  // For that reason we're using a module global `sessionCount` variable\n\n\n  await socket.on('close', () => {\n    delete sockets[sessionCount];\n  });\n  sockets[sessionCount] = socket;\n  sessionCount += 1;\n  return sessionCount;\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 97,
      "endLine": 103,
      "before": "(resolve: ((mixed) => void), reject: ((Error) => void)) => {\n  socketServer = net.createServer((socket: net$Socket) => handleConnection(socket, accept, args)); // $FlowIssue - wrong type definitions for `listen`\n\n  socketServer.listen(port, host, () => {\n    resolve();\n    process.on('SIGTERM', close);\n    process.on('SIGHUP', close);\n  }).on('error', reject);\n}",
      "after": "async (resolve: ((mixed) => void), reject: ((Error) => void)) => {\n  socketServer = net.createServer(async (socket: net$Socket) => await handleConnection(socket, accept, args)); // $FlowIssue - wrong type definitions for `listen`\n\n  await socketServer.listen(port, host, async () => {\n    resolve();\n    await process.on('SIGTERM', close);\n    await process.on('SIGHUP', close);\n  }).on('error', reject);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 100,
      "endLine": 100,
      "before": "() => {\n  resolve();\n  process.on('SIGTERM', close);\n  process.on('SIGHUP', close);\n}",
      "after": "async () => {\n  resolve();\n  await process.on('SIGTERM', close);\n  await process.on('SIGHUP', close);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/src/js/socketRepl.js",
      "startLine": 101,
      "endLine": 101,
      "before": "() => {\n  resolve();\n  process.on('SIGTERM', close);\n  process.on('SIGHUP', close);\n}",
      "after": "async () => {\n  resolve();\n  await process.on('SIGTERM', close);\n  await process.on('SIGHUP', close);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/bundle.js",
      "startLine": 115,
      "endLine": 117,
      "before": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nfunction bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  ws.on('close', function () {\n    var source = fs.readFileSync(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}",
      "after": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nasync function bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  await bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  await ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  await ws.on('close', async function () {\n    var source = await fs.promises.readFile(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 199,
      "endLine": 199,
      "before": "/**\n * Bundle the application into one script\n **/\nfunction combineProject(next) {\n  if (options.noBundle) {\n    _log('using provided bundle %s since noBundle is true', options.input);\n\n    const source = fs.readFileSync(options.input, 'utf8');\n    const thirdPartyMain = `\nif (!process.send) {\n  process.argv.splice(1, 0, 'nexe.js');\n}\n\nconst Module = require('module');\nconst initModule = new Module(process.execPath, null);\ninitModule.paths = Module._nodeModulePaths(process.cwd());\nreturn initModule._compile(${JSON.stringify(source)}, process.execPath);\n        `;\n    fs.writeFileSync(path.join(nodeCompiler.dir, 'lib', '_third_party_main.js'), thirdPartyMain);\n    next();\n  } else {\n    _log('bundle %s', options.input);\n\n    bundle(options.input, nodeCompiler.dir, options, next);\n  }\n}",
      "after": "/**\n * Bundle the application into one script\n **/\nasync function combineProject(next) {\n  if (options.noBundle) {\n    _log('using provided bundle %s since noBundle is true', options.input);\n\n    const source = fs.readFileSync(options.input, 'utf8');\n    const thirdPartyMain = `\nif (!process.send) {\n  process.argv.splice(1, 0, 'nexe.js');\n}\n\nconst Module = require('module');\nconst initModule = new Module(process.execPath, null);\ninitModule.paths = Module._nodeModulePaths(process.cwd());\nreturn initModule._compile(${JSON.stringify(source)}, process.execPath);\n        `;\n    fs.writeFileSync(path.join(nodeCompiler.dir, 'lib', '_third_party_main.js'), thirdPartyMain);\n    next();\n  } else {\n    _log('bundle %s', options.input);\n\n    await bundle(options.input, nodeCompiler.dir, options, next);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/bundle.js",
      "startLine": 119,
      "endLine": 123,
      "before": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nfunction bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  ws.on('close', function () {\n    var source = fs.readFileSync(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}",
      "after": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nasync function bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  await bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  await ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  await ws.on('close', async function () {\n    var source = await fs.promises.readFile(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/bundle.js",
      "startLine": 125,
      "endLine": 138,
      "before": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nfunction bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  ws.on('close', function () {\n    var source = fs.readFileSync(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}",
      "after": "/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nasync function bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, 'lib', 'nexe.js');\n  const mapfile = options.output + '.map';\n  let ws = fs.createWriteStream(bundlePath);\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {\n    isNexe: true\n  },\n      wantedGlobalVars = igv.split(','); // parse insertGlobalVars.\n\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n  let paths = [path.join(nc, 'lib')];\n\n  if (options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n  _log('executing browserify via API');\n\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n\n      _log(\"Excluding '%s' from browserify bundle\", lib);\n\n      bproc.exclude(lib);\n    }\n  } // copy the excludes code for requires for now.\n\n\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n      // if `lib` is object then fetch all params without `file`\n      // otherwise returns empty object\n\n      let opts = lib instanceof Object && Object.keys(lib).filter(key => key !== 'file').reduce((acc, key) => {\n        return acc[key] = lib[key], acc;\n      }, {}) || {};\n\n      _log(\"Force including '%s' in browserify bundle\", name);\n\n      bproc.require(lib, opts);\n    }\n  }\n\n  if (options.debug) {\n    bproc.require(require.resolve('source-map-support'));\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n  .pipe(ws); // pipe to file\n  // error on require errors, still can't contionue. ffs browserify\n\n  await bprocbun.on('error', function (err) {\n    _log('error', '[browserify] ' + err);\n  });\n  await ws.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'Failed to save stdout to disk');\n\n    process.exit(1);\n  });\n  await ws.on('close', async function () {\n    var source = await fs.promises.readFile(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, ''); // write the source modified to nexe.js\n\n    fs.writeFile(bundlePath, source, 'utf8', function (err) {\n      if (err) {\n        _log('error', 'failed to save source');\n\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 110,
      "endLine": 122,
      "before": "/**\n *check relevant options\n */\nfunction checkOpts(next) {\n  /* failsafe */\n  if (options === undefined) {\n    _log('error', 'no options given to .compile()');\n\n    process.exit();\n  }\n  /**\n   * Have we been given a custom flag for python executable?\n   **/\n\n\n  if (options.python !== 'python' && options.python !== '' && options.python !== undefined) {\n    if (isWin) {\n      isPy = options.python.replace(/\\//gm, '\\\\'); // use windows file paths, batch is sensitive.\n    } else {\n      isPy = options.python;\n    }\n\n    _log('set python as ' + isPy);\n  } else {\n    isPy = 'python';\n  } // remove dots\n\n\n  options.framework = options.framework.replace(/\\./g, ''); // set outter-scope framework variable.\n\n  framework = options.framework;\n\n  _log('framework => ' + framework);\n\n  version = options.nodeVersion; // better framework vc\n  // check iojs version\n\n  if (framework === 'iojs' && version === 'latest') {\n    _log('fetching iojs versions');\n\n    mkdirp(options.nodeTempDir); // make temp dir, probably repetive.\n    // create write stream so we have control over events\n\n    var output = fs.createWriteStream(path.join(options.nodeTempDir, 'iojs-versions.json'));\n    request.get('https://iojs.org/dist/index.json').pipe(output);\n    output.on('close', function () {\n      _log('done');\n\n      var f = fs.readFileSync(path.join(options.nodeTempDir, 'iojs-versions.json'));\n      f = JSON.parse(f);\n      version = f[0].version.replace('v', '');\n\n      _log('iojs latest => ' + version); // continue down along the async road\n\n\n      next();\n    });\n  } else {\n    next();\n  }\n}",
      "after": "/**\n *check relevant options\n */\nasync function checkOpts(next) {\n  /* failsafe */\n  if (options === undefined) {\n    _log('error', 'no options given to .compile()');\n\n    process.exit();\n  }\n  /**\n   * Have we been given a custom flag for python executable?\n   **/\n\n\n  if (options.python !== 'python' && options.python !== '' && options.python !== undefined) {\n    if (isWin) {\n      isPy = options.python.replace(/\\//gm, '\\\\'); // use windows file paths, batch is sensitive.\n    } else {\n      isPy = options.python;\n    }\n\n    _log('set python as ' + isPy);\n  } else {\n    isPy = 'python';\n  } // remove dots\n\n\n  options.framework = options.framework.replace(/\\./g, ''); // set outter-scope framework variable.\n\n  framework = options.framework;\n\n  _log('framework => ' + framework);\n\n  version = options.nodeVersion; // better framework vc\n  // check iojs version\n\n  if (framework === 'iojs' && version === 'latest') {\n    _log('fetching iojs versions');\n\n    mkdirp(options.nodeTempDir); // make temp dir, probably repetive.\n    // create write stream so we have control over events\n\n    var output = fs.createWriteStream(path.join(options.nodeTempDir, 'iojs-versions.json'));\n    request.get('https://iojs.org/dist/index.json').pipe(output);\n    await output.on('close', async function () {\n      _log('done');\n\n      var f = await fs.promises.readFile(path.join(options.nodeTempDir, 'iojs-versions.json'));\n      f = JSON.parse(f);\n      version = f[0].version.replace('v', '');\n\n      _log('iojs latest => ' + version); // continue down along the async road\n\n\n      next();\n    });\n  } else {\n    next();\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 416,
      "endLine": 418,
      "before": "/**\n * download node into the target directory\n */\nfunction downloadNode(next) {\n  if (fs.existsSync(nodeFilePath)) return next();\n  var uri = framework;\n\n  if (framework === 'node') {\n    uri = 'nodejs'; // if node, use nodejs uri\n  } else if (framework === 'nodejs') {\n    framework = 'node'; // support nodejs, and node, as framework.\n  }\n\n  var type = global.type;\n  var url,\n      prefix = 'https://' + uri + '.org/dist';\n\n  if (version === 'latest') {\n    url = prefix + '/' + framework + '-' + version + '.tar.gz';\n  } else {\n    url = prefix + '/v' + version + '/' + framework + '-v' + version + '.tar.gz';\n  }\n\n  _log('downloading %s', url);\n\n  var output = fs.createWriteStream(nodeFilePath, {\n    flags: 'w+'\n  }); // need to set user-agent to bypass some corporate firewalls\n\n  var requestOptions = {\n    url: url,\n    headers: {\n      'User-Agent': 'Node.js'\n    }\n  };\n\n  _logProgress(request(requestOptions)).pipe(output);\n\n  output.on('close', function () {\n    next();\n  });\n}",
      "after": "/**\n * download node into the target directory\n */\nasync function downloadNode(next) {\n  if (fs.existsSync(nodeFilePath)) return next();\n  var uri = framework;\n\n  if (framework === 'node') {\n    uri = 'nodejs'; // if node, use nodejs uri\n  } else if (framework === 'nodejs') {\n    framework = 'node'; // support nodejs, and node, as framework.\n  }\n\n  var type = global.type;\n  var url,\n      prefix = 'https://' + uri + '.org/dist';\n\n  if (version === 'latest') {\n    url = prefix + '/' + framework + '-' + version + '.tar.gz';\n  } else {\n    url = prefix + '/v' + version + '/' + framework + '-v' + version + '.tar.gz';\n  }\n\n  _log('downloading %s', url);\n\n  var output = fs.createWriteStream(nodeFilePath, {\n    flags: 'w+'\n  }); // need to set user-agent to bypass some corporate firewalls\n\n  var requestOptions = {\n    url: url,\n    headers: {\n      'User-Agent': 'Node.js'\n    }\n  };\n  (await _logProgress(request(requestOptions))).pipe(output);\n  await output.on('close', function () {\n    next();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 444,
      "endLine": 481,
      "before": "/**\n * unzip in the same directory\n */\nfunction unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    extract.on('entry', function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      write.on('close', function () {\n        return callback();\n      });\n      stream.on('error', function (err) {\n        return onError(err);\n      });\n      write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}",
      "after": "/**\n * unzip in the same directory\n */\nasync function unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    await extract.on('entry', async function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      await write.on('close', function () {\n        return callback();\n      });\n      await stream.on('error', function (err) {\n        return onError(err);\n      });\n      await write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    await extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    await tar.on('close', function () {\n      return next();\n    });\n    await tar.on('error', onError);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 132,
      "endLine": 139,
      "before": "/**\n * first download node\n */\nfunction downloadNode(next) {\n  _downloadNode(version, options.nodeTempDir, options.nodeConfigureArgs, options.nodeMakeArgs, options.nodeVCBuildArgs, next);\n}",
      "after": "/**\n * first download node\n */\nasync function downloadNode(next) {\n  await _downloadNode(version, options.nodeTempDir, options.nodeConfigureArgs, options.nodeMakeArgs, options.nodeVCBuildArgs, next);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 468,
      "endLine": 470,
      "before": "function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  write.on('close', function () {\n    return callback();\n  });\n  stream.on('error', function (err) {\n    return onError(err);\n  });\n  write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}",
      "after": "async function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  await write.on('close', function () {\n    return callback();\n  });\n  await stream.on('error', function (err) {\n    return onError(err);\n  });\n  await write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 472,
      "endLine": 474,
      "before": "function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  write.on('close', function () {\n    return callback();\n  });\n  stream.on('error', function (err) {\n    return onError(err);\n  });\n  write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}",
      "after": "async function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  await write.on('close', function () {\n    return callback();\n  });\n  await stream.on('error', function (err) {\n    return onError(err);\n  });\n  await write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 476,
      "endLine": 478,
      "before": "function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  write.on('close', function () {\n    return callback();\n  });\n  stream.on('error', function (err) {\n    return onError(err);\n  });\n  write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}",
      "after": "async function (header, stream, callback) {\n  // header is the tar header\n  // stream is the content body (might be an empty stream)\n  // call next when you are done with this entry\n  var absolutepath = path.join(basedir, header.name);\n\n  if (header.type === 'directory') {\n    // handle directories.\n    // console.log('dir:', header.name);\n    fs.mkdirSync(absolutepath);\n    return callback();\n  } else if (header.type === 'file') {// handle files\n    // console.log('file:', header.name);\n  } else {\n    console.log(header.type + ':', header.name);\n\n    _log('warn', 'unhandled type in tar extraction, skipping');\n\n    return callback();\n  }\n\n  var write = fs.createWriteStream(absolutepath);\n  stream.pipe(write);\n  await write.on('close', function () {\n    return callback();\n  });\n  await stream.on('error', function (err) {\n    return onError(err);\n  });\n  await write.on('error', function (err) {\n    return onError(err);\n  });\n  stream.resume(); // just auto drain the stream\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 483,
      "endLine": 486,
      "before": "/**\n * unzip in the same directory\n */\nfunction unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    extract.on('entry', function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      write.on('close', function () {\n        return callback();\n      });\n      stream.on('error', function (err) {\n        return onError(err);\n      });\n      write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}",
      "after": "/**\n * unzip in the same directory\n */\nasync function unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    await extract.on('entry', async function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      await write.on('close', function () {\n        return callback();\n      });\n      await stream.on('error', function (err) {\n        return onError(err);\n      });\n      await write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    await extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    await tar.on('close', function () {\n      return next();\n    });\n    await tar.on('error', onError);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 499,
      "endLine": 501,
      "before": "/**\n * unzip in the same directory\n */\nfunction unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    extract.on('entry', function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      write.on('close', function () {\n        return callback();\n      });\n      stream.on('error', function (err) {\n        return onError(err);\n      });\n      write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}",
      "after": "/**\n * unzip in the same directory\n */\nasync function unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    await extract.on('entry', async function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      await write.on('close', function () {\n        return callback();\n      });\n      await stream.on('error', function (err) {\n        return onError(err);\n      });\n      await write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    await extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    await tar.on('close', function () {\n      return next();\n    });\n    await tar.on('error', onError);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 502,
      "endLine": 502,
      "before": "/**\n * unzip in the same directory\n */\nfunction unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    extract.on('entry', function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      write.on('close', function () {\n        return callback();\n      });\n      stream.on('error', function (err) {\n        return onError(err);\n      });\n      write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    tar.on('close', function () {\n      return next();\n    });\n    tar.on('error', onError);\n  }\n}",
      "after": "/**\n * unzip in the same directory\n */\nasync function unzipNodeTarball(next) {\n  var onError = function (err) {\n    console.log(err.stack);\n\n    _log('error', 'failed to extract the node source');\n\n    process.exit(1);\n  };\n\n  if (isWin) {\n    _log('extracting the node source [node-tar.gz]'); // tar-stream method w/ gunzip-maybe\n\n\n    var read = fs.createReadStream(nodeFilePath);\n    var extract = tarstream.extract();\n    var basedir = nodeFileDir;\n\n    if (!fs.existsSync(nodeFileDir)) {\n      fs.mkdirSync(nodeFileDir);\n    }\n\n    await extract.on('entry', async function (header, stream, callback) {\n      // header is the tar header\n      // stream is the content body (might be an empty stream)\n      // call next when you are done with this entry\n      var absolutepath = path.join(basedir, header.name);\n\n      if (header.type === 'directory') {\n        // handle directories.\n        // console.log('dir:', header.name);\n        fs.mkdirSync(absolutepath);\n        return callback();\n      } else if (header.type === 'file') {// handle files\n        // console.log('file:', header.name);\n      } else {\n        console.log(header.type + ':', header.name);\n\n        _log('warn', 'unhandled type in tar extraction, skipping');\n\n        return callback();\n      }\n\n      var write = fs.createWriteStream(absolutepath);\n      stream.pipe(write);\n      await write.on('close', function () {\n        return callback();\n      });\n      await stream.on('error', function (err) {\n        return onError(err);\n      });\n      await write.on('error', function (err) {\n        return onError(err);\n      });\n      stream.resume(); // just auto drain the stream\n    });\n    await extract.on('finish', function () {\n      _log('extraction finished');\n\n      return next();\n    });\n    read.pipe(gunzip()).pipe(extract);\n  } else {\n    _log('extracting the node source [native tar]');\n\n    var cmd = ['tar', '-xf', nodeFilePath, '-C', nodeFileDir];\n\n    _log(cmd.join(' '));\n\n    var tar = spawn(cmd.shift(), cmd);\n    tar.stdout.pipe(process.stdout);\n    tar.stderr.pipe(process.stderr);\n    await tar.on('close', function () {\n      return next();\n    });\n    await tar.on('error', onError);\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 576,
      "endLine": 578,
      "before": "function (next) {\n  // create a new env with minimal impact on old one\n  var newEnv = process.env;\n\n  if (isPy !== 'python') {\n    // add the dir of the suposed python exe to path\n    newEnv.path = process.env.PATH + ';' + path.dirname(isPy);\n  }\n\n  if (!nodeVCBuildArgs || !nodeVCBuildArgs.length) {\n    nodeVCBuildArgs = ['nosign']; // \"release\" is already the default config value in VCBuild.bat\n  } // spawn a vcbuild process with our custom enviroment.\n\n\n  var vcbuild = spawn('vcbuild.bat', nodeVCBuildArgs, {\n    cwd: dir,\n    env: newEnv\n  });\n  vcbuild.stdout.pipe(process.stdout);\n  vcbuild.stderr.pipe(process.stderr);\n  vcbuild.on('close', function () {\n    next();\n  });\n}",
      "after": "async function (next) {\n  // create a new env with minimal impact on old one\n  var newEnv = process.env;\n\n  if (isPy !== 'python') {\n    // add the dir of the suposed python exe to path\n    newEnv.path = process.env.PATH + ';' + path.dirname(isPy);\n  }\n\n  if (!nodeVCBuildArgs || !nodeVCBuildArgs.length) {\n    nodeVCBuildArgs = ['nosign']; // \"release\" is already the default config value in VCBuild.bat\n  } // spawn a vcbuild process with our custom enviroment.\n\n\n  var vcbuild = spawn('vcbuild.bat', nodeVCBuildArgs, {\n    cwd: dir,\n    env: newEnv\n  });\n  vcbuild.stdout.pipe(process.stdout);\n  vcbuild.stderr.pipe(process.stderr);\n  await vcbuild.on('close', function () {\n    next();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 268,
      "endLine": 268,
      "before": "/**\n * compile the node application\n */\nfunction makeExecutable(next) {\n  if (isWin) {\n    _log('vcbuild [make stage]');\n  } else {\n    _log('make');\n  }\n\n  nodeCompiler.make(next);\n}",
      "after": "/**\n * compile the node application\n */\nasync function makeExecutable(next) {\n  if (isWin) {\n    _log('vcbuild [make stage]');\n  } else {\n    _log('make');\n  }\n\n  await nodeCompiler.make(next);\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 637,
      "endLine": 661,
      "before": "function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  configure.on('close', function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    make.on('close', function () {\n      next();\n    });\n  });\n}",
      "after": "async function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  await configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  await configure.on('close', async function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    await make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    await make.on('close', function () {\n      next();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 664,
      "endLine": 699,
      "before": "function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  configure.on('close', function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    make.on('close', function () {\n      next();\n    });\n  });\n}",
      "after": "async function (next) {\n  var cfg = './configure',\n      configure;\n  var conf = [cfg];\n  /* add all nodeConfigureArgs to the ./configure argument array */\n\n  conf = [conf].concat(nodeConfigureArgs); // should work for all use cases now.\n\n  configure = spawn(isPy, conf, {\n    cwd: dir.toString('ascii')\n  }); // local function, move to top eventually\n\n  function _loop(dir) {\n    /* eventually try every python file */\n    var pdir = fs.readdirSync(dir);\n    pdir.forEach(function (v, i) {\n      var stat = fs.statSync(dir + '/' + v);\n\n      if (stat.isFile()) {\n        // only process Makefiles and .mk targets.\n        if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n          return;\n        }\n\n        _log('patching ' + v);\n        /* patch the file */\n\n\n        var py = fs.readFileSync(dir + '/' + v, {\n          encoding: 'utf8'\n        });\n        py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n        fs.writeFileSync(dir + '/' + v, py, {\n          encoding: 'utf8'\n        }); // write to file\n      } else if (stat.isDirectory()) {\n        // must be dir?\n        // skip tests because we don't need them here\n        if (v !== 'test') {\n          _loop(dir + '/' + v);\n        }\n      }\n    });\n  }\n\n  configure.stdout.pipe(process.stdout);\n  configure.stderr.pipe(process.stderr); // on error\n\n  await configure.on('error', function (err) {\n    console.log('Error:', err);\n    console.log('');\n    console.log('Details:');\n    console.log('command =', isPy, cfg, conf_args || '');\n    console.log('cwd =', dir);\n    var configure_path = path.join(dir, 'configure');\n    var contains_configure = fs.existsSync(configure_path);\n    console.log('cwd contains configure,', contains_configure ? colors.green('yes') : colors.red('no'));\n    var configure_size = fs.statSync(configure_path).size;\n    console.log('configure is non-zero size,', configure_size > 0 ? colors.green('yes') : colors.red('no'));\n\n    _log('error', 'failed to launch configure.');\n\n    process.exit(1);\n  }); // when it's finished\n\n  await configure.on('close', async function () {\n    if (isPy !== 'python') {\n      /**\n       * Originally I thought this only applied to io.js,\n       * however I soon found out this affects node.js,\n       * so it is now mainstream.\n       */\n      _log('preparing python'); // loop over depends\n\n\n      _loop(dir);\n    }\n\n    if (nodeMakeArgs === undefined) {\n      nodeMakeArgs = [];\n    }\n\n    var platformMake = 'make';\n\n    if (os.platform().match(/bsd$/) != null) {\n      platformMake = 'gmake';\n    }\n\n    var make = spawn(platformMake, nodeMakeArgs, {\n      cwd: dir\n    });\n    make.stdout.pipe(process.stdout);\n    make.stderr.pipe(process.stderr);\n    await make.on('error', function (err) {\n      console.log(err);\n\n      _log('error', 'failed to run make.');\n\n      process.exit(1);\n    });\n    await make.on('close', function () {\n      next();\n    });\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 691,
      "endLine": 695,
      "before": "function () {\n  if (isPy !== 'python') {\n    /**\n     * Originally I thought this only applied to io.js,\n     * however I soon found out this affects node.js,\n     * so it is now mainstream.\n     */\n    _log('preparing python'); // loop over depends\n\n\n    _loop(dir);\n  }\n\n  if (nodeMakeArgs === undefined) {\n    nodeMakeArgs = [];\n  }\n\n  var platformMake = 'make';\n\n  if (os.platform().match(/bsd$/) != null) {\n    platformMake = 'gmake';\n  }\n\n  var make = spawn(platformMake, nodeMakeArgs, {\n    cwd: dir\n  });\n  make.stdout.pipe(process.stdout);\n  make.stderr.pipe(process.stderr);\n  make.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to run make.');\n\n    process.exit(1);\n  });\n  make.on('close', function () {\n    next();\n  });\n}",
      "after": "async function () {\n  if (isPy !== 'python') {\n    /**\n     * Originally I thought this only applied to io.js,\n     * however I soon found out this affects node.js,\n     * so it is now mainstream.\n     */\n    _log('preparing python'); // loop over depends\n\n\n    _loop(dir);\n  }\n\n  if (nodeMakeArgs === undefined) {\n    nodeMakeArgs = [];\n  }\n\n  var platformMake = 'make';\n\n  if (os.platform().match(/bsd$/) != null) {\n    platformMake = 'gmake';\n  }\n\n  var make = spawn(platformMake, nodeMakeArgs, {\n    cwd: dir\n  });\n  make.stdout.pipe(process.stdout);\n  make.stderr.pipe(process.stderr);\n  await make.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to run make.');\n\n    process.exit(1);\n  });\n  await make.on('close', function () {\n    next();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 696,
      "endLine": 698,
      "before": "function () {\n  if (isPy !== 'python') {\n    /**\n     * Originally I thought this only applied to io.js,\n     * however I soon found out this affects node.js,\n     * so it is now mainstream.\n     */\n    _log('preparing python'); // loop over depends\n\n\n    _loop(dir);\n  }\n\n  if (nodeMakeArgs === undefined) {\n    nodeMakeArgs = [];\n  }\n\n  var platformMake = 'make';\n\n  if (os.platform().match(/bsd$/) != null) {\n    platformMake = 'gmake';\n  }\n\n  var make = spawn(platformMake, nodeMakeArgs, {\n    cwd: dir\n  });\n  make.stdout.pipe(process.stdout);\n  make.stderr.pipe(process.stderr);\n  make.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to run make.');\n\n    process.exit(1);\n  });\n  make.on('close', function () {\n    next();\n  });\n}",
      "after": "async function () {\n  if (isPy !== 'python') {\n    /**\n     * Originally I thought this only applied to io.js,\n     * however I soon found out this affects node.js,\n     * so it is now mainstream.\n     */\n    _log('preparing python'); // loop over depends\n\n\n    _loop(dir);\n  }\n\n  if (nodeMakeArgs === undefined) {\n    nodeMakeArgs = [];\n  }\n\n  var platformMake = 'make';\n\n  if (os.platform().match(/bsd$/) != null) {\n    platformMake = 'gmake';\n  }\n\n  var make = spawn(platformMake, nodeMakeArgs, {\n    cwd: dir\n  });\n  make.stdout.pipe(process.stdout);\n  make.stderr.pipe(process.stderr);\n  await make.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to run make.');\n\n    process.exit(1);\n  });\n  await make.on('close', function () {\n    next();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 1093,
      "endLine": 1105,
      "before": "/**\n * Log the progress of a request object.\n */\nfunction _logProgress(req) {\n  req.on('response', function (resp) {\n    var len = parseInt(resp.headers['content-length'], 10),\n        bar = new ProgressBar('[:bar]', {\n      complete: '=',\n      incomplete: ' ',\n      total: len,\n      width: 100 // just use 100\n\n    });\n    req.on('data', function (chunk) {\n      bar.tick(chunk.length);\n    });\n  });\n  req.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to download node sources,');\n\n    process.exit(1);\n  });\n  return req;\n}\n/**\n * Attempt to parse the package.json for nexe information.\n *\n * @param {string} path - path to package.json\n * @param {object} options - fallback options\n *\n * @todo implement options overriding package defaults.\n * @todo make this much less hackily implemented....\n *\n * @return {object} nexe.compile - options object\n **/",
      "after": "/**\n * Log the progress of a request object.\n */\nasync function _logProgress(req) {\n  await req.on('response', async function (resp) {\n    var len = parseInt(resp.headers['content-length'], 10),\n        bar = new ProgressBar('[:bar]', {\n      complete: '=',\n      incomplete: ' ',\n      total: len,\n      width: 100 // just use 100\n\n    });\n    await req.on('data', function (chunk) {\n      bar.tick(chunk.length);\n    });\n  });\n  await req.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to download node sources,');\n\n    process.exit(1);\n  });\n  return req;\n}\n/**\n * Attempt to parse the package.json for nexe information.\n *\n * @param {string} path - path to package.json\n * @param {object} options - fallback options\n *\n * @todo implement options overriding package defaults.\n * @todo make this much less hackily implemented....\n *\n * @return {object} nexe.compile - options object\n **/"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 414,
      "endLine": 414,
      "before": "/**\n * download node into the target directory\n */\nfunction downloadNode(next) {\n  if (fs.existsSync(nodeFilePath)) return next();\n  var uri = framework;\n\n  if (framework === 'node') {\n    uri = 'nodejs'; // if node, use nodejs uri\n  } else if (framework === 'nodejs') {\n    framework = 'node'; // support nodejs, and node, as framework.\n  }\n\n  var type = global.type;\n  var url,\n      prefix = 'https://' + uri + '.org/dist';\n\n  if (version === 'latest') {\n    url = prefix + '/' + framework + '-' + version + '.tar.gz';\n  } else {\n    url = prefix + '/v' + version + '/' + framework + '-v' + version + '.tar.gz';\n  }\n\n  _log('downloading %s', url);\n\n  var output = fs.createWriteStream(nodeFilePath, {\n    flags: 'w+'\n  }); // need to set user-agent to bypass some corporate firewalls\n\n  var requestOptions = {\n    url: url,\n    headers: {\n      'User-Agent': 'Node.js'\n    }\n  };\n\n  _logProgress(request(requestOptions)).pipe(output);\n\n  output.on('close', function () {\n    next();\n  });\n}",
      "after": "/**\n * download node into the target directory\n */\nasync function downloadNode(next) {\n  if (fs.existsSync(nodeFilePath)) return next();\n  var uri = framework;\n\n  if (framework === 'node') {\n    uri = 'nodejs'; // if node, use nodejs uri\n  } else if (framework === 'nodejs') {\n    framework = 'node'; // support nodejs, and node, as framework.\n  }\n\n  var type = global.type;\n  var url,\n      prefix = 'https://' + uri + '.org/dist';\n\n  if (version === 'latest') {\n    url = prefix + '/' + framework + '-' + version + '.tar.gz';\n  } else {\n    url = prefix + '/v' + version + '/' + framework + '-v' + version + '.tar.gz';\n  }\n\n  _log('downloading %s', url);\n\n  var output = fs.createWriteStream(nodeFilePath, {\n    flags: 'w+'\n  }); // need to set user-agent to bypass some corporate firewalls\n\n  var requestOptions = {\n    url: url,\n    headers: {\n      'User-Agent': 'Node.js'\n    }\n  };\n  (await _logProgress(request(requestOptions))).pipe(output);\n  await output.on('close', function () {\n    next();\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 1102,
      "endLine": 1104,
      "before": "function (resp) {\n  var len = parseInt(resp.headers['content-length'], 10),\n      bar = new ProgressBar('[:bar]', {\n    complete: '=',\n    incomplete: ' ',\n    total: len,\n    width: 100 // just use 100\n\n  });\n  req.on('data', function (chunk) {\n    bar.tick(chunk.length);\n  });\n}",
      "after": "async function (resp) {\n  var len = parseInt(resp.headers['content-length'], 10),\n      bar = new ProgressBar('[:bar]', {\n    complete: '=',\n    incomplete: ' ',\n    total: len,\n    width: 100 // just use 100\n\n  });\n  await req.on('data', function (chunk) {\n    bar.tick(chunk.length);\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 1107,
      "endLine": 1111,
      "before": "/**\n * Log the progress of a request object.\n */\nfunction _logProgress(req) {\n  req.on('response', function (resp) {\n    var len = parseInt(resp.headers['content-length'], 10),\n        bar = new ProgressBar('[:bar]', {\n      complete: '=',\n      incomplete: ' ',\n      total: len,\n      width: 100 // just use 100\n\n    });\n    req.on('data', function (chunk) {\n      bar.tick(chunk.length);\n    });\n  });\n  req.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to download node sources,');\n\n    process.exit(1);\n  });\n  return req;\n}\n/**\n * Attempt to parse the package.json for nexe information.\n *\n * @param {string} path - path to package.json\n * @param {object} options - fallback options\n *\n * @todo implement options overriding package defaults.\n * @todo make this much less hackily implemented....\n *\n * @return {object} nexe.compile - options object\n **/",
      "after": "/**\n * Log the progress of a request object.\n */\nasync function _logProgress(req) {\n  await req.on('response', async function (resp) {\n    var len = parseInt(resp.headers['content-length'], 10),\n        bar = new ProgressBar('[:bar]', {\n      complete: '=',\n      incomplete: ' ',\n      total: len,\n      width: 100 // just use 100\n\n    });\n    await req.on('data', function (chunk) {\n      bar.tick(chunk.length);\n    });\n  });\n  await req.on('error', function (err) {\n    console.log(err);\n\n    _log('error', 'failed to download node sources,');\n\n    process.exit(1);\n  });\n  return req;\n}\n/**\n * Attempt to parse the package.json for nexe information.\n *\n * @param {string} path - path to package.json\n * @param {object} options - fallback options\n *\n * @todo implement options overriding package defaults.\n * @todo make this much less hackily implemented....\n *\n * @return {object} nexe.compile - options object\n **/"
    }
  ],
  "27": [
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 181,
      "endLine": 181,
      "before": "/**\n * Bundle the application into one script\n **/\nfunction combineProject(next) {\n  if (options.noBundle) {\n    _log('using provided bundle %s since noBundle is true', options.input);\n\n    const source = fs.readFileSync(options.input, 'utf8');\n    const thirdPartyMain = `\nif (!process.send) {\n  process.argv.splice(1, 0, 'nexe.js');\n}\n\nconst Module = require('module');\nconst initModule = new Module(process.execPath, null);\ninitModule.paths = Module._nodeModulePaths(process.cwd());\nreturn initModule._compile(${JSON.stringify(source)}, process.execPath);\n        `;\n    fs.writeFileSync(path.join(nodeCompiler.dir, 'lib', '_third_party_main.js'), thirdPartyMain);\n    next();\n  } else {\n    _log('bundle %s', options.input);\n\n    bundle(options.input, nodeCompiler.dir, options, next);\n  }\n}",
      "after": "/**\n * Bundle the application into one script\n **/\nasync function combineProject(next) {\n  if (options.noBundle) {\n    _log('using provided bundle %s since noBundle is true', options.input);\n\n    const source = await fs.promises.readFile(options.input, 'utf8');\n    const thirdPartyMain = `\nif (!process.send) {\n  process.argv.splice(1, 0, 'nexe.js');\n}\n\nconst Module = require('module');\nconst initModule = new Module(process.execPath, null);\ninitModule.paths = Module._nodeModulePaths(process.cwd());\nreturn initModule._compile(${JSON.stringify(source)}, process.execPath);\n        `;\n    fs.writeFileSync(path.join(nodeCompiler.dir, 'lib', '_third_party_main.js'), thirdPartyMain);\n    next();\n  } else {\n    _log('bundle %s', options.input);\n\n    await bundle(options.input, nodeCompiler.dir, options, next);\n  }\n}"
    }
  ],
  "28": [
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 192,
      "endLine": 195,
      "before": "/**\n * Bundle the application into one script\n **/\nfunction combineProject(next) {\n  if (options.noBundle) {\n    _log('using provided bundle %s since noBundle is true', options.input);\n\n    const source = fs.readFileSync(options.input, 'utf8');\n    const thirdPartyMain = `\nif (!process.send) {\n  process.argv.splice(1, 0, 'nexe.js');\n}\n\nconst Module = require('module');\nconst initModule = new Module(process.execPath, null);\ninitModule.paths = Module._nodeModulePaths(process.cwd());\nreturn initModule._compile(${JSON.stringify(source)}, process.execPath);\n        `;\n    fs.writeFileSync(path.join(nodeCompiler.dir, 'lib', '_third_party_main.js'), thirdPartyMain);\n    next();\n  } else {\n    _log('bundle %s', options.input);\n\n    bundle(options.input, nodeCompiler.dir, options, next);\n  }\n}",
      "after": "/**\n * Bundle the application into one script\n **/\nasync function combineProject(next) {\n  if (options.noBundle) {\n    _log('using provided bundle %s since noBundle is true', options.input);\n\n    const source = await fs.promises.readFile(options.input, 'utf8');\n    const thirdPartyMain = `\nif (!process.send) {\n  process.argv.splice(1, 0, 'nexe.js');\n}\n\nconst Module = require('module');\nconst initModule = new Module(process.execPath, null);\ninitModule.paths = Module._nodeModulePaths(process.cwd());\nreturn initModule._compile(${JSON.stringify(source)}, process.execPath);\n        `;\n    await fs.promises.writeFile(path.join(nodeCompiler.dir, 'lib', '_third_party_main.js'), thirdPartyMain);\n    next();\n  } else {\n    _log('bundle %s', options.input);\n\n    await bundle(options.input, nodeCompiler.dir, options, next);\n  }\n}"
    }
  ],
  "29": [
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 204,
      "endLine": 207,
      "before": "function moveLibs(next) {\n  fs.writeFileSync(`${nodeCompiler.dir}/google-closure-compiler-js.js`, fs.readFileSync(`target/google-closure-compiler-js.js`));\n  next();\n}",
      "after": "async function moveLibs(next) {\n  await fs.promises.writeFile(`${nodeCompiler.dir}/google-closure-compiler-js.js`, fs.readFileSync(`target/google-closure-compiler-js.js`));\n  next();\n}"
    }
  ],
  "30": [
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 206,
      "endLine": 206,
      "before": "function moveLibs(next) {\n  fs.writeFileSync(`${nodeCompiler.dir}/google-closure-compiler-js.js`, fs.readFileSync(`target/google-closure-compiler-js.js`));\n  next();\n}",
      "after": "async function moveLibs(next) {\n  await fs.promises.writeFile(`${nodeCompiler.dir}/google-closure-compiler-js.js`, await fs.promises.readFile(`target/google-closure-compiler-js.js`));\n  next();\n}"
    }
  ],
  "31": [
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 616,
      "endLine": 618,
      "before": "function (v, i) {\n  var stat = fs.statSync(dir + '/' + v);\n\n  if (stat.isFile()) {\n    // only process Makefiles and .mk targets.\n    if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n      return;\n    }\n\n    _log('patching ' + v);\n    /* patch the file */\n\n\n    var py = fs.readFileSync(dir + '/' + v, {\n      encoding: 'utf8'\n    });\n    py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n    fs.writeFileSync(dir + '/' + v, py, {\n      encoding: 'utf8'\n    }); // write to file\n  } else if (stat.isDirectory()) {\n    // must be dir?\n    // skip tests because we don't need them here\n    if (v !== 'test') {\n      _loop(dir + '/' + v);\n    }\n  }\n}",
      "after": "async function (v, i) {\n  var stat = fs.statSync(dir + '/' + v);\n\n  if (stat.isFile()) {\n    // only process Makefiles and .mk targets.\n    if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n      return;\n    }\n\n    _log('patching ' + v);\n    /* patch the file */\n\n\n    var py = await fs.promises.readFile(dir + '/' + v, {\n      encoding: 'utf8'\n    });\n    py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n    fs.writeFileSync(dir + '/' + v, py, {\n      encoding: 'utf8'\n    }); // write to file\n  } else if (stat.isDirectory()) {\n    // must be dir?\n    // skip tests because we don't need them here\n    if (v !== 'test') {\n      _loop(dir + '/' + v);\n    }\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 605,
      "endLine": 630,
      "before": "// local function, move to top eventually\nfunction _loop(dir) {\n  /* eventually try every python file */\n  var pdir = fs.readdirSync(dir);\n  pdir.forEach(function (v, i) {\n    var stat = fs.statSync(dir + '/' + v);\n\n    if (stat.isFile()) {\n      // only process Makefiles and .mk targets.\n      if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n        return;\n      }\n\n      _log('patching ' + v);\n      /* patch the file */\n\n\n      var py = fs.readFileSync(dir + '/' + v, {\n        encoding: 'utf8'\n      });\n      py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n      fs.writeFileSync(dir + '/' + v, py, {\n        encoding: 'utf8'\n      }); // write to file\n    } else if (stat.isDirectory()) {\n      // must be dir?\n      // skip tests because we don't need them here\n      if (v !== 'test') {\n        _loop(dir + '/' + v);\n      }\n    }\n  });\n}",
      "after": "// local function, move to top eventually\nasync function _loop(dir) {\n  /* eventually try every python file */\n  var pdir = fs.readdirSync(dir);\n  await pdir.forEach(async function (v, i) {\n    var stat = fs.statSync(dir + '/' + v);\n\n    if (stat.isFile()) {\n      // only process Makefiles and .mk targets.\n      if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n        return;\n      }\n\n      _log('patching ' + v);\n      /* patch the file */\n\n\n      var py = await fs.promises.readFile(dir + '/' + v, {\n        encoding: 'utf8'\n      });\n      py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n      fs.writeFileSync(dir + '/' + v, py, {\n        encoding: 'utf8'\n      }); // write to file\n    } else if (stat.isDirectory()) {\n      // must be dir?\n      // skip tests because we don't need them here\n      if (v !== 'test') {\n        _loop(dir + '/' + v);\n      }\n    }\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 268,
      "endLine": 268,
      "before": "/**\n * compile the node application\n */\nfunction makeExecutable(next) {\n  if (isWin) {\n    _log('vcbuild [make stage]');\n  } else {\n    _log('make');\n  }\n\n  nodeCompiler.make(next);\n}",
      "after": "/**\n * compile the node application\n */\nasync function makeExecutable(next) {\n  if (isWin) {\n    _log('vcbuild [make stage]');\n  } else {\n    _log('make');\n  }\n\n  await nodeCompiler.make(next);\n}"
    }
  ],
  "32": [
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 620,
      "endLine": 622,
      "before": "function (v, i) {\n  var stat = fs.statSync(dir + '/' + v);\n\n  if (stat.isFile()) {\n    // only process Makefiles and .mk targets.\n    if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n      return;\n    }\n\n    _log('patching ' + v);\n    /* patch the file */\n\n\n    var py = fs.readFileSync(dir + '/' + v, {\n      encoding: 'utf8'\n    });\n    py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n    fs.writeFileSync(dir + '/' + v, py, {\n      encoding: 'utf8'\n    }); // write to file\n  } else if (stat.isDirectory()) {\n    // must be dir?\n    // skip tests because we don't need them here\n    if (v !== 'test') {\n      _loop(dir + '/' + v);\n    }\n  }\n}",
      "after": "async function (v, i) {\n  var stat = fs.statSync(dir + '/' + v);\n\n  if (stat.isFile()) {\n    // only process Makefiles and .mk targets.\n    if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n      return;\n    }\n\n    _log('patching ' + v);\n    /* patch the file */\n\n\n    var py = await fs.promises.readFile(dir + '/' + v, {\n      encoding: 'utf8'\n    });\n    py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n    await fs.promises.writeFile(dir + '/' + v, py, {\n      encoding: 'utf8'\n    }); // write to file\n  } else if (stat.isDirectory()) {\n    // must be dir?\n    // skip tests because we don't need them here\n    if (v !== 'test') {\n      _loop(dir + '/' + v);\n    }\n  }\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 605,
      "endLine": 630,
      "before": "// local function, move to top eventually\nfunction _loop(dir) {\n  /* eventually try every python file */\n  var pdir = fs.readdirSync(dir);\n  pdir.forEach(function (v, i) {\n    var stat = fs.statSync(dir + '/' + v);\n\n    if (stat.isFile()) {\n      // only process Makefiles and .mk targets.\n      if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n        return;\n      }\n\n      _log('patching ' + v);\n      /* patch the file */\n\n\n      var py = fs.readFileSync(dir + '/' + v, {\n        encoding: 'utf8'\n      });\n      py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n      fs.writeFileSync(dir + '/' + v, py, {\n        encoding: 'utf8'\n      }); // write to file\n    } else if (stat.isDirectory()) {\n      // must be dir?\n      // skip tests because we don't need them here\n      if (v !== 'test') {\n        _loop(dir + '/' + v);\n      }\n    }\n  });\n}",
      "after": "// local function, move to top eventually\nasync function _loop(dir) {\n  /* eventually try every python file */\n  var pdir = fs.readdirSync(dir);\n  await pdir.forEach(async function (v, i) {\n    var stat = fs.statSync(dir + '/' + v);\n\n    if (stat.isFile()) {\n      // only process Makefiles and .mk targets.\n      if (v !== 'Makefile' && path.extname(v) !== '.mk') {\n        return;\n      }\n\n      _log('patching ' + v);\n      /* patch the file */\n\n\n      var py = await fs.promises.readFile(dir + '/' + v, {\n        encoding: 'utf8'\n      });\n      py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n\n      await fs.promises.writeFile(dir + '/' + v, py, {\n        encoding: 'utf8'\n      }); // write to file\n    } else if (stat.isDirectory()) {\n      // must be dir?\n      // skip tests because we don't need them here\n      if (v !== 'test') {\n        _loop(dir + '/' + v);\n      }\n    }\n  });\n}"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 268,
      "endLine": 268,
      "before": "/**\n * compile the node application\n */\nfunction makeExecutable(next) {\n  if (isWin) {\n    _log('vcbuild [make stage]');\n  } else {\n    _log('make');\n  }\n\n  nodeCompiler.make(next);\n}",
      "after": "/**\n * compile the node application\n */\nasync function makeExecutable(next) {\n  if (isWin) {\n    _log('vcbuild [make stage]');\n  } else {\n    _log('make');\n  }\n\n  await nodeCompiler.make(next);\n}"
    }
  ],
  "33": [
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 849,
      "endLine": 851,
      "before": "/**\n * Patch node.cc to not check the internal arguments.\n */\nfunction _monkeyPatchMainCc(compiler, complete) {\n  let finalContents;\n  let mainPath = path.join(compiler.dir, 'src', 'node.cc');\n  let mainC = fs.readFileSync(mainPath, {\n    encoding: 'utf8'\n  }); // content split, and original start/end\n\n  let constant_loc = 1;\n  let lines = mainC.split('\\n');\n  let startLine = lines.indexOf('  // TODO use parse opts');\n  let endLine = lines.indexOf('  option_end_index = i;'); // pre node 0.11.6 compat\n\n  let isPatched = lines.indexOf('// NEXE_PATCH_IGNOREFLAGS');\n\n  if (isPatched !== -1) {\n    _log('already patched node.cc');\n\n    return complete();\n  }\n  /**\n   * This is the new method of passing the args. Tested on node.js 0.12.5\n   * and iojs 2.3.1\n   **/\n\n\n  if (endLine === -1 && startLine === -1) {\n    // only if the pre-0.12.5 failed.\n    _log('using the after 0.12.5 method of ignoring flags.');\n\n    startLine = lines.indexOf(\"  while (index < nargs && argv[index][0] == '-') {\"); // beginning of the function\n\n    endLine = lines.indexOf('  // Copy remaining arguments.');\n    endLine--; // space, then it's at the }\n\n    constant_loc = lines.length + 1;\n  } else {\n    _log('using 0.10.x > method of ignoring flags');\n\n    lines[endLine] = '  option_end_index = 1;';\n  }\n  /**\n   * This is the method for 5.5.0\n   **/\n\n\n  if (endLine === -1 || startLine === -1) {\n    _log('using the after 5.5.0 method of ignoring flags.');\n\n    startLine = lines.indexOf(\"  while (index < nargs && argv[index][0] == '-' && !short_circuit) {\"); // beginning of the function\n\n    endLine = lines.indexOf('  // Copy remaining arguments.');\n    endLine--; // space, then it's at the }\n\n    constant_loc = lines.length + 1;\n  } // other versions here.\n\n\n  if (endLine === -1 || startLine === -1) {\n    // failsafe.\n    _log('error', 'Failed to find a way to patch node.cc to ignoreFlags');\n\n    _log('startLine =', startLine, '| endLine =', endLine);\n\n    if (!/^1(1|2)\\./.test(compiler.version)) {\n      process.exit(1);\n    }\n  } // check if it's been done\n\n\n  lines[constant_loc] = '// NEXE_PATCH_IGNOREFLAGS';\n\n  for (var i = startLine; i < endLine; i++) {\n    lines[i] = undefined; // set the value to undefined so it's skipped by the join\n  }\n\n  _log('patched node.cc');\n\n  finalContents = lines.join('\\n'); // write the file contents\n\n  fs.writeFile(mainPath, finalContents, {\n    encoding: 'utf8'\n  }, function (err) {\n    if (err) {\n      _log('error', 'failed to write to', mainPath);\n\n      return process.exit(1);\n    }\n\n    return complete();\n  });\n}\n/**\n * Patch flags.cc from deps/v8/src to use hard-coded flags.\n * this function is very closely ready to accept custom injection code.\n **/",
      "after": "/**\n * Patch node.cc to not check the internal arguments.\n */\nasync function _monkeyPatchMainCc(compiler, complete) {\n  let finalContents;\n  let mainPath = path.join(compiler.dir, 'src', 'node.cc');\n  let mainC = await fs.promises.readFile(mainPath, {\n    encoding: 'utf8'\n  }); // content split, and original start/end\n\n  let constant_loc = 1;\n  let lines = mainC.split('\\n');\n  let startLine = lines.indexOf('  // TODO use parse opts');\n  let endLine = lines.indexOf('  option_end_index = i;'); // pre node 0.11.6 compat\n\n  let isPatched = lines.indexOf('// NEXE_PATCH_IGNOREFLAGS');\n\n  if (isPatched !== -1) {\n    _log('already patched node.cc');\n\n    return complete();\n  }\n  /**\n   * This is the new method of passing the args. Tested on node.js 0.12.5\n   * and iojs 2.3.1\n   **/\n\n\n  if (endLine === -1 && startLine === -1) {\n    // only if the pre-0.12.5 failed.\n    _log('using the after 0.12.5 method of ignoring flags.');\n\n    startLine = lines.indexOf(\"  while (index < nargs && argv[index][0] == '-') {\"); // beginning of the function\n\n    endLine = lines.indexOf('  // Copy remaining arguments.');\n    endLine--; // space, then it's at the }\n\n    constant_loc = lines.length + 1;\n  } else {\n    _log('using 0.10.x > method of ignoring flags');\n\n    lines[endLine] = '  option_end_index = 1;';\n  }\n  /**\n   * This is the method for 5.5.0\n   **/\n\n\n  if (endLine === -1 || startLine === -1) {\n    _log('using the after 5.5.0 method of ignoring flags.');\n\n    startLine = lines.indexOf(\"  while (index < nargs && argv[index][0] == '-' && !short_circuit) {\"); // beginning of the function\n\n    endLine = lines.indexOf('  // Copy remaining arguments.');\n    endLine--; // space, then it's at the }\n\n    constant_loc = lines.length + 1;\n  } // other versions here.\n\n\n  if (endLine === -1 || startLine === -1) {\n    // failsafe.\n    _log('error', 'Failed to find a way to patch node.cc to ignoreFlags');\n\n    _log('startLine =', startLine, '| endLine =', endLine);\n\n    if (!/^1(1|2)\\./.test(compiler.version)) {\n      process.exit(1);\n    }\n  } // check if it's been done\n\n\n  lines[constant_loc] = '// NEXE_PATCH_IGNOREFLAGS';\n\n  for (var i = startLine; i < endLine; i++) {\n    lines[i] = undefined; // set the value to undefined so it's skipped by the join\n  }\n\n  _log('patched node.cc');\n\n  finalContents = lines.join('\\n'); // write the file contents\n\n  fs.writeFile(mainPath, finalContents, {\n    encoding: 'utf8'\n  }, function (err) {\n    if (err) {\n      _log('error', 'failed to write to', mainPath);\n\n      return process.exit(1);\n    }\n\n    return complete();\n  });\n}\n/**\n * Patch flags.cc from deps/v8/src to use hard-coded flags.\n * this function is very closely ready to accept custom injection code.\n **/"
    },
    {
      "filename": "/home/osboxes/lumo/vendor/nexe/exe.js",
      "startLine": 225,
      "endLine": 225,
      "before": "/**\n * monkeypatch node.cc to prevent v8 and node from processing CLI flags\n */\nfunction monkeyPatchNodeCc(next) {\n  if (options.flags) {\n    _monkeyPatchMainCc(nodeCompiler, next);\n  } else {\n    next();\n  }\n}",
      "after": "/**\n * monkeypatch node.cc to prevent v8 and node from processing CLI flags\n */\nasync function monkeyPatchNodeCc(next) {\n  if (options.flags) {\n    await _monkeyPatchMainCc(nodeCompiler, next);\n  } else {\n    next();\n  }\n}"
    }
  ]
}