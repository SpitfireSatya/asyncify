
import * as babelParser from '@babel/parser';
import { BabelParser } from './babel-parser';
import * as sinon from 'sinon';
import { expect } from 'chai';
import { Store } from '../store/store';
import { ASTNode } from '../../models/AST-node.model';

describe('plugins > parsers-and-generators', (): void => {
  describe('BabelParser', (): void => {

    describe('generateAST()', (): void => {

      let parserStub: sinon.SinonStub, cacheASTNodesStub: sinon.SinonStub;

      beforeEach((): void => {
        parserStub = sinon.stub(babelParser, 'parse');
        cacheASTNodesStub = sinon.stub(<any>BabelParser, '_cacheASTNodes');
      });

      afterEach((): void => {
        parserStub.restore();
        cacheASTNodesStub.restore();
      });

      it('should invoke babelParser.parse() with the source code, config', (): void => {

        parserStub.returns({});

        BabelParser.generateAST('source code', <any>{}, 'filePath');

        sinon.assert.calledOnceWithExactly(parserStub, 'source code', {});

      });

      it('should invoke _cacheASTNodes() with the ast generated by parser and the file path', (): void => {

        parserStub.returns({});

        BabelParser.generateAST('source code', <any>{}, 'filePath');

        sinon.assert.calledOnceWithExactly(cacheASTNodesStub, {}, 'filePath');

      });

      it('should return the ast generated by parser', (): void => {

        parserStub.returns({});

        const result: any = BabelParser.generateAST('source code', <any>{}, 'filePath');

        expect(result).to.eql({});

      });

      it('should rethrow the error thrown by the parser', (): void => {

        parserStub.throws(new Error('something went wrong'));

        expect((): any => BabelParser.generateAST('', {}, '')).to.throw('something went wrong');

      });

      it('should rethrow the error thrown by the cacheASTNodes', (): void => {

        cacheASTNodesStub.throws(new Error('something went wrong'));

        expect((): any => BabelParser.generateAST('', {}, '')).to.throw('something went wrong');

      });

    });

    describe('[private] _cacheASTNodes()', (): void => {

      const functionDeclarationNode: any = { type: 'FunctionDeclaration', loc: {start: {line: 1, column: 1}, end: {line: 1, column: 1 }}};
      const functionExpressionNode: any = { type: 'FunctionExpression', loc: {start: {line: 1, column: 1}, end: {line: 1, column: 1 }}};
      const arrowFunctionExpressionNode: any = { type: 'ArrowFunctionExpression', loc: {start: {line: 1, column: 1}, end: {line: 1, column: 1 }}}; // tslint:disable-line: max-line-length
      const arrowFunctionDeclarationNode: any = { type: 'ArrowFunctionDeclaration', loc: {start: {line: 1, column: 1}, end: {line: 1, column: 1 }}}; // tslint:disable-line: max-line-length
      const classMethodNode: any = { type: 'ClassMethod', loc: {start: {line: 1, column: 1}, end: {line: 1, column: 1 }}};
      const objectMethodNode: any = { type: 'ObjectMethod', loc: {start: {line: 1, column: 1}, end: {line: 1, column: 1 }}};

      const callExpressionNode: any = { type: 'CallExpression', loc: {start: {line: 1, column: 1}, end: {line: 1, column: 1 }}};
      const memberExpressionNode: any = { type: 'MemberExpression', loc: {start: {line: 1, column: 1}, end: {line: 1, column: 1 }}};

      let setASTNodeStub: sinon.SinonStub;
      const cacheKeyFun: string = 'Fun(file:<1,1>--<1,1>)';
      const cacheKeyCallee: string = 'Callee(file:<1,1>--<1,1>)';

      beforeEach((): void => {
        setASTNodeStub = sinon.stub(Store, 'setASTNode');
      });

      afterEach((): void => {
        setASTNodeStub.restore();
      });

      it('should populate ASTNode and add to store for function declaration', (): void => {

        const ast: any = { key: functionDeclarationNode };

        BabelParser['_cacheASTNodes'](ast, 'file');

        sinon.assert.calledOnceWithExactly(setASTNodeStub, cacheKeyFun, new ASTNode(ast, 'key', 'file', null, ast));

      });

      it('should populate ASTNode and add to store for function expression', (): void => {

        const ast: any = { key: functionExpressionNode };

        BabelParser['_cacheASTNodes'](ast, 'file');

        sinon.assert.calledOnceWithExactly(setASTNodeStub, cacheKeyFun, new ASTNode(ast, 'key', 'file', null, ast));

      });

      it('should populate ASTNode and add to store for arrow function declaration', (): void => {

        const ast: any = { key: arrowFunctionDeclarationNode };

        BabelParser['_cacheASTNodes'](ast, 'file');

        sinon.assert.calledOnceWithExactly(setASTNodeStub, cacheKeyFun, new ASTNode(ast, 'key', 'file', null, ast));

      });

      it('should populate ASTNode and add to store for arrow function expression', (): void => {

        const ast: any = { key: arrowFunctionExpressionNode };

        BabelParser['_cacheASTNodes'](ast, 'file');

        sinon.assert.calledOnceWithExactly(setASTNodeStub, cacheKeyFun, new ASTNode(ast, 'key', 'file', null, ast));

      });

      it('should populate ASTNode and add to store for class method', (): void => {

        const ast: any = { key: classMethodNode };

        BabelParser['_cacheASTNodes'](ast, 'file');

        sinon.assert.calledOnceWithExactly(setASTNodeStub, cacheKeyFun, new ASTNode(ast, 'key', 'file', null, ast));

      });

      it('should populate ASTNode and add to store for object method', (): void => {

        const ast: any = { key: objectMethodNode };

        BabelParser['_cacheASTNodes'](ast, 'file');

        sinon.assert.calledOnceWithExactly(setASTNodeStub, cacheKeyFun, new ASTNode(ast, 'key', 'file', null, ast));

      });

      it('should populate ASTNode and add to store for call expression', (): void => {

        const ast: any = { key: callExpressionNode };

        BabelParser['_cacheASTNodes'](ast, 'file');

        sinon.assert.calledOnceWithExactly(setASTNodeStub, cacheKeyCallee, new ASTNode(ast, 'key', 'file', null, ast));

      });

      it('should populate ASTNode and add to store for member expression', (): void => {

        const ast: any = { key: memberExpressionNode };

        BabelParser['_cacheASTNodes'](ast, 'file');

        sinon.assert.calledOnceWithExactly(setASTNodeStub, cacheKeyCallee, new ASTNode(ast, 'key', 'file', null, ast));

      });

      it('should populate parent function for node if present', (): void => {

        const ast: any = { key: { ...functionDeclarationNode, body: { key1: objectMethodNode }, data: null }};

        BabelParser['_cacheASTNodes'](ast, 'file');

        sinon.assert.calledWithMatch(setASTNodeStub.secondCall, cacheKeyFun, new ASTNode(ast.key.body, 'key1', 'file', ast.key, ast));

      });

      it('should do nothing if astNode is null', (): void => {

        const ast: any = null;

        BabelParser['_cacheASTNodes'](ast, 'file');

        sinon.assert.notCalled(setASTNodeStub);

      });

    });

  });
});
